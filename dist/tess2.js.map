{"version":3,"file":"tess2.js","sources":["../src/tess2.js"],"sourcesContent":["/*\r\n** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) \r\n** Copyright (C) [dates of first publication] Silicon Graphics, Inc.\r\n** All Rights Reserved.\r\n**\r\n** Permission is hereby granted, free of charge, to any person obtaining a copy\r\n** of this software and associated documentation files (the \"Software\"), to deal\r\n** in the Software without restriction, including without limitation the rights\r\n** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n** of the Software, and to permit persons to whom the Software is furnished to do so,\r\n** subject to the following conditions:\r\n** \r\n** The above copyright notice including the dates of first publication and either this\r\n** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be\r\n** included in all copies or substantial portions of the Software. \r\n**\r\n** THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.\r\n** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\r\n** OR OTHER DEALINGS IN THE SOFTWARE.\r\n** \r\n** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not\r\n** be used in advertising or otherwise to promote the sale, use or other dealings in\r\n** this Software without prior written authorization from Silicon Graphics, Inc.\r\n*/\r\n/*\r\n** Author: Mikko Mononen, Aug 2013.\r\n** The code is based on GLU libtess by Eric Veach, July 1994\r\n*/\r\n\r\n\t\"use strict\";\r\n\r\n\t/* Public API */\r\n\r\n\tvar Tess2 = {};\r\n\tvar Geom = {};\r\n\r\n\texport default Tess2;\r\n\t\r\n\tTess2.WINDING_ODD = 0;\r\n\tTess2.WINDING_NONZERO = 1;\r\n\tTess2.WINDING_POSITIVE = 2;\r\n\tTess2.WINDING_NEGATIVE = 3;\r\n\tTess2.WINDING_ABS_GEQ_TWO = 4;\r\n\r\n\tTess2.POLYGONS = 0;\r\n\tTess2.CONNECTED_POLYGONS = 1;\r\n\tTess2.BOUNDARY_CONTOURS = 2;\r\n\r\n\tTess2.tesselate = function(opts) {\r\n\t\tvar debug =  opts.debug || false;\r\n\t\tvar tess = new Tesselator();\r\n\t\tfor (var i = 0; i < opts.contours.length; i++) {\r\n\t\t\ttess.addContour(opts.vertexSize || 2, opts.contours[i]);\r\n\t\t}\r\n\t\ttess.tesselate(opts.windingRule || Tess2.WINDING_ODD,\r\n\t\t\t\t\t   opts.elementType || Tess2.POLYGONS,\r\n\t\t\t\t\t   opts.polySize || 3,\r\n\t\t\t\t\t   opts.vertexSize || 2,\r\n\t\t\t\t\t   opts.normal || [0,0,1]);\r\n\t\treturn {\r\n\t\t\tvertices: tess.vertices,\r\n\t\t\tvertexIndices: tess.vertexIndices,\r\n\t\t\tvertexCount: tess.vertexCount,\r\n\t\t\telements: tess.elements,\r\n\t\t\telementCount: tess.elementCount,\r\n\t\t\tmesh: debug ? tess.mesh : undefined\r\n\t\t};\r\n\t};\r\n\r\n\t/* Internal */\r\n\r\n\tvar assert = function(cond) {\r\n\t\tif (!cond) {\r\n\t\t\tthrow \"Assertion Failed!\";\r\n\t\t}\r\n\t}\r\n\r\n\t/* The mesh structure is similar in spirit, notation, and operations\r\n\t* to the \"quad-edge\" structure (see L. Guibas and J. Stolfi, Primitives\r\n\t* for the manipulation of general subdivisions and the computation of\r\n\t* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).\r\n\t* For a simplified description, see the course notes for CS348a,\r\n\t* \"Mathematical Foundations of Computer Graphics\", available at the\r\n\t* Stanford bookstore (and taught during the fall quarter).\r\n\t* The implementation also borrows a tiny subset of the graph-based approach\r\n\t* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction\r\n\t* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).\r\n\t*\r\n\t* The fundamental data structure is the \"half-edge\".  Two half-edges\r\n\t* go together to make an edge, but they point in opposite directions.\r\n\t* Each half-edge has a pointer to its mate (the \"symmetric\" half-edge Sym),\r\n\t* its origin vertex (Org), the face on its left side (Lface), and the\r\n\t* adjacent half-edges in the CCW direction around the origin vertex\r\n\t* (Onext) and around the left face (Lnext).  There is also a \"next\"\r\n\t* pointer for the global edge list (see below).\r\n\t*\r\n\t* The notation used for mesh navigation:\r\n\t*  Sym   = the mate of a half-edge (same edge, but opposite direction)\r\n\t*  Onext = edge CCW around origin vertex (keep same origin)\r\n\t*  Dnext = edge CCW around destination vertex (keep same dest)\r\n\t*  Lnext = edge CCW around left face (dest becomes new origin)\r\n\t*  Rnext = edge CCW around right face (origin becomes new dest)\r\n\t*\r\n\t* \"prev\" means to substitute CW for CCW in the definitions above.\r\n\t*\r\n\t* The mesh keeps global lists of all vertices, faces, and edges,\r\n\t* stored as doubly-linked circular lists with a dummy header node.\r\n\t* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).\r\n\t*\r\n\t* The circular edge list is special; since half-edges always occur\r\n\t* in pairs (e and e->Sym), each half-edge stores a pointer in only\r\n\t* one direction.  Starting at eHead and following the e->next pointers\r\n\t* will visit each *edge* once (ie. e or e->Sym, but not both).\r\n\t* e->Sym stores a pointer in the opposite direction, thus it is\r\n\t* always true that e->Sym->next->Sym->next == e.\r\n\t*\r\n\t* Each vertex has a pointer to next and previous vertices in the\r\n\t* circular list, and a pointer to a half-edge with this vertex as\r\n\t* the origin (NULL if this is the dummy header).  There is also a\r\n\t* field \"data\" for client data.\r\n\t*\r\n\t* Each face has a pointer to the next and previous faces in the\r\n\t* circular list, and a pointer to a half-edge with this face as\r\n\t* the left face (NULL if this is the dummy header).  There is also\r\n\t* a field \"data\" for client data.\r\n\t*\r\n\t* Note that what we call a \"face\" is really a loop; faces may consist\r\n\t* of more than one loop (ie. not simply connected), but there is no\r\n\t* record of this in the data structure.  The mesh may consist of\r\n\t* several disconnected regions, so it may not be possible to visit\r\n\t* the entire mesh by starting at a half-edge and traversing the edge\r\n\t* structure.\r\n\t*\r\n\t* The mesh does NOT support isolated vertices; a vertex is deleted along\r\n\t* with its last edge.  Similarly when two faces are merged, one of the\r\n\t* faces is deleted (see tessMeshDelete below).  For mesh operations,\r\n\t* all face (loop) and vertex pointers must not be NULL.  However, once\r\n\t* mesh manipulation is finished, TESSmeshZapFace can be used to delete\r\n\t* faces of the mesh, one at a time.  All external faces can be \"zapped\"\r\n\t* before the mesh is returned to the client; then a NULL face indicates\r\n\t* a region which is not part of the output polygon.\r\n\t*/\r\n\r\n\tfunction TESSvertex() {\r\n\t\tthis.next = null;\t/* next vertex (never NULL) */\r\n\t\tthis.prev = null;\t/* previous vertex (never NULL) */\r\n\t\tthis.anEdge = null;\t/* a half-edge with this origin */\r\n\r\n\t\t/* Internal data (keep hidden) */\r\n\t\tthis.coords = [0,0,0];\t/* vertex location in 3D */\r\n\t\tthis.s = 0.0;\r\n\t\tthis.t = 0.0;\t\t\t/* projection onto the sweep plane */\r\n\t\tthis.pqHandle = 0;\t\t/* to allow deletion from priority queue */\r\n\t\tthis.n = 0;\t\t\t\t/* to allow identify unique vertices */\r\n\t\tthis.idx = 0;\t\t\t/* to allow map result to original verts */\r\n\t} \r\n\r\n\tfunction TESSface() {\r\n\t\tthis.next = null;\t\t/* next face (never NULL) */\r\n\t\tthis.prev = null;\t\t/* previous face (never NULL) */\r\n\t\tthis.anEdge = null;\t\t/* a half edge with this left face */\r\n\r\n\t\t/* Internal data (keep hidden) */\r\n\t\tthis.trail = null;\t\t/* \"stack\" for conversion to strips */\r\n\t\tthis.n = 0;\t\t\t\t/* to allow identiy unique faces */\r\n\t\tthis.marked = false;\t/* flag for conversion to strips */\r\n\t\tthis.inside = false;\t/* this face is in the polygon interior */\r\n\t};\r\n\r\n\tfunction TESShalfEdge(side) {\r\n\t\tthis.next = null;\t\t/* doubly-linked list (prev==Sym->next) */\r\n\t\tthis.Sym = null;\t\t/* same edge, opposite direction */\r\n\t\tthis.Onext = null;\t\t/* next edge CCW around origin */\r\n\t\tthis.Lnext = null;\t\t/* next edge CCW around left face */\r\n\t\tthis.Org = null;\t\t/* origin vertex (Overtex too long) */\r\n\t\tthis.Lface = null;\t\t/* left face */\r\n\r\n\t\t/* Internal data (keep hidden) */\r\n\t\tthis.activeRegion = null;\t/* a region with this upper edge (sweep.c) */\r\n\t\tthis.winding = 0;\t\t\t/* change in winding number when crossing\r\n\t\t\t\t\t\t\t\t\t   from the right face to the left face */\r\n\t\tthis.side = side;\r\n\t};\r\n\r\n\tTESShalfEdge.prototype = {\r\n\t\tget Rface() { return this.Sym.Lface; },\r\n\t\tset Rface(v) { this.Sym.Lface = v; },\r\n\t\tget Dst() { return this.Sym.Org; },\r\n\t\tset Dst(v) { this.Sym.Org = v; },\r\n\t\tget Oprev() { return this.Sym.Lnext; },\r\n\t\tset Oprev(v) { this.Sym.Lnext = v; },\r\n\t\tget Lprev() { return this.Onext.Sym; },\r\n\t\tset Lprev(v) { this.Onext.Sym = v; },\r\n\t\tget Dprev() { return this.Lnext.Sym; },\r\n\t\tset Dprev(v) { this.Lnext.Sym = v; },\r\n\t\tget Rprev() { return this.Sym.Onext; },\r\n\t\tset Rprev(v) { this.Sym.Onext = v; },\r\n\t\tget Dnext() { return /*this.Rprev*/this.Sym.Onext.Sym; },  /* 3 pointers */\r\n\t\tset Dnext(v) { /*this.Rprev*/this.Sym.Onext.Sym = v; },  /* 3 pointers */\r\n\t\tget Rnext() { return /*this.Oprev*/this.Sym.Lnext.Sym; },  /* 3 pointers */\r\n\t\tset Rnext(v) { /*this.Oprev*/this.Sym.Lnext.Sym = v; },  /* 3 pointers */\r\n\t};\r\n\r\n\r\n\r\n\tfunction TESSmesh() {\r\n\t\tvar v = new TESSvertex();\r\n\t\tvar f = new TESSface();\r\n\t\tvar e = new TESShalfEdge(0);\r\n\t\tvar eSym = new TESShalfEdge(1);\r\n\r\n\t\tv.next = v.prev = v;\r\n\t\tv.anEdge = null;\r\n\r\n\t\tf.next = f.prev = f;\r\n\t\tf.anEdge = null;\r\n\t\tf.trail = null;\r\n\t\tf.marked = false;\r\n\t\tf.inside = false;\r\n\r\n\t\te.next = e;\r\n\t\te.Sym = eSym;\r\n\t\te.Onext = null;\r\n\t\te.Lnext = null;\r\n\t\te.Org = null;\r\n\t\te.Lface = null;\r\n\t\te.winding = 0;\r\n\t\te.activeRegion = null;\r\n\r\n\t\teSym.next = eSym;\r\n\t\teSym.Sym = e;\r\n\t\teSym.Onext = null;\r\n\t\teSym.Lnext = null;\r\n\t\teSym.Org = null;\r\n\t\teSym.Lface = null;\r\n\t\teSym.winding = 0;\r\n\t\teSym.activeRegion = null;\r\n\r\n\t\tthis.vHead = v;\t\t/* dummy header for vertex list */\r\n\t\tthis.fHead = f;\t\t/* dummy header for face list */\r\n\t\tthis.eHead = e;\t\t/* dummy header for edge list */\r\n\t\tthis.eHeadSym = eSym;\t/* and its symmetric counterpart */\r\n\t};\r\n\r\n\t/* The mesh operations below have three motivations: completeness,\r\n\t* convenience, and efficiency.  The basic mesh operations are MakeEdge,\r\n\t* Splice, and Delete.  All the other edge operations can be implemented\r\n\t* in terms of these.  The other operations are provided for convenience\r\n\t* and/or efficiency.\r\n\t*\r\n\t* When a face is split or a vertex is added, they are inserted into the\r\n\t* global list *before* the existing vertex or face (ie. e->Org or e->Lface).\r\n\t* This makes it easier to process all vertices or faces in the global lists\r\n\t* without worrying about processing the same data twice.  As a convenience,\r\n\t* when a face is split, the \"inside\" flag is copied from the old face.\r\n\t* Other internal data (v->data, v->activeRegion, f->data, f->marked,\r\n\t* f->trail, e->winding) is set to zero.\r\n\t*\r\n\t* ********************** Basic Edge Operations **************************\r\n\t*\r\n\t* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.\r\n\t* The loop (face) consists of the two new half-edges.\r\n\t*\r\n\t* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the\r\n\t* mesh connectivity and topology.  It changes the mesh so that\r\n\t*  eOrg->Onext <- OLD( eDst->Onext )\r\n\t*  eDst->Onext <- OLD( eOrg->Onext )\r\n\t* where OLD(...) means the value before the meshSplice operation.\r\n\t*\r\n\t* This can have two effects on the vertex structure:\r\n\t*  - if eOrg->Org != eDst->Org, the two vertices are merged together\r\n\t*  - if eOrg->Org == eDst->Org, the origin is split into two vertices\r\n\t* In both cases, eDst->Org is changed and eOrg->Org is untouched.\r\n\t*\r\n\t* Similarly (and independently) for the face structure,\r\n\t*  - if eOrg->Lface == eDst->Lface, one loop is split into two\r\n\t*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\r\n\t* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\r\n\t*\r\n\t* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\r\n\t* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\r\n\t* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\r\n\t* the newly created loop will contain eDel->Dst.  If the deletion of eDel\r\n\t* would create isolated vertices, those are deleted as well.\r\n\t*\r\n\t* ********************** Other Edge Operations **************************\r\n\t*\r\n\t* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that\r\n\t* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\r\n\t* eOrg and eNew will have the same left face.\r\n\t*\r\n\t* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\r\n\t* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\r\n\t* eOrg and eNew will have the same left face.\r\n\t*\r\n\t* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\r\n\t* to eDst->Org, and returns the corresponding half-edge eNew.\r\n\t* If eOrg->Lface == eDst->Lface, this splits one loop into two,\r\n\t* and the newly created loop is eNew->Lface.  Otherwise, two disjoint\r\n\t* loops are merged into one, and the loop eDst->Lface is destroyed.\r\n\t*\r\n\t* ************************ Other Operations *****************************\r\n\t*\r\n\t* tessMeshNewMesh() creates a new mesh with no edges, no vertices,\r\n\t* and no loops (what we usually call a \"face\").\r\n\t*\r\n\t* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in\r\n\t* both meshes, and returns the new mesh (the old meshes are destroyed).\r\n\t*\r\n\t* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.\r\n\t*\r\n\t* tessMeshZapFace( fZap ) destroys a face and removes it from the\r\n\t* global face list.  All edges of fZap will have a NULL pointer as their\r\n\t* left face.  Any edges which also have a NULL pointer as their right face\r\n\t* are deleted entirely (along with any isolated vertices this produces).\r\n\t* An entire mesh can be deleted by zapping its faces, one at a time,\r\n\t* in any order.  Zapped faces cannot be used in further mesh operations!\r\n\t*\r\n\t* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\r\n\t*/\r\n\r\n\tTESSmesh.prototype = {\r\n\r\n\t\t/* MakeEdge creates a new pair of half-edges which form their own loop.\r\n\t\t* No vertex or face structures are allocated, but these must be assigned\r\n\t\t* before the current edge operation is completed.\r\n\t\t*/\r\n\t\t//static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )\r\n\t\tmakeEdge_: function(eNext) {\r\n\t\t\tvar e = new TESShalfEdge(0);\r\n\t\t\tvar eSym = new TESShalfEdge(1);\r\n\r\n\t\t\t/* Make sure eNext points to the first edge of the edge pair */\r\n\t\t\tif( eNext.Sym.side < eNext.side ) { eNext = eNext.Sym; }\r\n\r\n\t\t\t/* Insert in circular doubly-linked list before eNext.\r\n\t\t\t* Note that the prev pointer is stored in Sym->next.\r\n\t\t\t*/\r\n\t\t\tvar ePrev = eNext.Sym.next;\r\n\t\t\teSym.next = ePrev;\r\n\t\t\tePrev.Sym.next = e;\r\n\t\t\te.next = eNext;\r\n\t\t\teNext.Sym.next = eSym;\r\n\r\n\t\t\te.Sym = eSym;\r\n\t\t\te.Onext = e;\r\n\t\t\te.Lnext = eSym;\r\n\t\t\te.Org = null;\r\n\t\t\te.Lface = null;\r\n\t\t\te.winding = 0;\r\n\t\t\te.activeRegion = null;\r\n\r\n\t\t\teSym.Sym = e;\r\n\t\t\teSym.Onext = eSym;\r\n\t\t\teSym.Lnext = e;\r\n\t\t\teSym.Org = null;\r\n\t\t\teSym.Lface = null;\r\n\t\t\teSym.winding = 0;\r\n\t\t\teSym.activeRegion = null;\r\n\r\n\t\t\treturn e;\r\n\t\t},\r\n\r\n\t\t/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the\r\n\t\t* CS348a notes (see mesh.h).  Basically it modifies the mesh so that\r\n\t\t* a->Onext and b->Onext are exchanged.  This can have various effects\r\n\t\t* depending on whether a and b belong to different face or vertex rings.\r\n\t\t* For more explanation see tessMeshSplice() below.\r\n\t\t*/\r\n\t\t// static void Splice( TESShalfEdge *a, TESShalfEdge *b )\r\n\t\tsplice_: function(a, b) {\r\n\t\t\tvar aOnext = a.Onext;\r\n\t\t\tvar bOnext = b.Onext;\r\n\t\t\taOnext.Sym.Lnext = b;\r\n\t\t\tbOnext.Sym.Lnext = a;\r\n\t\t\ta.Onext = bOnext;\r\n\t\t\tb.Onext = aOnext;\r\n\t\t},\r\n\r\n\t\t/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the\r\n\t\t* origin of all edges in the vertex loop to which eOrig belongs. \"vNext\" gives\r\n\t\t* a place to insert the new vertex in the global vertex list.  We insert\r\n\t\t* the new vertex *before* vNext so that algorithms which walk the vertex\r\n\t\t* list will not see the newly created vertices.\r\n\t\t*/\r\n\t\t//static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )\r\n\t\tmakeVertex_: function(newVertex, eOrig, vNext) {\r\n\t\t\tvar vNew = newVertex;\r\n\t\t\tassert(vNew !== null);\r\n\r\n\t\t\t/* insert in circular doubly-linked list before vNext */\r\n\t\t\tvar vPrev = vNext.prev;\r\n\t\t\tvNew.prev = vPrev;\r\n\t\t\tvPrev.next = vNew;\r\n\t\t\tvNew.next = vNext;\r\n\t\t\tvNext.prev = vNew;\r\n\r\n\t\t\tvNew.anEdge = eOrig;\r\n\t\t\t/* leave coords, s, t undefined */\r\n\r\n\t\t\t/* fix other edges on this vertex loop */\r\n\t\t\tvar e = eOrig;\r\n\t\t\tdo {\r\n\t\t\t\te.Org = vNew;\r\n\t\t\t\te = e.Onext;\r\n\t\t\t} while(e !== eOrig);\r\n\t\t},\r\n\r\n\t\t/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left\r\n\t\t* face of all edges in the face loop to which eOrig belongs.  \"fNext\" gives\r\n\t\t* a place to insert the new face in the global face list.  We insert\r\n\t\t* the new face *before* fNext so that algorithms which walk the face\r\n\t\t* list will not see the newly created faces.\r\n\t\t*/\r\n\t\t// static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )\r\n\t\tmakeFace_: function(newFace, eOrig, fNext) {\r\n\t\t\tvar fNew = newFace;\r\n\t\t\tassert(fNew !== null); \r\n\r\n\t\t\t/* insert in circular doubly-linked list before fNext */\r\n\t\t\tvar fPrev = fNext.prev;\r\n\t\t\tfNew.prev = fPrev;\r\n\t\t\tfPrev.next = fNew;\r\n\t\t\tfNew.next = fNext;\r\n\t\t\tfNext.prev = fNew;\r\n\r\n\t\t\tfNew.anEdge = eOrig;\r\n\t\t\tfNew.trail = null;\r\n\t\t\tfNew.marked = false;\r\n\r\n\t\t\t/* The new face is marked \"inside\" if the old one was.  This is a\r\n\t\t\t* convenience for the common case where a face has been split in two.\r\n\t\t\t*/\r\n\t\t\tfNew.inside = fNext.inside;\r\n\r\n\t\t\t/* fix other edges on this face loop */\r\n\t\t\tvar e = eOrig;\r\n\t\t\tdo {\r\n\t\t\t\te.Lface = fNew;\r\n\t\t\t\te = e.Lnext;\r\n\t\t\t} while(e !== eOrig);\r\n\t\t},\r\n\r\n\t\t/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),\r\n\t\t* and removes from the global edge list.\r\n\t\t*/\r\n\t\t//static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )\r\n\t\tkillEdge_: function(eDel) {\r\n\t\t\t/* Half-edges are allocated in pairs, see EdgePair above */\r\n\t\t\tif( eDel.Sym.side < eDel.side ) { eDel = eDel.Sym; }\r\n\r\n\t\t\t/* delete from circular doubly-linked list */\r\n\t\t\tvar eNext = eDel.next;\r\n\t\t\tvar ePrev = eDel.Sym.next;\r\n\t\t\teNext.Sym.next = ePrev;\r\n\t\t\tePrev.Sym.next = eNext;\r\n\t\t},\r\n\r\n\r\n\t\t/* KillVertex( vDel ) destroys a vertex and removes it from the global\r\n\t\t* vertex list.  It updates the vertex loop to point to a given new vertex.\r\n\t\t*/\r\n\t\t//static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )\r\n\t\tkillVertex_: function(vDel, newOrg) {\r\n\t\t\tvar eStart = vDel.anEdge;\r\n\t\t\t/* change the origin of all affected edges */\r\n\t\t\tvar e = eStart;\r\n\t\t\tdo {\r\n\t\t\t\te.Org = newOrg;\r\n\t\t\t\te = e.Onext;\r\n\t\t\t} while(e !== eStart);\r\n\r\n\t\t\t/* delete from circular doubly-linked list */\r\n\t\t\tvar vPrev = vDel.prev;\r\n\t\t\tvar vNext = vDel.next;\r\n\t\t\tvNext.prev = vPrev;\r\n\t\t\tvPrev.next = vNext;\r\n\t\t},\r\n\r\n\t\t/* KillFace( fDel ) destroys a face and removes it from the global face\r\n\t\t* list.  It updates the face loop to point to a given new face.\r\n\t\t*/\r\n\t\t//static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )\r\n\t\tkillFace_: function(fDel, newLface) {\r\n\t\t\tvar eStart = fDel.anEdge;\r\n\r\n\t\t\t/* change the left face of all affected edges */\r\n\t\t\tvar e = eStart;\r\n\t\t\tdo {\r\n\t\t\t\te.Lface = newLface;\r\n\t\t\t\te = e.Lnext;\r\n\t\t\t} while(e !== eStart);\r\n\r\n\t\t\t/* delete from circular doubly-linked list */\r\n\t\t\tvar fPrev = fDel.prev;\r\n\t\t\tvar fNext = fDel.next;\r\n\t\t\tfNext.prev = fPrev;\r\n\t\t\tfPrev.next = fNext;\r\n\t\t},\r\n\r\n\t\t/****************** Basic Edge Operations **********************/\r\n\r\n\t\t/* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).\r\n\t\t* The loop consists of the two new half-edges.\r\n\t\t*/\r\n\t\t//TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )\r\n\t\tmakeEdge: function() {\r\n\t\t\tvar newVertex1 = new TESSvertex();\r\n\t\t\tvar newVertex2 = new TESSvertex();\r\n\t\t\tvar newFace = new TESSface();\r\n\t\t\tvar e = this.makeEdge_( this.eHead);\r\n\t\t\tthis.makeVertex_( newVertex1, e, this.vHead );\r\n\t\t\tthis.makeVertex_( newVertex2, e.Sym, this.vHead );\r\n\t\t\tthis.makeFace_( newFace, e, this.fHead );\r\n\t\t\treturn e;\r\n\t\t},\r\n\r\n\t\t/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the\r\n\t\t* mesh connectivity and topology.  It changes the mesh so that\r\n\t\t*\teOrg->Onext <- OLD( eDst->Onext )\r\n\t\t*\teDst->Onext <- OLD( eOrg->Onext )\r\n\t\t* where OLD(...) means the value before the meshSplice operation.\r\n\t\t*\r\n\t\t* This can have two effects on the vertex structure:\r\n\t\t*  - if eOrg->Org != eDst->Org, the two vertices are merged together\r\n\t\t*  - if eOrg->Org == eDst->Org, the origin is split into two vertices\r\n\t\t* In both cases, eDst->Org is changed and eOrg->Org is untouched.\r\n\t\t*\r\n\t\t* Similarly (and independently) for the face structure,\r\n\t\t*  - if eOrg->Lface == eDst->Lface, one loop is split into two\r\n\t\t*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\r\n\t\t* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\r\n\t\t*\r\n\t\t* Some special cases:\r\n\t\t* If eDst == eOrg, the operation has no effect.\r\n\t\t* If eDst == eOrg->Lnext, the new face will have a single edge.\r\n\t\t* If eDst == eOrg->Lprev, the old face will have a single edge.\r\n\t\t* If eDst == eOrg->Onext, the new vertex will have a single edge.\r\n\t\t* If eDst == eOrg->Oprev, the old vertex will have a single edge.\r\n\t\t*/\r\n\t\t//int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )\r\n\t\tsplice: function(eOrg, eDst) {\r\n\t\t\tvar joiningLoops = false;\r\n\t\t\tvar joiningVertices = false;\r\n\r\n\t\t\tif( eOrg === eDst ) return;\r\n\r\n\t\t\tif( eDst.Org !== eOrg.Org ) {\r\n\t\t\t\t/* We are merging two disjoint vertices -- destroy eDst->Org */\r\n\t\t\t\tjoiningVertices = true;\r\n\t\t\t\tthis.killVertex_( eDst.Org, eOrg.Org );\r\n\t\t\t}\r\n\t\t\tif( eDst.Lface !== eOrg.Lface ) {\r\n\t\t\t\t/* We are connecting two disjoint loops -- destroy eDst->Lface */\r\n\t\t\t\tjoiningLoops = true;\r\n\t\t\t\tthis.killFace_( eDst.Lface, eOrg.Lface );\r\n\t\t\t}\r\n\r\n\t\t\t/* Change the edge structure */\r\n\t\t\tthis.splice_( eDst, eOrg );\r\n\r\n\t\t\tif( ! joiningVertices ) {\r\n\t\t\t\tvar newVertex = new TESSvertex();\r\n\r\n\t\t\t\t/* We split one vertex into two -- the new vertex is eDst->Org.\r\n\t\t\t\t* Make sure the old vertex points to a valid half-edge.\r\n\t\t\t\t*/\r\n\t\t\t\tthis.makeVertex_( newVertex, eDst, eOrg.Org );\r\n\t\t\t\teOrg.Org.anEdge = eOrg;\r\n\t\t\t}\r\n\t\t\tif( ! joiningLoops ) {\r\n\t\t\t\tvar newFace = new TESSface();  \r\n\r\n\t\t\t\t/* We split one loop into two -- the new loop is eDst->Lface.\r\n\t\t\t\t* Make sure the old face points to a valid half-edge.\r\n\t\t\t\t*/\r\n\t\t\t\tthis.makeFace_( newFace, eDst, eOrg.Lface );\r\n\t\t\t\teOrg.Lface.anEdge = eOrg;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\r\n\t\t* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\r\n\t\t* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\r\n\t\t* the newly created loop will contain eDel->Dst.  If the deletion of eDel\r\n\t\t* would create isolated vertices, those are deleted as well.\r\n\t\t*\r\n\t\t* This function could be implemented as two calls to tessMeshSplice\r\n\t\t* plus a few calls to memFree, but this would allocate and delete\r\n\t\t* unnecessary vertices and faces.\r\n\t\t*/\r\n\t\t//int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )\r\n\t\tdelete: function(eDel) {\r\n\t\t\tvar eDelSym = eDel.Sym;\r\n\t\t\tvar joiningLoops = false;\r\n\r\n\t\t\t/* First step: disconnect the origin vertex eDel->Org.  We make all\r\n\t\t\t* changes to get a consistent mesh in this \"intermediate\" state.\r\n\t\t\t*/\r\n\t\t\tif( eDel.Lface !== eDel.Rface ) {\r\n\t\t\t\t/* We are joining two loops into one -- remove the left face */\r\n\t\t\t\tjoiningLoops = true;\r\n\t\t\t\tthis.killFace_( eDel.Lface, eDel.Rface );\r\n\t\t\t}\r\n\r\n\t\t\tif( eDel.Onext === eDel ) {\r\n\t\t\t\tthis.killVertex_( eDel.Org, null );\r\n\t\t\t} else {\r\n\t\t\t\t/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */\r\n\t\t\t\teDel.Rface.anEdge = eDel.Oprev;\r\n\t\t\t\teDel.Org.anEdge = eDel.Onext;\r\n\r\n\t\t\t\tthis.splice_( eDel, eDel.Oprev );\r\n\t\t\t\tif( ! joiningLoops ) {\r\n\t\t\t\t\tvar newFace = new TESSface();\r\n\r\n\t\t\t\t\t/* We are splitting one loop into two -- create a new loop for eDel. */\r\n\t\t\t\t\tthis.makeFace_( newFace, eDel, eDel.Lface );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Claim: the mesh is now in a consistent state, except that eDel->Org\r\n\t\t\t* may have been deleted.  Now we disconnect eDel->Dst.\r\n\t\t\t*/\r\n\t\t\tif( eDelSym.Onext === eDelSym ) {\r\n\t\t\t\tthis.killVertex_( eDelSym.Org, null );\r\n\t\t\t\tthis.killFace_( eDelSym.Lface, null );\r\n\t\t\t} else {\r\n\t\t\t\t/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */\r\n\t\t\t\teDel.Lface.anEdge = eDelSym.Oprev;\r\n\t\t\t\teDelSym.Org.anEdge = eDelSym.Onext;\r\n\t\t\t\tthis.splice_( eDelSym, eDelSym.Oprev );\r\n\t\t\t}\r\n\r\n\t\t\t/* Any isolated vertices or faces have already been freed. */\r\n\t\t\tthis.killEdge_( eDel );\r\n\t\t},\r\n\r\n\t\t/******************** Other Edge Operations **********************/\r\n\r\n\t\t/* All these routines can be implemented with the basic edge\r\n\t\t* operations above.  They are provided for convenience and efficiency.\r\n\t\t*/\r\n\r\n\r\n\t\t/* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that\r\n\t\t* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\r\n\t\t* eOrg and eNew will have the same left face.\r\n\t\t*/\r\n\t\t// TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );\r\n\t\taddEdgeVertex: function(eOrg) {\r\n\t\t\tvar eNew = this.makeEdge_( eOrg );\r\n\t\t\tvar eNewSym = eNew.Sym;\r\n\r\n\t\t\t/* Connect the new edge appropriately */\r\n\t\t\tthis.splice_( eNew, eOrg.Lnext );\r\n\r\n\t\t\t/* Set the vertex and face information */\r\n\t\t\teNew.Org = eOrg.Dst;\r\n\r\n\t\t\tvar newVertex = new TESSvertex();\r\n\t\t\tthis.makeVertex_( newVertex, eNewSym, eNew.Org );\r\n\r\n\t\t\teNew.Lface = eNewSym.Lface = eOrg.Lface;\r\n\r\n\t\t\treturn eNew;\r\n\t\t},\r\n\r\n\r\n\t\t/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\r\n\t\t* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\r\n\t\t* eOrg and eNew will have the same left face.\r\n\t\t*/\r\n\t\t// TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );\r\n\t\tsplitEdge: function(eOrg, eDst) {\r\n\t\t\tvar tempHalfEdge = this.addEdgeVertex( eOrg );\r\n\t\t\tvar eNew = tempHalfEdge.Sym;\r\n\r\n\t\t\t/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */\r\n\t\t\tthis.splice_( eOrg.Sym, eOrg.Sym.Oprev );\r\n\t\t\tthis.splice_( eOrg.Sym, eNew );\r\n\r\n\t\t\t/* Set the vertex and face information */\r\n\t\t\teOrg.Dst = eNew.Org;\r\n\t\t\teNew.Dst.anEdge = eNew.Sym;\t/* may have pointed to eOrg->Sym */\r\n\t\t\teNew.Rface = eOrg.Rface;\r\n\t\t\teNew.winding = eOrg.winding;\t/* copy old winding information */\r\n\t\t\teNew.Sym.winding = eOrg.Sym.winding;\r\n\r\n\t\t\treturn eNew;\r\n\t\t},\r\n\r\n\r\n\t\t/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\r\n\t\t* to eDst->Org, and returns the corresponding half-edge eNew.\r\n\t\t* If eOrg->Lface == eDst->Lface, this splits one loop into two,\r\n\t\t* and the newly created loop is eNew->Lface.  Otherwise, two disjoint\r\n\t\t* loops are merged into one, and the loop eDst->Lface is destroyed.\r\n\t\t*\r\n\t\t* If (eOrg == eDst), the new face will have only two edges.\r\n\t\t* If (eOrg->Lnext == eDst), the old face is reduced to a single edge.\r\n\t\t* If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.\r\n\t\t*/\r\n\r\n\t\t// TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );\r\n\t\tconnect: function(eOrg, eDst) {\r\n\t\t\tvar joiningLoops = false;  \r\n\t\t\tvar eNew = this.makeEdge_( eOrg );\r\n\t\t\tvar eNewSym = eNew.Sym;\r\n\r\n\t\t\tif( eDst.Lface !== eOrg.Lface ) {\r\n\t\t\t\t/* We are connecting two disjoint loops -- destroy eDst->Lface */\r\n\t\t\t\tjoiningLoops = true;\r\n\t\t\t\tthis.killFace_( eDst.Lface, eOrg.Lface );\r\n\t\t\t}\r\n\r\n\t\t\t/* Connect the new edge appropriately */\r\n\t\t\tthis.splice_( eNew, eOrg.Lnext );\r\n\t\t\tthis.splice_( eNewSym, eDst );\r\n\r\n\t\t\t/* Set the vertex and face information */\r\n\t\t\teNew.Org = eOrg.Dst;\r\n\t\t\teNewSym.Org = eDst.Org;\r\n\t\t\teNew.Lface = eNewSym.Lface = eOrg.Lface;\r\n\r\n\t\t\t/* Make sure the old face points to a valid half-edge */\r\n\t\t\teOrg.Lface.anEdge = eNewSym;\r\n\r\n\t\t\tif( ! joiningLoops ) {\r\n\t\t\t\tvar newFace = new TESSface();\r\n\t\t\t\t/* We split one loop into two -- the new loop is eNew->Lface */\r\n\t\t\t\tthis.makeFace_( newFace, eNew, eOrg.Lface );\r\n\t\t\t}\r\n\t\t\treturn eNew;\r\n\t\t},\r\n\r\n\t\t/* tessMeshZapFace( fZap ) destroys a face and removes it from the\r\n\t\t* global face list.  All edges of fZap will have a NULL pointer as their\r\n\t\t* left face.  Any edges which also have a NULL pointer as their right face\r\n\t\t* are deleted entirely (along with any isolated vertices this produces).\r\n\t\t* An entire mesh can be deleted by zapping its faces, one at a time,\r\n\t\t* in any order.  Zapped faces cannot be used in further mesh operations!\r\n\t\t*/\r\n\t\tzapFace: function( fZap )\r\n\t\t{\r\n\t\t\tvar eStart = fZap.anEdge;\r\n\t\t\tvar e, eNext, eSym;\r\n\t\t\tvar fPrev, fNext;\r\n\r\n\t\t\t/* walk around face, deleting edges whose right face is also NULL */\r\n\t\t\teNext = eStart.Lnext;\r\n\t\t\tdo {\r\n\t\t\t\te = eNext;\r\n\t\t\t\teNext = e.Lnext;\r\n\r\n\t\t\t\te.Lface = null;\r\n\t\t\t\tif( e.Rface === null ) {\r\n\t\t\t\t\t/* delete the edge -- see TESSmeshDelete above */\r\n\r\n\t\t\t\t\tif( e.Onext === e ) {\r\n\t\t\t\t\t\tthis.killVertex_( e.Org, null );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Make sure that e->Org points to a valid half-edge */\r\n\t\t\t\t\t\te.Org.anEdge = e.Onext;\r\n\t\t\t\t\t\tthis.splice_( e, e.Oprev );\r\n\t\t\t\t\t}\r\n\t\t\t\t\teSym = e.Sym;\r\n\t\t\t\t\tif( eSym.Onext === eSym ) {\r\n\t\t\t\t\t\tthis.killVertex_( eSym.Org, null );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t/* Make sure that eSym->Org points to a valid half-edge */\r\n\t\t\t\t\t\teSym.Org.anEdge = eSym.Onext;\r\n\t\t\t\t\t\tthis.splice_( eSym, eSym.Oprev );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthis.killEdge_( e );\r\n\t\t\t\t}\r\n\t\t\t} while( e != eStart );\r\n\r\n\t\t\t/* delete from circular doubly-linked list */\r\n\t\t\tfPrev = fZap.prev;\r\n\t\t\tfNext = fZap.next;\r\n\t\t\tfNext.prev = fPrev;\r\n\t\t\tfPrev.next = fNext;\r\n\t\t},\r\n\r\n\t\tcountFaceVerts_: function(f) {\r\n\t\t\tvar eCur = f.anEdge;\r\n\t\t\tvar n = 0;\r\n\t\t\tdo\r\n\t\t\t{\r\n\t\t\t\tn++;\r\n\t\t\t\teCur = eCur.Lnext;\r\n\t\t\t}\r\n\t\t\twhile (eCur !== f.anEdge);\r\n\t\t\treturn n;\r\n\t\t},\r\n\r\n\t\t//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )\r\n\t\tmergeConvexFaces: function(maxVertsPerFace) {\r\n\t\t\tvar f;\r\n\t\t\tvar eCur, eNext, eSym;\r\n\t\t\tvar vStart;\r\n\t\t\tvar curNv, symNv;\r\n\r\n\t\t\tfor( f = this.fHead.next; f !== this.fHead; f = f.next )\r\n\t\t\t{\r\n\t\t\t\t// Skip faces which are outside the result.\r\n\t\t\t\tif( !f.inside )\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\teCur = f.anEdge;\r\n\t\t\t\tvStart = eCur.Org;\r\n\t\t\t\t\t\r\n\t\t\t\twhile (true)\r\n\t\t\t\t{\r\n\t\t\t\t\teNext = eCur.Lnext;\r\n\t\t\t\t\teSym = eCur.Sym;\r\n\r\n\t\t\t\t\t// Try to merge if the neighbour face is valid.\r\n\t\t\t\t\tif( eSym && eSym.Lface && eSym.Lface.inside )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Try to merge the neighbour faces if the resulting polygons\r\n\t\t\t\t\t\t// does not exceed maximum number of vertices.\r\n\t\t\t\t\t\tcurNv = this.countFaceVerts_( f );\r\n\t\t\t\t\t\tsymNv = this.countFaceVerts_( eSym.Lface );\r\n\t\t\t\t\t\tif( (curNv+symNv-2) <= maxVertsPerFace )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Merge if the resulting poly is convex.\r\n\t\t\t\t\t\t\tif( Geom.vertCCW( eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org ) &&\r\n\t\t\t\t\t\t\t\tGeom.vertCCW( eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\teNext = eSym.Lnext;\r\n\t\t\t\t\t\t\t\tthis.delete( eSym );\r\n\t\t\t\t\t\t\t\teCur = null;\r\n\t\t\t\t\t\t\t\teSym = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif( eCur && eCur.Lnext.Org === vStart )\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t// Continue to next edge.\r\n\t\t\t\t\teCur = eNext;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\t\t/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\r\n\t\t*/\r\n\t\tcheck: function() {\r\n\t\t\tvar fHead = this.fHead;\r\n\t\t\tvar vHead = this.vHead;\r\n\t\t\tvar eHead = this.eHead;\r\n\t\t\tvar f, fPrev, v, vPrev, e, ePrev;\r\n\r\n\t\t\tfPrev = fHead;\r\n\t\t\tfor( fPrev = fHead ; (f = fPrev.next) !== fHead; fPrev = f) {\r\n\t\t\t\tassert( f.prev === fPrev );\r\n\t\t\t\te = f.anEdge;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tassert( e.Sym !== e );\r\n\t\t\t\t\tassert( e.Sym.Sym === e );\r\n\t\t\t\t\tassert( e.Lnext.Onext.Sym === e );\r\n\t\t\t\t\tassert( e.Onext.Sym.Lnext === e );\r\n\t\t\t\t\tassert( e.Lface === f );\r\n\t\t\t\t\te = e.Lnext;\r\n\t\t\t\t} while( e !== f.anEdge );\r\n\t\t\t}\r\n\t\t\tassert( f.prev === fPrev && f.anEdge === null );\r\n\r\n\t\t\tvPrev = vHead;\r\n\t\t\tfor( vPrev = vHead ; (v = vPrev.next) !== vHead; vPrev = v) {\r\n\t\t\t\tassert( v.prev === vPrev );\r\n\t\t\t\te = v.anEdge;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tassert( e.Sym !== e );\r\n\t\t\t\t\tassert( e.Sym.Sym === e );\r\n\t\t\t\t\tassert( e.Lnext.Onext.Sym === e );\r\n\t\t\t\t\tassert( e.Onext.Sym.Lnext === e );\r\n\t\t\t\t\tassert( e.Org === v );\r\n\t\t\t\t\te = e.Onext;\r\n\t\t\t\t} while( e !== v.anEdge );\r\n\t\t\t}\r\n\t\t\tassert( v.prev === vPrev && v.anEdge === null );\r\n\r\n\t\t\tePrev = eHead;\r\n\t\t\tfor( ePrev = eHead ; (e = ePrev.next) !== eHead; ePrev = e) {\r\n\t\t\t\tassert( e.Sym.next === ePrev.Sym );\r\n\t\t\t\tassert( e.Sym !== e );\r\n\t\t\t\tassert( e.Sym.Sym === e );\r\n\t\t\t\tassert( e.Org !== null );\r\n\t\t\t\tassert( e.Dst !== null );\r\n\t\t\t\tassert( e.Lnext.Onext.Sym === e );\r\n\t\t\t\tassert( e.Onext.Sym.Lnext === e );\r\n\t\t\t}\r\n\t\t\tassert( e.Sym.next === ePrev.Sym\r\n\t\t\t\t&& e.Sym === this.eHeadSym\r\n\t\t\t\t&& e.Sym.Sym === e\r\n\t\t\t\t&& e.Org === null && e.Dst === null\r\n\t\t\t\t&& e.Lface === null && e.Rface === null );\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tGeom.vertEq = function(u,v) {\r\n\t\treturn (u.s === v.s && u.t === v.t);\r\n\t};\r\n\r\n\t/* Returns TRUE if u is lexicographically <= v. */\r\n\tGeom.vertLeq = function(u,v) {\r\n\t\treturn ((u.s < v.s) || (u.s === v.s && u.t <= v.t));\r\n\t};\r\n\r\n\t/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */\r\n\tGeom.transLeq = function(u,v) {\r\n\t\treturn ((u.t < v.t) || (u.t === v.t && u.s <= v.s));\r\n\t};\r\n\r\n\tGeom.edgeGoesLeft = function(e) {\r\n\t\treturn Geom.vertLeq( e.Dst, e.Org );\r\n\t};\r\n\r\n\tGeom.edgeGoesRight = function(e) {\r\n\t\treturn Geom.vertLeq( e.Org, e.Dst );\r\n\t};\r\n\r\n\tGeom.vertL1dist = function(u,v) {\r\n\t\treturn (Math.abs(u.s - v.s) + Math.abs(u.t - v.t));\r\n\t};\r\n\r\n\t//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tGeom.edgeEval = function( u, v, w ) {\r\n\t\t/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),\r\n\t\t* evaluates the t-coord of the edge uw at the s-coord of the vertex v.\r\n\t\t* Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.\r\n\t\t* If uw is vertical (and thus passes thru v), the result is zero.\r\n\t\t*\r\n\t\t* The calculation is extremely accurate and stable, even when v\r\n\t\t* is very close to u or w.  In particular if we set v->t = 0 and\r\n\t\t* let r be the negated result (this evaluates (uw)(v->s)), then\r\n\t\t* r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).\r\n\t\t*/\r\n\t\tassert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));\r\n\r\n\t\tvar gapL = v.s - u.s;\r\n\t\tvar gapR = w.s - v.s;\r\n\r\n\t\tif( gapL + gapR > 0.0 ) {\r\n\t\t\tif( gapL < gapR ) {\r\n\t\t\t\treturn (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));\r\n\t\t\t} else {\r\n\t\t\t\treturn (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t};\r\n\r\n\t//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tGeom.edgeSign = function( u, v, w ) {\r\n\t\t/* Returns a number whose sign matches EdgeEval(u,v,w) but which\r\n\t\t* is cheaper to evaluate.  Returns > 0, == 0 , or < 0\r\n\t\t* as v is above, on, or below the edge uw.\r\n\t\t*/\r\n\t\tassert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));\r\n\r\n\t\tvar gapL = v.s - u.s;\r\n\t\tvar gapR = w.s - v.s;\r\n\r\n\t\tif( gapL + gapR > 0.0 ) {\r\n\t\t\treturn (v.t - w.t) * gapL + (v.t - u.t) * gapR;\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t};\r\n\r\n\r\n\t/***********************************************************************\r\n\t* Define versions of EdgeSign, EdgeEval with s and t transposed.\r\n\t*/\r\n\r\n\t//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tGeom.transEval = function( u, v, w ) {\r\n\t\t/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),\r\n\t\t* evaluates the t-coord of the edge uw at the s-coord of the vertex v.\r\n\t\t* Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.\r\n\t\t* If uw is vertical (and thus passes thru v), the result is zero.\r\n\t\t*\r\n\t\t* The calculation is extremely accurate and stable, even when v\r\n\t\t* is very close to u or w.  In particular if we set v->s = 0 and\r\n\t\t* let r be the negated result (this evaluates (uw)(v->t)), then\r\n\t\t* r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).\r\n\t\t*/\r\n\t\tassert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));\r\n\r\n\t\tvar gapL = v.t - u.t;\r\n\t\tvar gapR = w.t - v.t;\r\n\r\n\t\tif( gapL + gapR > 0.0 ) {\r\n\t\t\tif( gapL < gapR ) {\r\n\t\t\t\treturn (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));\r\n\t\t\t} else {\r\n\t\t\t\treturn (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t};\r\n\r\n\t//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tGeom.transSign = function( u, v, w ) {\r\n\t\t/* Returns a number whose sign matches TransEval(u,v,w) but which\r\n\t\t* is cheaper to evaluate.  Returns > 0, == 0 , or < 0\r\n\t\t* as v is above, on, or below the edge uw.\r\n\t\t*/\r\n\t\tassert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));\r\n\r\n\t\tvar gapL = v.t - u.t;\r\n\t\tvar gapR = w.t - v.t;\r\n\r\n\t\tif( gapL + gapR > 0.0 ) {\r\n\t\t\treturn (v.s - w.s) * gapL + (v.s - u.s) * gapR;\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t};\r\n\r\n\r\n\t//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tGeom.vertCCW = function( u, v, w ) {\r\n\t\t/* For almost-degenerate situations, the results are not reliable.\r\n\t\t* Unless the floating-point arithmetic can be performed without\r\n\t\t* rounding errors, *any* implementation will give incorrect results\r\n\t\t* on some degenerate inputs, so the client must have some way to\r\n\t\t* handle this situation.\r\n\t\t*/\r\n\t\treturn (u.s*(v.t - w.t) + v.s*(w.t - u.t) + w.s*(u.t - v.t)) >= 0.0;\r\n\t};\r\n\r\n\t/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),\r\n\t* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces\r\n\t* this in the rare case that one argument is slightly negative.\r\n\t* The implementation is extremely stable numerically.\r\n\t* In particular it guarantees that the result r satisfies\r\n\t* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate\r\n\t* even when a and b differ greatly in magnitude.\r\n\t*/\r\n\tGeom.interpolate = function(a,x,b,y) {\r\n\t\treturn (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b === 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))));\r\n\t};\r\n\r\n\t/*\r\n\t#ifndef FOR_TRITE_TEST_PROGRAM\r\n\t#define Interpolate(a,x,b,y)\tRealInterpolate(a,x,b,y)\r\n\t#else\r\n\r\n\t// Claim: the ONLY property the sweep algorithm relies on is that\r\n\t// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.\r\n\t#include <stdlib.h>\r\n\textern int RandomInterpolate;\r\n\r\n\tdouble Interpolate( double a, double x, double b, double y)\r\n\t{\r\n\t\tprintf(\"*********************%d\\n\",RandomInterpolate);\r\n\t\tif( RandomInterpolate ) {\r\n\t\t\ta = 1.2 * drand48() - 0.1;\r\n\t\t\ta = (a < 0) ? 0 : ((a > 1) ? 1 : a);\r\n\t\t\tb = 1.0 - a;\r\n\t\t}\r\n\t\treturn RealInterpolate(a,x,b,y);\r\n\t}\r\n\t#endif*/\r\n\r\n\tGeom.intersect = function( o1, d1, o2, d2, v ) {\r\n\t\t/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.\r\n\t\t* The computed point is guaranteed to lie in the intersection of the\r\n\t\t* bounding rectangles defined by each edge.\r\n\t\t*/\r\n\t\tvar z1, z2;\r\n\t\tvar t;\r\n\r\n\t\t/* This is certainly not the most efficient way to find the intersection\r\n\t\t* of two line segments, but it is very numerically stable.\r\n\t\t*\r\n\t\t* Strategy: find the two middle vertices in the VertLeq ordering,\r\n\t\t* and interpolate the intersection s-value from these.  Then repeat\r\n\t\t* using the TransLeq ordering to find the intersection t-value.\r\n\t\t*/\r\n\r\n\t\tif( ! Geom.vertLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }\r\n\t\tif( ! Geom.vertLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }\r\n\t\tif( ! Geom.vertLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; }//swap( o1, o2 ); swap( d1, d2 ); }\r\n\r\n\t\tif( ! Geom.vertLeq( o2, d1 )) {\r\n\t\t\t/* Technically, no intersection -- do our best */\r\n\t\t\tv.s = (o2.s + d1.s) / 2;\r\n\t\t} else if( Geom.vertLeq( d1, d2 )) {\r\n\t\t\t/* Interpolate between o2 and d1 */\r\n\t\t\tz1 = Geom.edgeEval( o1, o2, d1 );\r\n\t\t\tz2 = Geom.edgeEval( o2, d1, d2 );\r\n\t\t\tif( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n\t\t\tv.s = Geom.interpolate( z1, o2.s, z2, d1.s );\r\n\t\t} else {\r\n\t\t\t/* Interpolate between o2 and d2 */\r\n\t\t\tz1 = Geom.edgeSign( o1, o2, d1 );\r\n\t\t\tz2 = -Geom.edgeSign( o1, d2, d1 );\r\n\t\t\tif( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n\t\t\tv.s = Geom.interpolate( z1, o2.s, z2, d2.s );\r\n\t\t}\r\n\r\n\t\t/* Now repeat the process for t */\r\n\r\n\t\tif( ! Geom.transLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }\r\n\t\tif( ! Geom.transLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }\r\n\t\tif( ! Geom.transLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; } //swap( o1, o2 ); swap( d1, d2 ); }\r\n\r\n\t\tif( ! Geom.transLeq( o2, d1 )) {\r\n\t\t\t/* Technically, no intersection -- do our best */\r\n\t\t\tv.t = (o2.t + d1.t) / 2;\r\n\t\t} else if( Geom.transLeq( d1, d2 )) {\r\n\t\t\t/* Interpolate between o2 and d1 */\r\n\t\t\tz1 = Geom.transEval( o1, o2, d1 );\r\n\t\t\tz2 = Geom.transEval( o2, d1, d2 );\r\n\t\t\tif( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n\t\t\tv.t = Geom.interpolate( z1, o2.t, z2, d1.t );\r\n\t\t} else {\r\n\t\t\t/* Interpolate between o2 and d2 */\r\n\t\t\tz1 = Geom.transSign( o1, o2, d1 );\r\n\t\t\tz2 = -Geom.transSign( o1, d2, d1 );\r\n\t\t\tif( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }\r\n\t\t\tv.t = Geom.interpolate( z1, o2.t, z2, d2.t );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\r\n\tfunction DictNode() {\r\n\t\tthis.key = null;\r\n\t\tthis.next = null;\r\n\t\tthis.prev = null;\r\n\t};\r\n\r\n\tfunction Dict(frame, leq) {\r\n\t\tthis.head = new DictNode();\r\n\t\tthis.head.next = this.head;\r\n\t\tthis.head.prev = this.head;\r\n\t\tthis.frame = frame;\r\n\t\tthis.leq = leq;\r\n\t};\r\n\r\n\tDict.prototype = {\r\n\t\tmin: function() {\r\n\t\t\treturn this.head.next;\r\n\t\t},\r\n\r\n\t\tmax: function() {\r\n\t\t\treturn this.head.prev;\r\n\t\t},\r\n\r\n\t\tinsert: function(k) {\r\n\t\t\treturn this.insertBefore(this.head, k);\r\n\t\t},\r\n\r\n\t\tsearch: function(key) {\r\n\t\t\t/* Search returns the node with the smallest key greater than or equal\r\n\t\t\t* to the given key.  If there is no such key, returns a node whose\r\n\t\t\t* key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.\r\n\t\t\t*/\r\n\t\t\tvar node = this.head;\r\n\t\t\tdo {\r\n\t\t\t\tnode = node.next;\r\n\t\t\t} while( node.key !== null && ! this.leq(this.frame, key, node.key));\r\n\r\n\t\t\treturn node;\r\n\t\t},\r\n\r\n\t\tinsertBefore: function(node, key) {\r\n\t\t\tdo {\r\n\t\t\t\tnode = node.prev;\r\n\t\t\t} while( node.key !== null && ! this.leq(this.frame, node.key, key));\r\n\r\n\t\t\tvar newNode = new DictNode();\r\n\t\t\tnewNode.key = key;\r\n\t\t\tnewNode.next = node.next;\r\n\t\t\tnode.next.prev = newNode;\r\n\t\t\tnewNode.prev = node;\r\n\t\t\tnode.next = newNode;\r\n\r\n\t\t\treturn newNode;\r\n\t\t},\r\n\r\n\t\tdelete: function(node) {\r\n\t\t\tnode.next.prev = node.prev;\r\n\t\t\tnode.prev.next = node.next;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\tfunction PQnode() {\r\n\t\tthis.handle = null;\r\n\t}\r\n\r\n\tfunction PQhandleElem() {\r\n\t\tthis.key = null;\r\n\t\tthis.node = null;\r\n\t}\r\n\r\n\tfunction PriorityQ(size, leq) {\r\n\t\tthis.size = 0;\r\n\t\tthis.max = size;\r\n\r\n\t\tthis.nodes = [];\r\n\t\tthis.nodes.length = size+1;\r\n\t\tvar i;\r\n\t\t\r\n\t\tfor (i = 0; i < this.nodes.length; i++)\r\n\t\t\tthis.nodes[i] = new PQnode();\r\n\r\n\t\tthis.handles = [];\r\n\t\tthis.handles.length = size+1;\r\n\t\tfor (i = 0; i < this.handles.length; i++)\r\n\t\t\tthis.handles[i] = new PQhandleElem();\r\n\r\n\t\tthis.initialized = false;\r\n\t\tthis.freeList = 0;\r\n\t\tthis.leq = leq;\r\n\r\n\t\tthis.nodes[1].handle = 1;\t/* so that Minimum() returns NULL */\r\n\t\tthis.handles[1].key = null;\r\n\t};\r\n\r\n\tPriorityQ.prototype = {\r\n\r\n\t\tfloatDown_: function( curr )\r\n\t\t{\r\n\t\t\tvar n = this.nodes;\r\n\t\t\tvar h = this.handles;\r\n\t\t\tvar hCurr, hChild;\r\n\t\t\tvar child;\r\n\r\n\t\t\thCurr = n[curr].handle;\r\n\t\t\tfor( ;; ) {\r\n\t\t\t\tchild = curr << 1;\r\n\t\t\t\tif( child < this.size && this.leq( h[n[child+1].handle].key, h[n[child].handle].key )) {\r\n\t\t\t\t\t++child;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tassert(child <= this.max);\r\n\r\n\t\t\t\thChild = n[child].handle;\r\n\t\t\t\tif( child > this.size || this.leq( h[hCurr].key, h[hChild].key )) {\r\n\t\t\t\t\tn[curr].handle = hCurr;\r\n\t\t\t\t\th[hCurr].node = curr;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tn[curr].handle = hChild;\r\n\t\t\t\th[hChild].node = curr;\r\n\t\t\t\tcurr = child;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tfloatUp_: function( curr )\r\n\t\t{\r\n\t\t\tvar n = this.nodes;\r\n\t\t\tvar h = this.handles;\r\n\t\t\tvar hCurr, hParent;\r\n\t\t\tvar parent;\r\n\r\n\t\t\thCurr = n[curr].handle;\r\n\t\t\tfor( ;; ) {\r\n\t\t\t\tparent = curr >> 1;\r\n\t\t\t\thParent = n[parent].handle;\r\n\t\t\t\tif( parent === 0 || this.leq( h[hParent].key, h[hCurr].key )) {\r\n\t\t\t\t\tn[curr].handle = hCurr;\r\n\t\t\t\t\th[hCurr].node = curr;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tn[curr].handle = hParent;\r\n\t\t\t\th[hParent].node = curr;\r\n\t\t\t\tcurr = parent;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tinit: function() {\r\n\t\t\t/* This method of building a heap is O(n), rather than O(n lg n). */\r\n\t\t\tfor( var i = this.size; i >= 1; --i ) {\r\n\t\t\t\tthis.floatDown_( i );\r\n\t\t\t}\r\n\t\t\tthis.initialized = true;\r\n\t\t},\r\n\r\n\t\tmin: function() {\r\n\t\t\treturn this.handles[this.nodes[1].handle].key;\r\n\t\t},\r\n\r\n\t\t/* really pqHeapInsert */\r\n\t\t/* returns INV_HANDLE iff out of memory */\r\n\t\t//PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )\r\n\t\tinsert: function(keyNew)\r\n\t\t{\r\n\t\t\tvar curr;\r\n\t\t\tvar free;\r\n\r\n\t\t\tcurr = ++this.size;\r\n\t\t\tif( (curr*2) > this.max ) {\r\n\t\t\t\tthis.max *= 2;\r\n\t\t\t\tvar i;\r\n\t\t\t\tvar s;\r\n\t\t\t\ts = this.nodes.length;\r\n\t\t\t\tthis.nodes.length = this.max+1;\r\n\t\t\t\tfor (i = s; i < this.nodes.length; i++)\r\n\t\t\t\t\tthis.nodes[i] = new PQnode();\r\n\r\n\t\t\t\ts = this.handles.length;\r\n\t\t\t\tthis.handles.length = this.max+1;\r\n\t\t\t\tfor (i = s; i < this.handles.length; i++)\r\n\t\t\t\t\tthis.handles[i] = new PQhandleElem();\r\n\t\t\t}\r\n\r\n\t\t\tif( this.freeList === 0 ) {\r\n\t\t\t\tfree = curr;\r\n\t\t\t} else {\r\n\t\t\t\tfree = this.freeList;\r\n\t\t\t\tthis.freeList = this.handles[free].node;\r\n\t\t\t}\r\n\r\n\t\t\tthis.nodes[curr].handle = free;\r\n\t\t\tthis.handles[free].node = curr;\r\n\t\t\tthis.handles[free].key = keyNew;\r\n\r\n\t\t\tif( this.initialized ) {\r\n\t\t\t\tthis.floatUp_( curr );\r\n\t\t\t}\r\n\t\t\treturn free;\r\n\t\t},\r\n\r\n\t\t//PQkey pqHeapExtractMin( PriorityQHeap *pq )\r\n\t\textractMin: function() {\r\n\t\t\tvar n = this.nodes;\r\n\t\t\tvar h = this.handles;\r\n\t\t\tvar hMin = n[1].handle;\r\n\t\t\tvar min = h[hMin].key;\r\n\r\n\t\t\tif( this.size > 0 ) {\r\n\t\t\t\tn[1].handle = n[this.size].handle;\r\n\t\t\t\th[n[1].handle].node = 1;\r\n\r\n\t\t\t\th[hMin].key = null;\r\n\t\t\t\th[hMin].node = this.freeList;\r\n\t\t\t\tthis.freeList = hMin;\r\n\r\n\t\t\t\t--this.size;\r\n\t\t\t\tif( this.size > 0 ) {\r\n\t\t\t\t\tthis.floatDown_( 1 );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn min;\r\n\t\t},\r\n\r\n\t\tdelete: function( hCurr ) {\r\n\t\t\tvar n = this.nodes;\r\n\t\t\tvar h = this.handles;\r\n\t\t\tvar curr;\r\n\r\n\t\t\tassert( hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null );\r\n\r\n\t\t\tcurr = h[hCurr].node;\r\n\t\t\tn[curr].handle = n[this.size].handle;\r\n\t\t\th[n[curr].handle].node = curr;\r\n\r\n\t\t\t--this.size;\r\n\t\t\tif( curr <= this.size ) {\r\n\t\t\t\tif( curr <= 1 || this.leq( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {\r\n\t\t\t\t\tthis.floatDown_( curr );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.floatUp_( curr );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\th[hCurr].key = null;\r\n\t\t\th[hCurr].node = this.freeList;\r\n\t\t\tthis.freeList = hCurr;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/* For each pair of adjacent edges crossing the sweep line, there is\r\n\t* an ActiveRegion to represent the region between them.  The active\r\n\t* regions are kept in sorted order in a dynamic dictionary.  As the\r\n\t* sweep line crosses each vertex, we update the affected regions.\r\n\t*/\r\n\r\n\tfunction ActiveRegion() {\r\n\t\tthis.eUp = null;\t\t/* upper edge, directed right to left */\r\n\t\tthis.nodeUp = null;\t/* dictionary node corresponding to eUp */\r\n\t\tthis.windingNumber = 0;\t/* used to determine which regions are\r\n\t\t\t\t\t\t\t\t* inside the polygon */\r\n\t\tthis.inside = false;\t\t/* is this region inside the polygon? */\r\n\t\tthis.sentinel = false;\t/* marks fake edges at t = +/-infinity */\r\n\t\tthis.dirty = false;\t\t/* marks regions where the upper or lower\r\n\t\t\t\t\t\t* edge has changed, but we haven't checked\r\n\t\t\t\t\t\t* whether they intersect yet */\r\n\t\tthis.fixUpperEdge = false;\t/* marks temporary edges introduced when\r\n\t\t\t\t\t\t\t* we process a \"right vertex\" (one without\r\n\t\t\t\t\t\t\t* any edges leaving to the right) */\r\n\t};\r\n\r\n\tvar Sweep = {};\r\n\r\n\tSweep.regionBelow = function(r) {\r\n\t\treturn r.nodeUp.prev.key;\r\n\t}\r\n\r\n\tSweep.regionAbove = function(r) {\r\n\t\treturn r.nodeUp.next.key;\r\n\t}\r\n\r\n\tSweep.debugEvent = function( tess ) {\r\n\t\t// empty\r\n\t}\r\n\r\n\r\n\t/*\r\n\t* Invariants for the Edge Dictionary.\r\n\t* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)\r\n\t*   at any valid location of the sweep event\r\n\t* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2\r\n\t*   share a common endpoint\r\n\t* - for each e, e->Dst has been processed, but not e->Org\r\n\t* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)\r\n\t*   where \"event\" is the current sweep line event.\r\n\t* - no edge e has zero length\r\n\t*\r\n\t* Invariants for the Mesh (the processed portion).\r\n\t* - the portion of the mesh left of the sweep line is a planar graph,\r\n\t*   ie. there is *some* way to embed it in the plane\r\n\t* - no processed edge has zero length\r\n\t* - no two processed vertices have identical coordinates\r\n\t* - each \"inside\" region is monotone, ie. can be broken into two chains\r\n\t*   of monotonically increasing vertices according to VertLeq(v1,v2)\r\n\t*   - a non-invariant: these chains may intersect (very slightly)\r\n\t*\r\n\t* Invariants for the Sweep.\r\n\t* - if none of the edges incident to the event vertex have an activeRegion\r\n\t*   (ie. none of these edges are in the edge dictionary), then the vertex\r\n\t*   has only right-going edges.\r\n\t* - if an edge is marked \"fixUpperEdge\" (it is a temporary edge introduced\r\n\t*   by ConnectRightVertex), then it is the only right-going edge from\r\n\t*   its associated vertex.  (This says that these edges exist only\r\n\t*   when it is necessary.)\r\n\t*/\r\n\r\n\t/* When we merge two edges into one, we need to compute the combined\r\n\t* winding of the new edge.\r\n\t*/\r\n\tSweep.addWinding = function(eDst,eSrc) {\r\n\t\teDst.winding += eSrc.winding;\r\n\t\teDst.Sym.winding += eSrc.Sym.winding;\r\n\t}\r\n\r\n\r\n\t//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )\r\n\tSweep.edgeLeq = function( tess, reg1, reg2 ) {\r\n\t\t/*\r\n\t\t* Both edges must be directed from right to left (this is the canonical\r\n\t\t* direction for the upper edge of each region).\r\n\t\t*\r\n\t\t* The strategy is to evaluate a \"t\" value for each edge at the\r\n\t\t* current sweep line position, given by tess->event.  The calculations\r\n\t\t* are designed to be very stable, but of course they are not perfect.\r\n\t\t*\r\n\t\t* Special case: if both edge destinations are at the sweep event,\r\n\t\t* we sort the edges by slope (they would otherwise compare equally).\r\n\t\t*/\r\n\t\tvar ev = tess.event;\r\n\t\tvar t1, t2;\r\n\r\n\t\tvar e1 = reg1.eUp;\r\n\t\tvar e2 = reg2.eUp;\r\n\r\n\t\tif( e1.Dst === ev ) {\r\n\t\t\tif( e2.Dst === ev ) {\r\n\t\t\t\t/* Two edges right of the sweep line which meet at the sweep event.\r\n\t\t\t\t* Sort them by slope.\r\n\t\t\t\t*/\r\n\t\t\t\tif( Geom.vertLeq( e1.Org, e2.Org )) {\r\n\t\t\t\t\treturn Geom.edgeSign( e2.Dst, e1.Org, e2.Org ) <= 0;\r\n\t\t\t\t}\r\n\t\t\t\treturn Geom.edgeSign( e1.Dst, e2.Org, e1.Org ) >= 0;\r\n\t\t\t}\r\n\t\t\treturn Geom.edgeSign( e2.Dst, ev, e2.Org ) <= 0;\r\n\t\t}\r\n\t\tif( e2.Dst === ev ) {\r\n\t\t\treturn Geom.edgeSign( e1.Dst, ev, e1.Org ) >= 0;\r\n\t\t}\r\n\r\n\t\t/* General case - compute signed distance *from* e1, e2 to event */\r\n\t\tvar t1 = Geom.edgeEval( e1.Dst, ev, e1.Org );\r\n\t\tvar t2 = Geom.edgeEval( e2.Dst, ev, e2.Org );\r\n\t\treturn (t1 >= t2);\r\n\t}\r\n\r\n\r\n\t//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )\r\n\tSweep.deleteRegion = function( tess, reg ) {\r\n\t\tif( reg.fixUpperEdge ) {\r\n\t\t\t/* It was created with zero winding number, so it better be\r\n\t\t\t* deleted with zero winding number (ie. it better not get merged\r\n\t\t\t* with a real edge).\r\n\t\t\t*/\r\n\t\t\tassert( reg.eUp.winding === 0 );\r\n\t\t}\r\n\t\treg.eUp.activeRegion = null;\r\n\t\ttess.dict.delete( reg.nodeUp );\r\n\t}\r\n\r\n\t//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )\r\n\tSweep.fixUpperEdge = function( tess, reg, newEdge ) {\r\n\t\t/*\r\n\t\t* Replace an upper edge which needs fixing (see ConnectRightVertex).\r\n\t\t*/\r\n\t\tassert( reg.fixUpperEdge );\r\n\t\ttess.mesh.delete( reg.eUp );\r\n\t\treg.fixUpperEdge = false;\r\n\t\treg.eUp = newEdge;\r\n\t\tnewEdge.activeRegion = reg;\r\n\t}\r\n\r\n\t//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )\r\n\tSweep.topLeftRegion = function( tess, reg ) {\r\n\t\tvar org = reg.eUp.Org;\r\n\t\tvar e;\r\n\r\n\t\t/* Find the region above the uppermost edge with the same origin */\r\n\t\tdo {\r\n\t\t\treg = Sweep.regionAbove( reg );\r\n\t\t} while( reg.eUp.Org === org );\r\n\r\n\t\t/* If the edge above was a temporary edge introduced by ConnectRightVertex,\r\n\t\t* now is the time to fix it.\r\n\t\t*/\r\n\t\tif( reg.fixUpperEdge ) {\r\n\t\t\te = tess.mesh.connect( Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext );\r\n\t\t\tif (e === null) return null;\r\n\t\t\tSweep.fixUpperEdge( tess, reg, e );\r\n\t\t\treg = Sweep.regionAbove( reg );\r\n\t\t}\r\n\t\treturn reg;\r\n\t}\r\n\r\n\t//static ActiveRegion *TopRightRegion( ActiveRegion *reg )\r\n\tSweep.topRightRegion = function( reg )\r\n\t{\r\n\t\tvar dst = reg.eUp.Dst;\r\n\t\t/* Find the region above the uppermost edge with the same destination */\r\n\t\tdo {\r\n\t\t\treg = Sweep.regionAbove( reg );\r\n\t\t} while( reg.eUp.Dst === dst );\r\n\t\treturn reg;\r\n\t}\r\n\r\n\t//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )\r\n\tSweep.addRegionBelow = function( tess, regAbove, eNewUp ) {\r\n\t\t/*\r\n\t\t* Add a new active region to the sweep line, *somewhere* below \"regAbove\"\r\n\t\t* (according to where the new edge belongs in the sweep-line dictionary).\r\n\t\t* The upper edge of the new region will be \"eNewUp\".\r\n\t\t* Winding number and \"inside\" flag are not updated.\r\n\t\t*/\r\n\t\tvar regNew = new ActiveRegion();\r\n\t\tregNew.eUp = eNewUp;\r\n\t\tregNew.nodeUp = tess.dict.insertBefore( regAbove.nodeUp, regNew );\r\n\t//\tif (regNew->nodeUp == NULL) longjmp(tess->env,1);\r\n\t\tregNew.fixUpperEdge = false;\r\n\t\tregNew.sentinel = false;\r\n\t\tregNew.dirty = false;\r\n\r\n\t\teNewUp.activeRegion = regNew;\r\n\t\treturn regNew;\r\n\t}\r\n\r\n\t//static int IsWindingInside( TESStesselator *tess, int n )\r\n\tSweep.isWindingInside = function( tess, n ) {\r\n\t\tswitch( tess.windingRule ) {\r\n\t\t\tcase Tess2.WINDING_ODD:\r\n\t\t\t\treturn (n & 1) !== 0;\r\n\t\t\tcase Tess2.WINDING_NONZERO:\r\n\t\t\t\treturn (n !== 0);\r\n\t\t\tcase Tess2.WINDING_POSITIVE:\r\n\t\t\t\treturn (n > 0);\r\n\t\t\tcase Tess2.WINDING_NEGATIVE:\r\n\t\t\t\treturn (n < 0);\r\n\t\t\tcase Tess2.WINDING_ABS_GEQ_TWO:\r\n\t\t\t\treturn (n >= 2) || (n <= -2);\r\n\t\t}\r\n\t\tassert( false );\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )\r\n\tSweep.computeWinding = function( tess, reg ) {\r\n\t\treg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;\r\n\t\treg.inside = Sweep.isWindingInside( tess, reg.windingNumber );\r\n\t}\r\n\r\n\r\n\t//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )\r\n\tSweep.finishRegion = function( tess, reg ) {\r\n\t\t/*\r\n\t\t* Delete a region from the sweep line.  This happens when the upper\r\n\t\t* and lower chains of a region meet (at a vertex on the sweep line).\r\n\t\t* The \"inside\" flag is copied to the appropriate mesh face (we could\r\n\t\t* not do this before -- since the structure of the mesh is always\r\n\t\t* changing, this face may not have even existed until now).\r\n\t\t*/\r\n\t\tvar e = reg.eUp;\r\n\t\tvar f = e.Lface;\r\n\r\n\t\tf.inside = reg.inside;\r\n\t\tf.anEdge = e;   /* optimization for tessMeshTessellateMonoRegion() */\r\n\t\tSweep.deleteRegion( tess, reg );\r\n\t}\r\n\r\n\r\n\t//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )\r\n\tSweep.finishLeftRegions = function( tess, regFirst, regLast ) {\r\n\t\t/*\r\n\t\t* We are given a vertex with one or more left-going edges.  All affected\r\n\t\t* edges should be in the edge dictionary.  Starting at regFirst->eUp,\r\n\t\t* we walk down deleting all regions where both edges have the same\r\n\t\t* origin vOrg.  At the same time we copy the \"inside\" flag from the\r\n\t\t* active region to the face, since at this point each face will belong\r\n\t\t* to at most one region (this was not necessarily true until this point\r\n\t\t* in the sweep).  The walk stops at the region above regLast; if regLast\r\n\t\t* is NULL we walk as far as possible.  At the same time we relink the\r\n\t\t* mesh if necessary, so that the ordering of edges around vOrg is the\r\n\t\t* same as in the dictionary.\r\n\t\t*/\r\n\t\tvar e, ePrev;\r\n\t\tvar reg = null;\r\n\t\tvar regPrev = regFirst;\r\n\t\tvar ePrev = regFirst.eUp;\r\n\t\twhile( regPrev !== regLast ) {\r\n\t\t\tregPrev.fixUpperEdge = false;\t/* placement was OK */\r\n\t\t\treg = Sweep.regionBelow( regPrev );\r\n\t\t\te = reg.eUp;\r\n\t\t\tif( e.Org != ePrev.Org ) {\r\n\t\t\t\tif( ! reg.fixUpperEdge ) {\r\n\t\t\t\t\t/* Remove the last left-going edge.  Even though there are no further\r\n\t\t\t\t\t* edges in the dictionary with this origin, there may be further\r\n\t\t\t\t\t* such edges in the mesh (if we are adding left edges to a vertex\r\n\t\t\t\t\t* that has already been processed).  Thus it is important to call\r\n\t\t\t\t\t* FinishRegion rather than just DeleteRegion.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tSweep.finishRegion( tess, regPrev );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t/* If the edge below was a temporary edge introduced by\r\n\t\t\t\t* ConnectRightVertex, now is the time to fix it.\r\n\t\t\t\t*/\r\n\t\t\t\te = tess.mesh.connect( ePrev.Lprev, e.Sym );\r\n\t//\t\t\tif (e == NULL) longjmp(tess->env,1);\r\n\t\t\t\tSweep.fixUpperEdge( tess, reg, e );\r\n\t\t\t}\r\n\r\n\t\t\t/* Relink edges so that ePrev->Onext == e */\r\n\t\t\tif( ePrev.Onext !== e ) {\r\n\t\t\t\ttess.mesh.splice( e.Oprev, e );\r\n\t\t\t\ttess.mesh.splice( ePrev, e );\r\n\t\t\t}\r\n\t\t\tSweep.finishRegion( tess, regPrev );\t/* may change reg->eUp */\r\n\t\t\tePrev = reg.eUp;\r\n\t\t\tregPrev = reg;\r\n\t\t}\r\n\t\treturn ePrev;\r\n\t}\r\n\r\n\r\n\t//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )\r\n\tSweep.addRightEdges = function( tess, regUp, eFirst, eLast, eTopLeft, cleanUp ) {\r\n\t\t/*\r\n\t\t* Purpose: insert right-going edges into the edge dictionary, and update\r\n\t\t* winding numbers and mesh connectivity appropriately.  All right-going\r\n\t\t* edges share a common origin vOrg.  Edges are inserted CCW starting at\r\n\t\t* eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any\r\n\t\t* left-going edges already processed, then eTopLeft must be the edge\r\n\t\t* such that an imaginary upward vertical segment from vOrg would be\r\n\t\t* contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft\r\n\t\t* should be NULL.\r\n\t\t*/\r\n\t\tvar reg, regPrev;\r\n\t\tvar e, ePrev;\r\n\t\tvar firstTime = true;\r\n\r\n\t\t/* Insert the new right-going edges in the dictionary */\r\n\t\te = eFirst;\r\n\t\tdo {\r\n\t\t\tassert( Geom.vertLeq( e.Org, e.Dst ));\r\n\t\t\tSweep.addRegionBelow( tess, regUp, e.Sym );\r\n\t\t\te = e.Onext;\r\n\t\t} while ( e !== eLast );\r\n\r\n\t\t/* Walk *all* right-going edges from e->Org, in the dictionary order,\r\n\t\t* updating the winding numbers of each region, and re-linking the mesh\r\n\t\t* edges to match the dictionary ordering (if necessary).\r\n\t\t*/\r\n\t\tif( eTopLeft === null ) {\r\n\t\t\teTopLeft = Sweep.regionBelow( regUp ).eUp.Rprev;\r\n\t\t}\r\n\t\tregPrev = regUp;\r\n\t\tePrev = eTopLeft;\r\n\t\tfor( ;; ) {\r\n\t\t\treg = Sweep.regionBelow( regPrev );\r\n\t\t\te = reg.eUp.Sym;\r\n\t\t\tif( e.Org !== ePrev.Org ) break;\r\n\r\n\t\t\tif( e.Onext !== ePrev ) {\r\n\t\t\t\t/* Unlink e from its current position, and relink below ePrev */\r\n\t\t\t\ttess.mesh.splice( e.Oprev, e );\r\n\t\t\t\ttess.mesh.splice( ePrev.Oprev, e );\r\n\t\t\t}\r\n\t\t\t/* Compute the winding number and \"inside\" flag for the new regions */\r\n\t\t\treg.windingNumber = regPrev.windingNumber - e.winding;\r\n\t\t\treg.inside = Sweep.isWindingInside( tess, reg.windingNumber );\r\n\r\n\t\t\t/* Check for two outgoing edges with same slope -- process these\r\n\t\t\t* before any intersection tests (see example in tessComputeInterior).\r\n\t\t\t*/\r\n\t\t\tregPrev.dirty = true;\r\n\t\t\tif( ! firstTime && Sweep.checkForRightSplice( tess, regPrev )) {\r\n\t\t\t\tSweep.addWinding( e, ePrev );\r\n\t\t\t\tSweep.deleteRegion( tess, regPrev );\r\n\t\t\t\ttess.mesh.delete( ePrev );\r\n\t\t\t}\r\n\t\t\tfirstTime = false;\r\n\t\t\tregPrev = reg;\r\n\t\t\tePrev = e;\r\n\t\t}\r\n\t\tregPrev.dirty = true;\r\n\t\tassert( regPrev.windingNumber - e.winding === reg.windingNumber );\r\n\r\n\t\tif( cleanUp ) {\r\n\t\t\t/* Check for intersections between newly adjacent edges. */\r\n\t\t\tSweep.walkDirtyRegions( tess, regPrev );\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )\r\n\tSweep.spliceMergeVertices = function( tess, e1, e2 ) {\r\n\t\t/*\r\n\t\t* Two vertices with idential coordinates are combined into one.\r\n\t\t* e1->Org is kept, while e2->Org is discarded.\r\n\t\t*/\r\n\t\ttess.mesh.splice( e1, e2 ); \r\n\t}\r\n\r\n\t//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )\r\n\tSweep.vertexWeights = function( isect, org, dst ) {\r\n\t\t/*\r\n\t\t* Find some weights which describe how the intersection vertex is\r\n\t\t* a linear combination of \"org\" and \"dest\".  Each of the two edges\r\n\t\t* which generated \"isect\" is allocated 50% of the weight; each edge\r\n\t\t* splits the weight between its org and dst according to the\r\n\t\t* relative distance to \"isect\".\r\n\t\t*/\r\n\t\tvar t1 = Geom.vertL1dist( org, isect );\r\n\t\tvar t2 = Geom.vertL1dist( dst, isect );\r\n\t\tvar w0 = 0.5 * t2 / (t1 + t2);\r\n\t\tvar w1 = 0.5 * t1 / (t1 + t2);\r\n\t\tisect.coords[0] += w0*org.coords[0] + w1*dst.coords[0];\r\n\t\tisect.coords[1] += w0*org.coords[1] + w1*dst.coords[1];\r\n\t\tisect.coords[2] += w0*org.coords[2] + w1*dst.coords[2];\r\n\t}\r\n\r\n\r\n\t//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )\r\n\tSweep.getIntersectData = function( tess, isect, orgUp, dstUp, orgLo, dstLo ) {\r\n\t\t /*\r\n\t\t * We've computed a new intersection point, now we need a \"data\" pointer\r\n\t\t * from the user so that we can refer to this new vertex in the\r\n\t\t * rendering callbacks.\r\n\t\t */\r\n\t\tisect.coords[0] = isect.coords[1] = isect.coords[2] = 0;\r\n\t\tisect.idx = -1;\r\n\t\tSweep.vertexWeights( isect, orgUp, dstUp );\r\n\t\tSweep.vertexWeights( isect, orgLo, dstLo );\r\n\t}\r\n\r\n\t//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )\r\n\tSweep.checkForRightSplice = function( tess, regUp ) {\r\n\t\t/*\r\n\t\t* Check the upper and lower edge of \"regUp\", to make sure that the\r\n\t\t* eUp->Org is above eLo, or eLo->Org is below eUp (depending on which\r\n\t\t* origin is leftmost).\r\n\t\t*\r\n\t\t* The main purpose is to splice right-going edges with the same\r\n\t\t* dest vertex and nearly identical slopes (ie. we can't distinguish\r\n\t\t* the slopes numerically).  However the splicing can also help us\r\n\t\t* to recover from numerical errors.  For example, suppose at one\r\n\t\t* point we checked eUp and eLo, and decided that eUp->Org is barely\r\n\t\t* above eLo.  Then later, we split eLo into two edges (eg. from\r\n\t\t* a splice operation like this one).  This can change the result of\r\n\t\t* our test so that now eUp->Org is incident to eLo, or barely below it.\r\n\t\t* We must correct this condition to maintain the dictionary invariants.\r\n\t\t*\r\n\t\t* One possibility is to check these edges for intersection again\r\n\t\t* (ie. CheckForIntersect).  This is what we do if possible.  However\r\n\t\t* CheckForIntersect requires that tess->event lies between eUp and eLo,\r\n\t\t* so that it has something to fall back on when the intersection\r\n\t\t* calculation gives us an unusable answer.  So, for those cases where\r\n\t\t* we can't check for intersection, this routine fixes the problem\r\n\t\t* by just splicing the offending vertex into the other edge.\r\n\t\t* This is a guaranteed solution, no matter how degenerate things get.\r\n\t\t* Basically this is a combinatorial solution to a numerical problem.\r\n\t\t*/\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\r\n\t\tif( Geom.vertLeq( eUp.Org, eLo.Org )) {\r\n\t\t\tif( Geom.edgeSign( eLo.Dst, eUp.Org, eLo.Org ) > 0 ) return false;\r\n\r\n\t\t\t/* eUp->Org appears to be below eLo */\r\n\t\t\tif( ! Geom.vertEq( eUp.Org, eLo.Org )) {\r\n\t\t\t\t/* Splice eUp->Org into eLo */\r\n\t\t\t\ttess.mesh.splitEdge( eLo.Sym );\r\n\t\t\t\ttess.mesh.splice( eUp, eLo.Oprev );\r\n\t\t\t\tregUp.dirty = regLo.dirty = true;\r\n\r\n\t\t\t} else if( eUp.Org !== eLo.Org ) {\r\n\t\t\t\t/* merge the two vertices, discarding eUp->Org */\r\n\t\t\t\ttess.pq.delete( eUp.Org.pqHandle );\r\n\t\t\t\tSweep.spliceMergeVertices( tess, eLo.Oprev, eUp );\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif( Geom.edgeSign( eUp.Dst, eLo.Org, eUp.Org ) < 0 ) return false;\r\n\r\n\t\t\t/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */\r\n\t\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n\t\t\ttess.mesh.splitEdge( eUp.Sym );\r\n\t\t\ttess.mesh.splice( eLo.Oprev, eUp );\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )\r\n\tSweep.checkForLeftSplice = function( tess, regUp ) {\r\n\t\t/*\r\n\t\t* Check the upper and lower edge of \"regUp\", to make sure that the\r\n\t\t* eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which\r\n\t\t* destination is rightmost).\r\n\t\t*\r\n\t\t* Theoretically, this should always be true.  However, splitting an edge\r\n\t\t* into two pieces can change the results of previous tests.  For example,\r\n\t\t* suppose at one point we checked eUp and eLo, and decided that eUp->Dst\r\n\t\t* is barely above eLo.  Then later, we split eLo into two edges (eg. from\r\n\t\t* a splice operation like this one).  This can change the result of\r\n\t\t* the test so that now eUp->Dst is incident to eLo, or barely below it.\r\n\t\t* We must correct this condition to maintain the dictionary invariants\r\n\t\t* (otherwise new edges might get inserted in the wrong place in the\r\n\t\t* dictionary, and bad stuff will happen).\r\n\t\t*\r\n\t\t* We fix the problem by just splicing the offending vertex into the\r\n\t\t* other edge.\r\n\t\t*/\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\t\tvar e;\r\n\r\n\t\tassert( ! Geom.vertEq( eUp.Dst, eLo.Dst ));\r\n\r\n\t\tif( Geom.vertLeq( eUp.Dst, eLo.Dst )) {\r\n\t\t\tif( Geom.edgeSign( eUp.Dst, eLo.Dst, eUp.Org ) < 0 ) return false;\r\n\r\n\t\t\t/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */\r\n\t\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n\t\t\te = tess.mesh.splitEdge( eUp );\r\n\t\t\ttess.mesh.splice( eLo.Sym, e );\r\n\t\t\te.Lface.inside = regUp.inside;\r\n\t\t} else {\r\n\t\t\tif( Geom.edgeSign( eLo.Dst, eUp.Dst, eLo.Org ) > 0 ) return false;\r\n\r\n\t\t\t/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */\r\n\t\t\tregUp.dirty = regLo.dirty = true;\r\n\t\t\te = tess.mesh.splitEdge( eLo );\r\n\t\t\ttess.mesh.splice( eUp.Lnext, eLo.Sym );\r\n\t\t\te.Rface.inside = regUp.inside;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )\r\n\tSweep.checkForIntersect = function( tess, regUp ) {\r\n\t\t/*\r\n\t\t* Check the upper and lower edges of the given region to see if\r\n\t\t* they intersect.  If so, create the intersection and add it\r\n\t\t* to the data structures.\r\n\t\t*\r\n\t\t* Returns TRUE if adding the new intersection resulted in a recursive\r\n\t\t* call to AddRightEdges(); in this case all \"dirty\" regions have been\r\n\t\t* checked for intersections, and possibly regUp has been deleted.\r\n\t\t*/\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\t\tvar orgUp = eUp.Org;\r\n\t\tvar orgLo = eLo.Org;\r\n\t\tvar dstUp = eUp.Dst;\r\n\t\tvar dstLo = eLo.Dst;\r\n\t\tvar tMinUp, tMaxLo;\r\n\t\tvar isect = new TESSvertex, orgMin;\r\n\t\tvar e;\r\n\r\n\t\tassert( ! Geom.vertEq( dstLo, dstUp ));\r\n\t\tassert( Geom.edgeSign( dstUp, tess.event, orgUp ) <= 0 );\r\n\t\tassert( Geom.edgeSign( dstLo, tess.event, orgLo ) >= 0 );\r\n\t\tassert( orgUp !== tess.event && orgLo !== tess.event );\r\n\t\tassert( ! regUp.fixUpperEdge && ! regLo.fixUpperEdge );\r\n\r\n\t\tif( orgUp === orgLo ) return false;\t/* right endpoints are the same */\r\n\r\n\t\ttMinUp = Math.min( orgUp.t, dstUp.t );\r\n\t\ttMaxLo = Math.max( orgLo.t, dstLo.t );\r\n\t\tif( tMinUp > tMaxLo ) return false;\t/* t ranges do not overlap */\r\n\r\n\t\tif( Geom.vertLeq( orgUp, orgLo )) {\r\n\t\t\tif( Geom.edgeSign( dstLo, orgUp, orgLo ) > 0 ) return false;\r\n\t\t} else {\r\n\t\t\tif( Geom.edgeSign( dstUp, orgLo, orgUp ) < 0 ) return false;\r\n\t\t}\r\n\r\n\t\t/* At this point the edges intersect, at least marginally */\r\n\t\tSweep.debugEvent( tess );\r\n\r\n\t\tGeom.intersect( dstUp, orgUp, dstLo, orgLo, isect );\r\n\t\t/* The following properties are guaranteed: */\r\n\t\tassert( Math.min( orgUp.t, dstUp.t ) <= isect.t );\r\n\t\tassert( isect.t <= Math.max( orgLo.t, dstLo.t ));\r\n\t\tassert( Math.min( dstLo.s, dstUp.s ) <= isect.s );\r\n\t\tassert( isect.s <= Math.max( orgLo.s, orgUp.s ));\r\n\r\n\t\tif( Geom.vertLeq( isect, tess.event )) {\r\n\t\t\t/* The intersection point lies slightly to the left of the sweep line,\r\n\t\t\t* so move it until it''s slightly to the right of the sweep line.\r\n\t\t\t* (If we had perfect numerical precision, this would never happen\r\n\t\t\t* in the first place).  The easiest and safest thing to do is\r\n\t\t\t* replace the intersection by tess->event.\r\n\t\t\t*/\r\n\t\t\tisect.s = tess.event.s;\r\n\t\t\tisect.t = tess.event.t;\r\n\t\t}\r\n\t\t/* Similarly, if the computed intersection lies to the right of the\r\n\t\t* rightmost origin (which should rarely happen), it can cause\r\n\t\t* unbelievable inefficiency on sufficiently degenerate inputs.\r\n\t\t* (If you have the test program, try running test54.d with the\r\n\t\t* \"X zoom\" option turned on).\r\n\t\t*/\r\n\t\torgMin = Geom.vertLeq( orgUp, orgLo ) ? orgUp : orgLo;\r\n\t\tif( Geom.vertLeq( orgMin, isect )) {\r\n\t\t\tisect.s = orgMin.s;\r\n\t\t\tisect.t = orgMin.t;\r\n\t\t}\r\n\r\n\t\tif( Geom.vertEq( isect, orgUp ) || Geom.vertEq( isect, orgLo )) {\r\n\t\t\t/* Easy case -- intersection at one of the right endpoints */\r\n\t\t\tSweep.checkForRightSplice( tess, regUp );\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(    (! Geom.vertEq( dstUp, tess.event )\r\n\t\t\t&& Geom.edgeSign( dstUp, tess.event, isect ) >= 0)\r\n\t\t\t|| (! Geom.vertEq( dstLo, tess.event )\r\n\t\t\t&& Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ))\r\n\t\t{\r\n\t\t\t/* Very unusual -- the new upper or lower edge would pass on the\r\n\t\t\t* wrong side of the sweep event, or through it.  This can happen\r\n\t\t\t* due to very small numerical errors in the intersection calculation.\r\n\t\t\t*/\r\n\t\t\tif( dstLo === tess.event ) {\r\n\t\t\t\t/* Splice dstLo into eUp, and process the new region(s) */\r\n\t\t\t\ttess.mesh.splitEdge( eUp.Sym );\r\n\t\t\t\ttess.mesh.splice( eLo.Sym, eUp );\r\n\t\t\t\tregUp = Sweep.topLeftRegion( tess, regUp );\r\n\t//\t\t\tif (regUp == NULL) longjmp(tess->env,1);\r\n\t\t\t\teUp = Sweep.regionBelow(regUp).eUp;\r\n\t\t\t\tSweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );\r\n\t\t\t\tSweep.addRightEdges( tess, regUp, eUp.Oprev, eUp, eUp, true );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif( dstUp === tess.event ) {\r\n\t\t\t\t/* Splice dstUp into eLo, and process the new region(s) */\r\n\t\t\t\ttess.mesh.splitEdge( eLo.Sym );\r\n\t\t\t\ttess.mesh.splice( eUp.Lnext, eLo.Oprev ); \r\n\t\t\t\tregLo = regUp;\r\n\t\t\t\tregUp = Sweep.topRightRegion( regUp );\r\n\t\t\t\te = Sweep.regionBelow(regUp).eUp.Rprev;\r\n\t\t\t\tregLo.eUp = eLo.Oprev;\r\n\t\t\t\teLo = Sweep.finishLeftRegions( tess, regLo, null );\r\n\t\t\t\tSweep.addRightEdges( tess, regUp, eLo.Onext, eUp.Rprev, e, true );\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t/* Special case: called from ConnectRightVertex.  If either\r\n\t\t\t* edge passes on the wrong side of tess->event, split it\r\n\t\t\t* (and wait for ConnectRightVertex to splice it appropriately).\r\n\t\t\t*/\r\n\t\t\tif( Geom.edgeSign( dstUp, tess.event, isect ) >= 0 ) {\r\n\t\t\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n\t\t\t\ttess.mesh.splitEdge( eUp.Sym );\r\n\t\t\t\teUp.Org.s = tess.event.s;\r\n\t\t\t\teUp.Org.t = tess.event.t;\r\n\t\t\t}\r\n\t\t\tif( Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ) {\r\n\t\t\t\tregUp.dirty = regLo.dirty = true;\r\n\t\t\t\ttess.mesh.splitEdge( eLo.Sym );\r\n\t\t\t\teLo.Org.s = tess.event.s;\r\n\t\t\t\teLo.Org.t = tess.event.t;\r\n\t\t\t}\r\n\t\t\t/* leave the rest for ConnectRightVertex */\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* General case -- split both edges, splice into new vertex.\r\n\t\t* When we do the splice operation, the order of the arguments is\r\n\t\t* arbitrary as far as correctness goes.  However, when the operation\r\n\t\t* creates a new face, the work done is proportional to the size of\r\n\t\t* the new face.  We expect the faces in the processed part of\r\n\t\t* the mesh (ie. eUp->Lface) to be smaller than the faces in the\r\n\t\t* unprocessed original contours (which will be eLo->Oprev->Lface).\r\n\t\t*/\r\n\t\ttess.mesh.splitEdge( eUp.Sym );\r\n\t\ttess.mesh.splitEdge( eLo.Sym );\r\n\t\ttess.mesh.splice( eLo.Oprev, eUp );\r\n\t\teUp.Org.s = isect.s;\r\n\t\teUp.Org.t = isect.t;\r\n\t\teUp.Org.pqHandle = tess.pq.insert( eUp.Org );\r\n\t\tSweep.getIntersectData( tess, eUp.Org, orgUp, dstUp, orgLo, dstLo );\r\n\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )\r\n\tSweep.walkDirtyRegions = function( tess, regUp ) {\r\n\t\t/*\r\n\t\t* When the upper or lower edge of any region changes, the region is\r\n\t\t* marked \"dirty\".  This routine walks through all the dirty regions\r\n\t\t* and makes sure that the dictionary invariants are satisfied\r\n\t\t* (see the comments at the beginning of this file).  Of course\r\n\t\t* new dirty regions can be created as we make changes to restore\r\n\t\t* the invariants.\r\n\t\t*/\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp, eLo;\r\n\r\n\t\tfor( ;; ) {\r\n\t\t\t/* Find the lowest dirty region (we walk from the bottom up). */\r\n\t\t\twhile( regLo.dirty ) {\r\n\t\t\t\tregUp = regLo;\r\n\t\t\t\tregLo = Sweep.regionBelow(regLo);\r\n\t\t\t}\r\n\t\t\tif( ! regUp.dirty ) {\r\n\t\t\t\tregLo = regUp;\r\n\t\t\t\tregUp = Sweep.regionAbove( regUp );\r\n\t\t\t\tif( regUp === null || ! regUp.dirty ) {\r\n\t\t\t\t\t/* We've walked all the dirty regions */\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tregUp.dirty = false;\r\n\t\t\teUp = regUp.eUp;\r\n\t\t\teLo = regLo.eUp;\r\n\r\n\t\t\tif( eUp.Dst !== eLo.Dst ) {\r\n\t\t\t\t/* Check that the edge ordering is obeyed at the Dst vertices. */\r\n\t\t\t\tif( Sweep.checkForLeftSplice( tess, regUp )) {\r\n\r\n\t\t\t\t\t/* If the upper or lower edge was marked fixUpperEdge, then\r\n\t\t\t\t\t* we no longer need it (since these edges are needed only for\r\n\t\t\t\t\t* vertices which otherwise have no right-going edges).\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tif( regLo.fixUpperEdge ) {\r\n\t\t\t\t\t\tSweep.deleteRegion( tess, regLo );\r\n\t\t\t\t\t\ttess.mesh.delete( eLo );\r\n\t\t\t\t\t\tregLo = Sweep.regionBelow( regUp );\r\n\t\t\t\t\t\teLo = regLo.eUp;\r\n\t\t\t\t\t} else if( regUp.fixUpperEdge ) {\r\n\t\t\t\t\t\tSweep.deleteRegion( tess, regUp );\r\n\t\t\t\t\t\ttess.mesh.delete( eUp );\r\n\t\t\t\t\t\tregUp = Sweep.regionAbove( regLo );\r\n\t\t\t\t\t\teUp = regUp.eUp;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( eUp.Org !== eLo.Org ) {\r\n\t\t\t\tif(    eUp.Dst !== eLo.Dst\r\n\t\t\t\t\t&& ! regUp.fixUpperEdge && ! regLo.fixUpperEdge\r\n\t\t\t\t\t&& (eUp.Dst === tess.event || eLo.Dst === tess.event) )\r\n\t\t\t\t{\r\n\t\t\t\t\t/* When all else fails in CheckForIntersect(), it uses tess->event\r\n\t\t\t\t\t* as the intersection location.  To make this possible, it requires\r\n\t\t\t\t\t* that tess->event lie between the upper and lower edges, and also\r\n\t\t\t\t\t* that neither of these is marked fixUpperEdge (since in the worst\r\n\t\t\t\t\t* case it might splice one of these edges into tess->event, and\r\n\t\t\t\t\t* violate the invariant that fixable edges are the only right-going\r\n\t\t\t\t\t* edge from their associated vertex).\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tif( Sweep.checkForIntersect( tess, regUp )) {\r\n\t\t\t\t\t\t/* WalkDirtyRegions() was called recursively; we're done */\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* Even though we can't use CheckForIntersect(), the Org vertices\r\n\t\t\t\t\t* may violate the dictionary edge ordering.  Check and correct this.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tSweep.checkForRightSplice( tess, regUp );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( eUp.Org === eLo.Org && eUp.Dst === eLo.Dst ) {\r\n\t\t\t\t/* A degenerate loop consisting of only two edges -- delete it. */\r\n\t\t\t\tSweep.addWinding( eLo, eUp );\r\n\t\t\t\tSweep.deleteRegion( tess, regUp );\r\n\t\t\t\ttess.mesh.delete( eUp );\r\n\t\t\t\tregUp = Sweep.regionAbove( regLo );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )\r\n\tSweep.connectRightVertex = function( tess, regUp, eBottomLeft ) {\r\n\t\t/*\r\n\t\t* Purpose: connect a \"right\" vertex vEvent (one where all edges go left)\r\n\t\t* to the unprocessed portion of the mesh.  Since there are no right-going\r\n\t\t* edges, two regions (one above vEvent and one below) are being merged\r\n\t\t* into one.  \"regUp\" is the upper of these two regions.\r\n\t\t*\r\n\t\t* There are two reasons for doing this (adding a right-going edge):\r\n\t\t*  - if the two regions being merged are \"inside\", we must add an edge\r\n\t\t*    to keep them separated (the combined region would not be monotone).\r\n\t\t*  - in any case, we must leave some record of vEvent in the dictionary,\r\n\t\t*    so that we can merge vEvent with features that we have not seen yet.\r\n\t\t*    For example, maybe there is a vertical edge which passes just to\r\n\t\t*    the right of vEvent; we would like to splice vEvent into this edge.\r\n\t\t*\r\n\t\t* However, we don't want to connect vEvent to just any vertex.  We don''t\r\n\t\t* want the new edge to cross any other edges; otherwise we will create\r\n\t\t* intersection vertices even when the input data had no self-intersections.\r\n\t\t* (This is a bad thing; if the user's input data has no intersections,\r\n\t\t* we don't want to generate any false intersections ourselves.)\r\n\t\t*\r\n\t\t* Our eventual goal is to connect vEvent to the leftmost unprocessed\r\n\t\t* vertex of the combined region (the union of regUp and regLo).\r\n\t\t* But because of unseen vertices with all right-going edges, and also\r\n\t\t* new vertices which may be created by edge intersections, we don''t\r\n\t\t* know where that leftmost unprocessed vertex is.  In the meantime, we\r\n\t\t* connect vEvent to the closest vertex of either chain, and mark the region\r\n\t\t* as \"fixUpperEdge\".  This flag says to delete and reconnect this edge\r\n\t\t* to the next processed vertex on the boundary of the combined region.\r\n\t\t* Quite possibly the vertex we connected to will turn out to be the\r\n\t\t* closest one, in which case we won''t need to make any changes.\r\n\t\t*/\r\n\t\tvar eNew;\r\n\t\tvar eTopLeft = eBottomLeft.Onext;\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\t\tvar degenerate = false;\r\n\r\n\t\tif( eUp.Dst !== eLo.Dst ) {\r\n\t\t\tSweep.checkForIntersect( tess, regUp );\r\n\t\t}\r\n\r\n\t\t/* Possible new degeneracies: upper or lower edge of regUp may pass\r\n\t\t* through vEvent, or may coincide with new intersection vertex\r\n\t\t*/\r\n\t\tif( Geom.vertEq( eUp.Org, tess.event )) {\r\n\t\t\ttess.mesh.splice( eTopLeft.Oprev, eUp );\r\n\t\t\tregUp = Sweep.topLeftRegion( tess, regUp );\r\n\t\t\teTopLeft = Sweep.regionBelow( regUp ).eUp;\r\n\t\t\tSweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );\r\n\t\t\tdegenerate = true;\r\n\t\t}\r\n\t\tif( Geom.vertEq( eLo.Org, tess.event )) {\r\n\t\t\ttess.mesh.splice( eBottomLeft, eLo.Oprev );\r\n\t\t\teBottomLeft = Sweep.finishLeftRegions( tess, regLo, null );\r\n\t\t\tdegenerate = true;\r\n\t\t}\r\n\t\tif( degenerate ) {\r\n\t\t\tSweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Non-degenerate situation -- need to add a temporary, fixable edge.\r\n\t\t* Connect to the closer of eLo->Org, eUp->Org.\r\n\t\t*/\r\n\t\tif( Geom.vertLeq( eLo.Org, eUp.Org )) {\r\n\t\t\teNew = eLo.Oprev;\r\n\t\t} else {\r\n\t\t\teNew = eUp;\r\n\t\t}\r\n\t\teNew = tess.mesh.connect( eBottomLeft.Lprev, eNew );\r\n\r\n\t\t/* Prevent cleanup, otherwise eNew might disappear before we've even\r\n\t\t* had a chance to mark it as a temporary edge.\r\n\t\t*/\r\n\t\tSweep.addRightEdges( tess, regUp, eNew, eNew.Onext, eNew.Onext, false );\r\n\t\teNew.Sym.activeRegion.fixUpperEdge = true;\r\n\t\tSweep.walkDirtyRegions( tess, regUp );\r\n\t}\r\n\r\n\t/* Because vertices at exactly the same location are merged together\r\n\t* before we process the sweep event, some degenerate cases can't occur.\r\n\t* However if someone eventually makes the modifications required to\r\n\t* merge features which are close together, the cases below marked\r\n\t* TOLERANCE_NONZERO will be useful.  They were debugged before the\r\n\t* code to merge identical vertices in the main loop was added.\r\n\t*/\r\n\t//#define TOLERANCE_NONZERO\tFALSE\r\n\r\n\t//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )\r\n\tSweep.connectLeftDegenerate = function( tess, regUp, vEvent ) {\r\n\t\t/*\r\n\t\t* The event vertex lies exacty on an already-processed edge or vertex.\r\n\t\t* Adding the new vertex involves splicing it into the already-processed\r\n\t\t* part of the mesh.\r\n\t\t*/\r\n\t\tvar e, eTopLeft, eTopRight, eLast;\r\n\t\tvar reg;\r\n\r\n\t\te = regUp.eUp;\r\n\t\tif( Geom.vertEq( e.Org, vEvent )) {\r\n\t\t\t/* e->Org is an unprocessed vertex - just combine them, and wait\r\n\t\t\t* for e->Org to be pulled from the queue\r\n\t\t\t*/\r\n\t\t\tassert( false /*TOLERANCE_NONZERO*/ );\r\n\t\t\tSweep.spliceMergeVertices( tess, e, vEvent.anEdge );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif( ! Geom.vertEq( e.Dst, vEvent )) {\r\n\t\t\t/* General case -- splice vEvent into edge e which passes through it */\r\n\t\t\ttess.mesh.splitEdge( e.Sym );\r\n\t\t\tif( regUp.fixUpperEdge ) {\r\n\t\t\t\t/* This edge was fixable -- delete unused portion of original edge */\r\n\t\t\t\ttess.mesh.delete( e.Onext );\r\n\t\t\t\tregUp.fixUpperEdge = false;\r\n\t\t\t}\r\n\t\t\ttess.mesh.splice( vEvent.anEdge, e );\r\n\t\t\tSweep.sweepEvent( tess, vEvent );\t/* recurse */\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* vEvent coincides with e->Dst, which has already been processed.\r\n\t\t* Splice in the additional right-going edges.\r\n\t\t*/\r\n\t\tassert( false /*TOLERANCE_NONZERO*/ );\r\n\t\tregUp = Sweep.topRightRegion( regUp );\r\n\t\treg = Sweep.regionBelow( regUp );\r\n\t\teTopRight = reg.eUp.Sym;\r\n\t\teTopLeft = eLast = eTopRight.Onext;\r\n\t\tif( reg.fixUpperEdge ) {\r\n\t\t\t/* Here e->Dst has only a single fixable edge going right.\r\n\t\t\t* We can delete it since now we have some real right-going edges.\r\n\t\t\t*/\r\n\t\t\tassert( eTopLeft !== eTopRight );   /* there are some left edges too */\r\n\t\t\tSweep.deleteRegion( tess, reg );\r\n\t\t\ttess.mesh.delete( eTopRight );\r\n\t\t\teTopRight = eTopLeft.Oprev;\r\n\t\t}\r\n\t\ttess.mesh.splice( vEvent.anEdge, eTopRight );\r\n\t\tif( ! Geom.edgeGoesLeft( eTopLeft )) {\r\n\t\t\t/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */\r\n\t\t\teTopLeft = null;\r\n\t\t}\r\n\t\tSweep.addRightEdges( tess, regUp, eTopRight.Onext, eLast, eTopLeft, true );\r\n\t}\r\n\r\n\r\n\t//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )\r\n\tSweep.connectLeftVertex = function( tess, vEvent ) {\r\n\t\t/*\r\n\t\t* Purpose: connect a \"left\" vertex (one where both edges go right)\r\n\t\t* to the processed portion of the mesh.  Let R be the active region\r\n\t\t* containing vEvent, and let U and L be the upper and lower edge\r\n\t\t* chains of R.  There are two possibilities:\r\n\t\t*\r\n\t\t* - the normal case: split R into two regions, by connecting vEvent to\r\n\t\t*   the rightmost vertex of U or L lying to the left of the sweep line\r\n\t\t*\r\n\t\t* - the degenerate case: if vEvent is close enough to U or L, we\r\n\t\t*   merge vEvent into that edge chain.  The subcases are:\r\n\t\t*\t- merging with the rightmost vertex of U or L\r\n\t\t*\t- merging with the active edge of U or L\r\n\t\t*\t- merging with an already-processed portion of U or L\r\n\t\t*/\r\n\t\tvar regUp, regLo, reg;\r\n\t\tvar eUp, eLo, eNew;\r\n\t\tvar tmp = new ActiveRegion();\r\n\r\n\t\t/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */\r\n\r\n\t\t/* Get a pointer to the active region containing vEvent */\r\n\t\ttmp.eUp = vEvent.anEdge.Sym;\r\n\t\t/* __GL_DICTLISTKEY */ /* tessDictListSearch */\r\n\t\tregUp = tess.dict.search( tmp ).key;\r\n\t\tregLo = Sweep.regionBelow( regUp );\r\n\t\tif( !regLo ) {\r\n\t\t\t// This may happen if the input polygon is coplanar.\r\n\t\t\treturn;\r\n\t\t}\r\n\t\teUp = regUp.eUp;\r\n\t\teLo = regLo.eUp;\r\n\r\n\t\t/* Try merging with U or L first */\r\n\t\tif( Geom.edgeSign( eUp.Dst, vEvent, eUp.Org ) === 0.0 ) {\r\n\t\t\tSweep.connectLeftDegenerate( tess, regUp, vEvent );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Connect vEvent to rightmost processed vertex of either chain.\r\n\t\t* e->Dst is the vertex that we will connect to vEvent.\r\n\t\t*/\r\n\t\treg = Geom.vertLeq( eLo.Dst, eUp.Dst ) ? regUp : regLo;\r\n\r\n\t\tif( regUp.inside || reg.fixUpperEdge) {\r\n\t\t\tif( reg === regUp ) {\r\n\t\t\t\teNew = tess.mesh.connect( vEvent.anEdge.Sym, eUp.Lnext );\r\n\t\t\t} else {\r\n\t\t\t\tvar tempHalfEdge = tess.mesh.connect( eLo.Dnext, vEvent.anEdge);\r\n\t\t\t\teNew = tempHalfEdge.Sym;\r\n\t\t\t}\r\n\t\t\tif( reg.fixUpperEdge ) {\r\n\t\t\t\tSweep.fixUpperEdge( tess, reg, eNew );\r\n\t\t\t} else {\r\n\t\t\t\tSweep.computeWinding( tess, Sweep.addRegionBelow( tess, regUp, eNew ));\r\n\t\t\t}\r\n\t\t\tSweep.sweepEvent( tess, vEvent );\r\n\t\t} else {\r\n\t\t\t/* The new vertex is in a region which does not belong to the polygon.\r\n\t\t\t* We don''t need to connect this vertex to the rest of the mesh.\r\n\t\t\t*/\r\n\t\t\tSweep.addRightEdges( tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )\r\n\tSweep.sweepEvent = function( tess, vEvent ) {\r\n\t\t/*\r\n\t\t* Does everything necessary when the sweep line crosses a vertex.\r\n\t\t* Updates the mesh and the edge dictionary.\r\n\t\t*/\r\n\r\n\t\ttess.event = vEvent;\t\t/* for access in EdgeLeq() */\r\n\t\tSweep.debugEvent( tess );\r\n\r\n\t\t/* Check if this vertex is the right endpoint of an edge that is\r\n\t\t* already in the dictionary.  In this case we don't need to waste\r\n\t\t* time searching for the location to insert new edges.\r\n\t\t*/\r\n\t\tvar e = vEvent.anEdge;\r\n\t\twhile( e.activeRegion === null ) {\r\n\t\t\te = e.Onext;\r\n\t\t\tif( e === vEvent.anEdge ) {\r\n\t\t\t\t/* All edges go right -- not incident to any processed edges */\r\n\t\t\t\tSweep.connectLeftVertex( tess, vEvent );\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Processing consists of two phases: first we \"finish\" all the\r\n\t\t* active regions where both the upper and lower edges terminate\r\n\t\t* at vEvent (ie. vEvent is closing off these regions).\r\n\t\t* We mark these faces \"inside\" or \"outside\" the polygon according\r\n\t\t* to their winding number, and delete the edges from the dictionary.\r\n\t\t* This takes care of all the left-going edges from vEvent.\r\n\t\t*/\r\n\t\tvar regUp = Sweep.topLeftRegion( tess, e.activeRegion );\r\n\t\tassert( regUp !== null );\r\n\t//\tif (regUp == NULL) longjmp(tess->env,1);\r\n\t\tvar reg = Sweep.regionBelow( regUp );\r\n\t\tvar eTopLeft = reg.eUp;\r\n\t\tvar eBottomLeft = Sweep.finishLeftRegions( tess, reg, null );\r\n\r\n\t\t/* Next we process all the right-going edges from vEvent.  This\r\n\t\t* involves adding the edges to the dictionary, and creating the\r\n\t\t* associated \"active regions\" which record information about the\r\n\t\t* regions between adjacent dictionary edges.\r\n\t\t*/\r\n\t\tif( eBottomLeft.Onext === eTopLeft ) {\r\n\t\t\t/* No right-going edges -- add a temporary \"fixable\" edge */\r\n\t\t\tSweep.connectRightVertex( tess, regUp, eBottomLeft );\r\n\t\t} else {\r\n\t\t\tSweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t/* Make the sentinel coordinates big enough that they will never be\r\n\t* merged with real input features.\r\n\t*/\r\n\r\n\t//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )\r\n\tSweep.addSentinel = function( tess, smin, smax, t ) {\r\n\t\t/*\r\n\t\t* We add two sentinel edges above and below all other edges,\r\n\t\t* to avoid special cases at the top and bottom.\r\n\t\t*/\r\n\t\tvar reg = new ActiveRegion();\r\n\t\tvar e = tess.mesh.makeEdge();\r\n\t//\tif (e == NULL) longjmp(tess->env,1);\r\n\r\n\t\te.Org.s = smax;\r\n\t\te.Org.t = t;\r\n\t\te.Dst.s = smin;\r\n\t\te.Dst.t = t;\r\n\t\ttess.event = e.Dst;\t\t/* initialize it */\r\n\r\n\t\treg.eUp = e;\r\n\t\treg.windingNumber = 0;\r\n\t\treg.inside = false;\r\n\t\treg.fixUpperEdge = false;\r\n\t\treg.sentinel = true;\r\n\t\treg.dirty = false;\r\n\t\treg.nodeUp = tess.dict.insert( reg );\r\n\t//\tif (reg->nodeUp == NULL) longjmp(tess->env,1);\r\n\t}\r\n\r\n\r\n\t//static void InitEdgeDict( TESStesselator *tess )\r\n\tSweep.initEdgeDict = function( tess ) {\r\n\t\t/*\r\n\t\t* We maintain an ordering of edge intersections with the sweep line.\r\n\t\t* This order is maintained in a dynamic dictionary.\r\n\t\t*/\r\n\t\ttess.dict = new Dict( tess, Sweep.edgeLeq );\r\n\t//\tif (tess->dict == NULL) longjmp(tess->env,1);\r\n\r\n\t\tvar w = (tess.bmax[0] - tess.bmin[0]);\r\n\t\tvar h = (tess.bmax[1] - tess.bmin[1]);\r\n\r\n\t\tvar smin = tess.bmin[0] - w;\r\n\t\tvar smax = tess.bmax[0] + w;\r\n\t\tvar tmin = tess.bmin[1] - h;\r\n\t\tvar tmax = tess.bmax[1] + h;\r\n\r\n\t\tSweep.addSentinel( tess, smin, smax, tmin );\r\n\t\tSweep.addSentinel( tess, smin, smax, tmax );\r\n\t}\r\n\r\n\r\n\tSweep.doneEdgeDict = function( tess )\r\n\t{\r\n\t\tvar reg;\r\n\t\tvar fixedEdges = 0;\r\n\r\n\t\twhile( (reg = tess.dict.min().key) !== null ) {\r\n\t\t\t/*\r\n\t\t\t* At the end of all processing, the dictionary should contain\r\n\t\t\t* only the two sentinel edges, plus at most one \"fixable\" edge\r\n\t\t\t* created by ConnectRightVertex().\r\n\t\t\t*/\r\n\t\t\tif( ! reg.sentinel ) {\r\n\t\t\t\tassert( reg.fixUpperEdge );\r\n\t\t\t\tassert( ++fixedEdges === 1 );\r\n\t\t\t}\r\n\t\t\tassert( reg.windingNumber === 0 );\r\n\t\t\tSweep.deleteRegion( tess, reg );\r\n\t\t\t/*    tessMeshDelete( reg->eUp );*/\r\n\t\t}\r\n\t//\tdictDeleteDict( &tess->alloc, tess->dict );\r\n\t}\r\n\r\n\r\n\tSweep.removeDegenerateEdges = function( tess ) {\r\n\t\t/*\r\n\t\t* Remove zero-length edges, and contours with fewer than 3 vertices.\r\n\t\t*/\r\n\t\tvar e, eNext, eLnext;\r\n\t\tvar eHead = tess.mesh.eHead;\r\n\r\n\t\t/*LINTED*/\r\n\t\tfor( e = eHead.next; e !== eHead; e = eNext ) {\r\n\t\t\teNext = e.next;\r\n\t\t\teLnext = e.Lnext;\r\n\r\n\t\t\tif( Geom.vertEq( e.Org, e.Dst ) && e.Lnext.Lnext !== e ) {\r\n\t\t\t\t/* Zero-length edge, contour has at least 3 edges */\r\n\t\t\t\tSweep.spliceMergeVertices( tess, eLnext, e );\t/* deletes e->Org */\r\n\t\t\t\ttess.mesh.delete( e ); /* e is a self-loop */\r\n\t\t\t\te = eLnext;\r\n\t\t\t\teLnext = e.Lnext;\r\n\t\t\t}\r\n\t\t\tif( eLnext.Lnext === e ) {\r\n\t\t\t\t/* Degenerate contour (one or two edges) */\r\n\t\t\t\tif( eLnext !== e ) {\r\n\t\t\t\t\tif( eLnext === eNext || eLnext === eNext.Sym ) { eNext = eNext.next; }\r\n\t\t\t\t\ttess.mesh.delete( eLnext );\r\n\t\t\t\t}\r\n\t\t\t\tif( e === eNext || e === eNext.Sym ) { eNext = eNext.next; }\r\n\t\t\t\ttess.mesh.delete( e );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tSweep.initPriorityQ = function( tess ) {\r\n\t\t/*\r\n\t\t* Insert all vertices into the priority queue which determines the\r\n\t\t* order in which vertices cross the sweep line.\r\n\t\t*/\r\n\t\tvar pq;\r\n\t\tvar v, vHead;\r\n\t\tvar vertexCount = 0;\r\n\t\t\r\n\t\tvHead = tess.mesh.vHead;\r\n\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\tvertexCount++;\r\n\t\t}\r\n\t\t/* Make sure there is enough space for sentinels. */\r\n\t\tvertexCount += 8; //MAX( 8, tess->alloc.extraVertices );\r\n\t\t\r\n\t\tpq = tess.pq = new PriorityQ( vertexCount, Geom.vertLeq );\r\n\t//\tif (pq == NULL) return 0;\r\n\r\n\t\tvHead = tess.mesh.vHead;\r\n\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\tv.pqHandle = pq.insert( v );\r\n\t//\t\tif (v.pqHandle == INV_HANDLE)\r\n\t//\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (v !== vHead) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tpq.init();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tSweep.donePriorityQ = function( tess ) {\r\n\t\ttess.pq = null;\r\n\t}\r\n\r\n\r\n\tSweep.removeDegenerateFaces = function( tess, mesh ) {\r\n\t\t/*\r\n\t\t* Delete any degenerate faces with only two edges.  WalkDirtyRegions()\r\n\t\t* will catch almost all of these, but it won't catch degenerate faces\r\n\t\t* produced by splice operations on already-processed edges.\r\n\t\t* The two places this can happen are in FinishLeftRegions(), when\r\n\t\t* we splice in a \"temporary\" edge produced by ConnectRightVertex(),\r\n\t\t* and in CheckForLeftSplice(), where we splice already-processed\r\n\t\t* edges to ensure that our dictionary invariants are not violated\r\n\t\t* by numerical errors.\r\n\t\t*\r\n\t\t* In both these cases it is *very* dangerous to delete the offending\r\n\t\t* edge at the time, since one of the routines further up the stack\r\n\t\t* will sometimes be keeping a pointer to that edge.\r\n\t\t*/\r\n\t\tvar f, fNext;\r\n\t\tvar e;\r\n\r\n\t\t/*LINTED*/\r\n\t\tfor( f = mesh.fHead.next; f !== mesh.fHead; f = fNext ) {\r\n\t\t\tfNext = f.next;\r\n\t\t\te = f.anEdge;\r\n\t\t\tassert( e.Lnext !== e );\r\n\r\n\t\t\tif( e.Lnext.Lnext === e ) {\r\n\t\t\t\t/* A face with only two edges */\r\n\t\t\t\tSweep.addWinding( e.Onext, e );\r\n\t\t\t\ttess.mesh.delete( e );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tSweep.computeInterior = function( tess ) {\r\n\t\t/*\r\n\t\t* tessComputeInterior( tess ) computes the planar arrangement specified\r\n\t\t* by the given contours, and further subdivides this arrangement\r\n\t\t* into regions.  Each region is marked \"inside\" if it belongs\r\n\t\t* to the polygon, according to the rule given by tess->windingRule.\r\n\t\t* Each interior region is guaranteed be monotone.\r\n\t\t*/\r\n\t\tvar v, vNext;\r\n\r\n\t\t/* Each vertex defines an event for our sweep line.  Start by inserting\r\n\t\t* all the vertices in a priority queue.  Events are processed in\r\n\t\t* lexicographic order, ie.\r\n\t\t*\r\n\t\t*\te1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)\r\n\t\t*/\r\n\t\tSweep.removeDegenerateEdges( tess );\r\n\t\tif ( !Sweep.initPriorityQ( tess ) ) return false; /* if error */\r\n\t\tSweep.initEdgeDict( tess );\r\n\r\n\t\twhile( (v = tess.pq.extractMin()) !== null ) {\r\n\t\t\tfor( ;; ) {\r\n\t\t\t\tvNext = tess.pq.min();\r\n\t\t\t\tif( vNext === null || ! Geom.vertEq( vNext, v )) break;\r\n\r\n\t\t\t\t/* Merge together all vertices at exactly the same location.\r\n\t\t\t\t* This is more efficient than processing them one at a time,\r\n\t\t\t\t* simplifies the code (see ConnectLeftDegenerate), and is also\r\n\t\t\t\t* important for correct handling of certain degenerate cases.\r\n\t\t\t\t* For example, suppose there are two identical edges A and B\r\n\t\t\t\t* that belong to different contours (so without this code they would\r\n\t\t\t\t* be processed by separate sweep events).  Suppose another edge C\r\n\t\t\t\t* crosses A and B from above.  When A is processed, we split it\r\n\t\t\t\t* at its intersection point with C.  However this also splits C,\r\n\t\t\t\t* so when we insert B we may compute a slightly different\r\n\t\t\t\t* intersection point.  This might leave two edges with a small\r\n\t\t\t\t* gap between them.  This kind of error is especially obvious\r\n\t\t\t\t* when using boundary extraction (TESS_BOUNDARY_ONLY).\r\n\t\t\t\t*/\r\n\t\t\t\tvNext = tess.pq.extractMin();\r\n\t\t\t\tSweep.spliceMergeVertices( tess, v.anEdge, vNext.anEdge );\r\n\t\t\t}\r\n\t\t\tSweep.sweepEvent( tess, v );\r\n\t\t}\r\n\r\n\t\t/* Set tess->event for debugging purposes */\r\n\t\ttess.event = tess.dict.min().key.eUp.Org;\r\n\t\tSweep.debugEvent( tess );\r\n\t\tSweep.doneEdgeDict( tess );\r\n\t\tSweep.donePriorityQ( tess );\r\n\r\n\t\tif ( !Sweep.removeDegenerateFaces( tess, tess.mesh ) ) return false;\r\n\t\ttess.mesh.check();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction Tesselator() {\r\n\r\n\t\t/*** state needed for collecting the input data ***/\r\n\t\tthis.mesh = null;\t\t/* stores the input contours, and eventually\r\n\t\t\t\t\t\t\tthe tessellation itself */\r\n\r\n\t\t/*** state needed for projecting onto the sweep plane ***/\r\n\r\n\t\tthis.normal = [0.0, 0.0, 0.0];\t/* user-specified normal (if provided) */\r\n\t\tthis.sUnit = [0.0, 0.0, 0.0];\t/* unit vector in s-direction (debugging) */\r\n\t\tthis.tUnit = [0.0, 0.0, 0.0];\t/* unit vector in t-direction (debugging) */\r\n\r\n\t\tthis.bmin = [0.0, 0.0];\r\n\t\tthis.bmax = [0.0, 0.0];\r\n\r\n\t\t/*** state needed for the line sweep ***/\r\n\t\tthis.windingRule = Tess2.WINDING_ODD;\t/* rule for determining polygon interior */\r\n\r\n\t\tthis.dict = null;\t\t/* edge dictionary for sweep line */\r\n\t\tthis.pq = null;\t\t/* priority queue of vertex events */\r\n\t\tthis.event = null;\t\t/* current sweep event being processed */\r\n\r\n\t\tthis.vertexIndexCounter = 0;\r\n\t\t\r\n\t\tthis.vertices = [];\r\n\t\tthis.vertexIndices = [];\r\n\t\tthis.vertexCount = 0;\r\n\t\tthis.elements = [];\r\n\t\tthis.elementCount = 0;\r\n\t};\r\n\r\n\tTesselator.prototype = {\r\n\r\n\t\tdot_: function(u, v) {\r\n\t\t\treturn (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);\r\n\t\t},\r\n\r\n\t\tnormalize_: function( v ) {\r\n\t\t\tvar len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];\r\n\t\t\tassert( len > 0.0 );\r\n\t\t\tlen = Math.sqrt( len );\r\n\t\t\tv[0] /= len;\r\n\t\t\tv[1] /= len;\r\n\t\t\tv[2] /= len;\r\n\t\t},\r\n\r\n\t\tlongAxis_: function( v ) {\r\n\t\t\tvar i = 0;\r\n\t\t\tif( Math.abs(v[1]) > Math.abs(v[0]) ) { i = 1; }\r\n\t\t\tif( Math.abs(v[2]) > Math.abs(v[i]) ) { i = 2; }\r\n\t\t\treturn i;\r\n\t\t},\r\n\r\n\t\tcomputeNormal_: function( norm )\r\n\t\t{\r\n\t\t\tvar v, v1, v2;\r\n\t\t\tvar c, tLen2, maxLen2;\r\n\t\t\tvar maxVal = [0,0,0], minVal = [0,0,0], d1 = [0,0,0], d2 = [0,0,0], tNorm = [0,0,0];\r\n\t\t\tvar maxVert = [null,null,null], minVert = [null,null,null];\r\n\t\t\tvar vHead = this.mesh.vHead;\r\n\t\t\tvar i;\r\n\r\n\t\t\tv = vHead.next;\r\n\t\t\tfor( i = 0; i < 3; ++i ) {\r\n\t\t\t\tc = v.coords[i];\r\n\t\t\t\tminVal[i] = c;\r\n\t\t\t\tminVert[i] = v;\r\n\t\t\t\tmaxVal[i] = c;\r\n\t\t\t\tmaxVert[i] = v;\r\n\t\t\t}\r\n\r\n\t\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\t\tfor( i = 0; i < 3; ++i ) {\r\n\t\t\t\t\tc = v.coords[i];\r\n\t\t\t\t\tif( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }\r\n\t\t\t\t\tif( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Find two vertices separated by at least 1/sqrt(3) of the maximum\r\n\t\t\t* distance between any two vertices\r\n\t\t\t*/\r\n\t\t\ti = 0;\r\n\t\t\tif( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }\r\n\t\t\tif( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }\r\n\t\t\tif( minVal[i] >= maxVal[i] ) {\r\n\t\t\t\t/* All vertices are the same -- normal doesn't matter */\r\n\t\t\t\tnorm[0] = 0; norm[1] = 0; norm[2] = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t/* Look for a third vertex which forms the triangle with maximum area\r\n\t\t\t* (Length of normal == twice the triangle area)\r\n\t\t\t*/\r\n\t\t\tmaxLen2 = 0;\r\n\t\t\tv1 = minVert[i];\r\n\t\t\tv2 = maxVert[i];\r\n\t\t\td1[0] = v1.coords[0] - v2.coords[0];\r\n\t\t\td1[1] = v1.coords[1] - v2.coords[1];\r\n\t\t\td1[2] = v1.coords[2] - v2.coords[2];\r\n\t\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\t\td2[0] = v.coords[0] - v2.coords[0];\r\n\t\t\t\td2[1] = v.coords[1] - v2.coords[1];\r\n\t\t\t\td2[2] = v.coords[2] - v2.coords[2];\r\n\t\t\t\ttNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];\r\n\t\t\t\ttNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];\r\n\t\t\t\ttNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];\r\n\t\t\t\ttLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];\r\n\t\t\t\tif( tLen2 > maxLen2 ) {\r\n\t\t\t\t\tmaxLen2 = tLen2;\r\n\t\t\t\t\tnorm[0] = tNorm[0];\r\n\t\t\t\t\tnorm[1] = tNorm[1];\r\n\t\t\t\t\tnorm[2] = tNorm[2];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif( maxLen2 <= 0 ) {\r\n\t\t\t\t/* All points lie on a single line -- any decent normal will do */\r\n\t\t\t\tnorm[0] = norm[1] = norm[2] = 0;\r\n\t\t\t\tnorm[this.longAxis_(d1)] = 1;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tcheckOrientation_: function() {\r\n\t\t\tvar area;\r\n\t\t\tvar f, fHead = this.mesh.fHead;\r\n\t\t\tvar v, vHead = this.mesh.vHead;\r\n\t\t\tvar e;\r\n\r\n\t\t\t/* When we compute the normal automatically, we choose the orientation\r\n\t\t\t* so that the the sum of the signed areas of all contours is non-negative.\r\n\t\t\t*/\r\n\t\t\tarea = 0;\r\n\t\t\tfor( f = fHead.next; f !== fHead; f = f.next ) {\r\n\t\t\t\te = f.anEdge;\r\n\t\t\t\tif( e.winding <= 0 ) continue;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tarea += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);\r\n\t\t\t\t\te = e.Lnext;\r\n\t\t\t\t} while( e !== f.anEdge );\r\n\t\t\t}\r\n\t\t\tif( area < 0 ) {\r\n\t\t\t\t/* Reverse the orientation by flipping all the t-coordinates */\r\n\t\t\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\t\t\tv.t = - v.t;\r\n\t\t\t\t}\r\n\t\t\t\tthis.tUnit[0] = - this.tUnit[0];\r\n\t\t\t\tthis.tUnit[1] = - this.tUnit[1];\r\n\t\t\t\tthis.tUnit[2] = - this.tUnit[2];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t/*\t#ifdef FOR_TRITE_TEST_PROGRAM\r\n\t\t#include <stdlib.h>\r\n\t\textern int RandomSweep;\r\n\t\t#define S_UNIT_X\t(RandomSweep ? (2*drand48()-1) : 1.0)\r\n\t\t#define S_UNIT_Y\t(RandomSweep ? (2*drand48()-1) : 0.0)\r\n\t\t#else\r\n\t\t#if defined(SLANTED_SWEEP) */\r\n\t\t/* The \"feature merging\" is not intended to be complete.  There are\r\n\t\t* special cases where edges are nearly parallel to the sweep line\r\n\t\t* which are not implemented.  The algorithm should still behave\r\n\t\t* robustly (ie. produce a reasonable tesselation) in the presence\r\n\t\t* of such edges, however it may miss features which could have been\r\n\t\t* merged.  We could minimize this effect by choosing the sweep line\r\n\t\t* direction to be something unusual (ie. not parallel to one of the\r\n\t\t* coordinate axes).\r\n\t\t*/\r\n\t/*\t#define S_UNIT_X\t(TESSreal)0.50941539564955385\t// Pre-normalized\r\n\t\t#define S_UNIT_Y\t(TESSreal)0.86052074622010633\r\n\t\t#else\r\n\t\t#define S_UNIT_X\t(TESSreal)1.0\r\n\t\t#define S_UNIT_Y\t(TESSreal)0.0\r\n\t\t#endif\r\n\t\t#endif*/\r\n\r\n\t\t/* Determine the polygon normal and project vertices onto the plane\r\n\t\t* of the polygon.\r\n\t\t*/\r\n\t\tprojectPolygon_: function() {\r\n\t\t\tvar v, vHead = this.mesh.vHead;\r\n\t\t\tvar norm = [0,0,0];\r\n\t\t\tvar sUnit, tUnit;\r\n\t\t\tvar i, first, computedNormal = false;\r\n\r\n\t\t\tnorm[0] = this.normal[0];\r\n\t\t\tnorm[1] = this.normal[1];\r\n\t\t\tnorm[2] = this.normal[2];\r\n\t\t\tif( norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0 ) {\r\n\t\t\t\tthis.computeNormal_( norm );\r\n\t\t\t\tcomputedNormal = true;\r\n\t\t\t}\r\n\t\t\tsUnit = this.sUnit;\r\n\t\t\ttUnit = this.tUnit;\r\n\t\t\ti = this.longAxis_( norm );\r\n\r\n\t/*\t#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)\r\n\t\t\t// Choose the initial sUnit vector to be approximately perpendicular\r\n\t\t\t// to the normal.\r\n\t\t\t\r\n\t\t\tNormalize( norm );\r\n\r\n\t\t\tsUnit[i] = 0;\r\n\t\t\tsUnit[(i+1)%3] = S_UNIT_X;\r\n\t\t\tsUnit[(i+2)%3] = S_UNIT_Y;\r\n\r\n\t\t\t// Now make it exactly perpendicular \r\n\t\t\tw = Dot( sUnit, norm );\r\n\t\t\tsUnit[0] -= w * norm[0];\r\n\t\t\tsUnit[1] -= w * norm[1];\r\n\t\t\tsUnit[2] -= w * norm[2];\r\n\t\t\tNormalize( sUnit );\r\n\r\n\t\t\t// Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame \r\n\t\t\ttUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];\r\n\t\t\ttUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];\r\n\t\t\ttUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];\r\n\t\t\tNormalize( tUnit );\r\n\t\t#else*/\r\n\t\t\t/* Project perpendicular to a coordinate axis -- better numerically */\r\n\t\t\tsUnit[i] = 0;\r\n\t\t\tsUnit[(i+1)%3] = 1.0;\r\n\t\t\tsUnit[(i+2)%3] = 0.0;\r\n\r\n\t\t\ttUnit[i] = 0;\r\n\t\t\ttUnit[(i+1)%3] = 0.0;\r\n\t\t\ttUnit[(i+2)%3] = (norm[i] > 0) ? 1.0 : -1.0;\r\n\t//\t#endif\r\n\r\n\t\t\t/* Project the vertices onto the sweep plane */\r\n\t\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\t\tv.s = this.dot_( v.coords, sUnit );\r\n\t\t\t\tv.t = this.dot_( v.coords, tUnit );\r\n\t\t\t}\r\n\t\t\tif( computedNormal ) {\r\n\t\t\t\tthis.checkOrientation_();\r\n\t\t\t}\r\n\r\n\t\t\t/* Compute ST bounds. */\r\n\t\t\tfirst = true;\r\n\t\t\tfor( v = vHead.next; v !== vHead; v = v.next ) {\r\n\t\t\t\tif (first) {\r\n\t\t\t\t\tthis.bmin[0] = this.bmax[0] = v.s;\r\n\t\t\t\t\tthis.bmin[1] = this.bmax[1] = v.t;\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (v.s < this.bmin[0]) this.bmin[0] = v.s;\r\n\t\t\t\t\tif (v.s > this.bmax[0]) this.bmax[0] = v.s;\r\n\t\t\t\t\tif (v.t < this.bmin[1]) this.bmin[1] = v.t;\r\n\t\t\t\t\tif (v.t > this.bmax[1]) this.bmax[1] = v.t;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddWinding_: function(eDst,eSrc) {\r\n\t\t\teDst.winding += eSrc.winding;\r\n\t\t\teDst.Sym.winding += eSrc.Sym.winding;\r\n\t\t},\r\n\t\t\r\n\t\t/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region\r\n\t\t* (what else would it do??)  The region must consist of a single\r\n\t\t* loop of half-edges (see mesh.h) oriented CCW.  \"Monotone\" in this\r\n\t\t* case means that any vertical line intersects the interior of the\r\n\t\t* region in a single interval.  \r\n\t\t*\r\n\t\t* Tessellation consists of adding interior edges (actually pairs of\r\n\t\t* half-edges), to split the region into non-overlapping triangles.\r\n\t\t*\r\n\t\t* The basic idea is explained in Preparata and Shamos (which I don''t\r\n\t\t* have handy right now), although their implementation is more\r\n\t\t* complicated than this one.  The are two edge chains, an upper chain\r\n\t\t* and a lower chain.  We process all vertices from both chains in order,\r\n\t\t* from right to left.\r\n\t\t*\r\n\t\t* The algorithm ensures that the following invariant holds after each\r\n\t\t* vertex is processed: the untessellated region consists of two\r\n\t\t* chains, where one chain (say the upper) is a single edge, and\r\n\t\t* the other chain is concave.  The left vertex of the single edge\r\n\t\t* is always to the left of all vertices in the concave chain.\r\n\t\t*\r\n\t\t* Each step consists of adding the rightmost unprocessed vertex to one\r\n\t\t* of the two chains, and forming a fan of triangles from the rightmost\r\n\t\t* of two chain endpoints.  Determining whether we can add each triangle\r\n\t\t* to the fan is a simple orientation test.  By making the fan as large\r\n\t\t* as possible, we restore the invariant (check it yourself).\r\n\t\t*/\r\n\t//\tint tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )\r\n\t\ttessellateMonoRegion_: function( mesh, face ) {\r\n\t\t\tvar up, lo;\r\n\r\n\t\t\t/* All edges are oriented CCW around the boundary of the region.\r\n\t\t\t* First, find the half-edge whose origin vertex is rightmost.\r\n\t\t\t* Since the sweep goes from left to right, face->anEdge should\r\n\t\t\t* be close to the edge we want.\r\n\t\t\t*/\r\n\t\t\tup = face.anEdge;\r\n\t\t\tassert( up.Lnext !== up && up.Lnext.Lnext !== up );\r\n\r\n\t\t\tfor( ; Geom.vertLeq( up.Dst, up.Org ); up = up.Lprev )\r\n\t\t\t\t;\r\n\t\t\tfor( ; Geom.vertLeq( up.Org, up.Dst ); up = up.Lnext )\r\n\t\t\t\t;\r\n\t\t\tlo = up.Lprev;\r\n\r\n\t\t\twhile( up.Lnext !== lo ) {\r\n\t\t\t\tif( Geom.vertLeq( up.Dst, lo.Org )) {\r\n\t\t\t\t\t/* up->Dst is on the left.  It is safe to form triangles from lo->Org.\r\n\t\t\t\t\t* The EdgeGoesLeft test guarantees progress even when some triangles\r\n\t\t\t\t\t* are CW, given that the upper and lower chains are truly monotone.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\twhile( lo.Lnext !== up && (Geom.edgeGoesLeft( lo.Lnext )\r\n\t\t\t\t\t\t|| Geom.edgeSign( lo.Org, lo.Dst, lo.Lnext.Dst ) <= 0.0 )) {\r\n\t\t\t\t\t\t\tvar tempHalfEdge = mesh.connect( lo.Lnext, lo );\r\n\t\t\t\t\t\t\t//if (tempHalfEdge == NULL) return 0;\r\n\t\t\t\t\t\t\tlo = tempHalfEdge.Sym;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlo = lo.Lprev;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */\r\n\t\t\t\t\twhile( lo.Lnext !== up && (Geom.edgeGoesRight( up.Lprev )\r\n\t\t\t\t\t\t|| Geom.edgeSign( up.Dst, up.Org, up.Lprev.Org ) >= 0.0 )) {\r\n\t\t\t\t\t\t\tvar tempHalfEdge = mesh.connect( up, up.Lprev );\r\n\t\t\t\t\t\t\t//if (tempHalfEdge == NULL) return 0;\r\n\t\t\t\t\t\t\tup = tempHalfEdge.Sym;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tup = up.Lnext;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region\r\n\t\t\t* can be tessellated in a fan from this leftmost vertex.\r\n\t\t\t*/\r\n\t\t\tassert( lo.Lnext !== up );\r\n\t\t\twhile( lo.Lnext.Lnext !== up ) {\r\n\t\t\t\tvar tempHalfEdge = mesh.connect( lo.Lnext, lo );\r\n\t\t\t\t//if (tempHalfEdge == NULL) return 0;\r\n\t\t\t\tlo = tempHalfEdge.Sym;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\r\n\t\t/* tessMeshTessellateInterior( mesh ) tessellates each region of\r\n\t\t* the mesh which is marked \"inside\" the polygon.  Each such region\r\n\t\t* must be monotone.\r\n\t\t*/\r\n\t\t//int tessMeshTessellateInterior( TESSmesh *mesh )\r\n\t\ttessellateInterior_: function( mesh ) {\r\n\t\t\tvar f, next;\r\n\r\n\t\t\t/*LINTED*/\r\n\t\t\tfor( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {\r\n\t\t\t\t/* Make sure we don''t try to tessellate the new triangles. */\r\n\t\t\t\tnext = f.next;\r\n\t\t\t\tif( f.inside ) {\r\n\t\t\t\t\tif ( !this.tessellateMonoRegion_( mesh, f ) ) return false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t},\r\n\r\n\r\n\t\t/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces\r\n\t\t* which are not marked \"inside\" the polygon.  Since further mesh operations\r\n\t\t* on NULL faces are not allowed, the main purpose is to clean up the\r\n\t\t* mesh so that exterior loops are not represented in the data structure.\r\n\t\t*/\r\n\t\t//void tessMeshDiscardExterior( TESSmesh *mesh )\r\n\t\tdiscardExterior_: function( mesh ) {\r\n\t\t\tvar f, next;\r\n\r\n\t\t\t/*LINTED*/\r\n\t\t\tfor( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {\r\n\t\t\t\t/* Since f will be destroyed, save its next pointer. */\r\n\t\t\t\tnext = f.next;\r\n\t\t\t\tif( ! f.inside ) {\r\n\t\t\t\t\tmesh.zapFace( f );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the\r\n\t\t* winding numbers on all edges so that regions marked \"inside\" the\r\n\t\t* polygon have a winding number of \"value\", and regions outside\r\n\t\t* have a winding number of 0.\r\n\t\t*\r\n\t\t* If keepOnlyBoundary is TRUE, it also deletes all edges which do not\r\n\t\t* separate an interior region from an exterior one.\r\n\t\t*/\r\n\t//\tint tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )\r\n\t\tsetWindingNumber_: function( mesh, value, keepOnlyBoundary ) {\r\n\t\t\tvar e, eNext;\r\n\r\n\t\t\tfor( e = mesh.eHead.next; e !== mesh.eHead; e = eNext ) {\r\n\t\t\t\teNext = e.next;\r\n\t\t\t\tif( e.Rface.inside !== e.Lface.inside ) {\r\n\r\n\t\t\t\t\t/* This is a boundary edge (one side is interior, one is exterior). */\r\n\t\t\t\t\te.winding = (e.Lface.inside) ? value : -value;\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t/* Both regions are interior, or both are exterior. */\r\n\t\t\t\t\tif( ! keepOnlyBoundary ) {\r\n\t\t\t\t\t\te.winding = 0;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tmesh.delete( e );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tgetNeighbourFace_: function(edge)\r\n\t\t{\r\n\t\t\tif (!edge.Rface)\r\n\t\t\t\treturn -1;\r\n\t\t\tif (!edge.Rface.inside)\r\n\t\t\t\treturn -1;\r\n\t\t\treturn edge.Rface.n;\r\n\t\t},\r\n\r\n\t\toutputPolymesh_: function( mesh, elementType, polySize, vertexSize ) {\r\n\t\t\tvar v;\r\n\t\t\tvar f;\r\n\t\t\tvar edge;\r\n\t\t\tvar maxFaceCount = 0;\r\n\t\t\tvar maxVertexCount = 0;\r\n\t\t\tvar faceVerts, i;\r\n\t\t\tvar elements = 0;\r\n\t\t\tvar vert;\r\n\r\n\t\t\t// Assume that the input data is triangles now.\r\n\t\t\t// Try to merge as many polygons as possible\r\n\t\t\tif (polySize > 3)\r\n\t\t\t{\r\n\t\t\t\tmesh.mergeConvexFaces( polySize );\r\n\t\t\t}\r\n\r\n\t\t\t// Mark unused\r\n\t\t\tfor ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )\r\n\t\t\t\tv.n = -1;\r\n\r\n\t\t\t// Create unique IDs for all vertices and faces.\r\n\t\t\tfor ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n\t\t\t{\r\n\t\t\t\tf.n = -1;\r\n\t\t\t\tif( !f.inside ) continue;\r\n\r\n\t\t\t\tedge = f.anEdge;\r\n\t\t\t\tfaceVerts = 0;\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\tv = edge.Org;\r\n\t\t\t\t\tif ( v.n === -1 )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tv.n = maxVertexCount;\r\n\t\t\t\t\t\tmaxVertexCount++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfaceVerts++;\r\n\t\t\t\t\tedge = edge.Lnext;\r\n\t\t\t\t}\r\n\t\t\t\twhile (edge !== f.anEdge);\r\n\t\t\t\t\r\n\t\t\t\tassert( faceVerts <= polySize );\r\n\r\n\t\t\t\tf.n = maxFaceCount;\r\n\t\t\t\t++maxFaceCount;\r\n\t\t\t}\r\n\r\n\t\t\tthis.elementCount = maxFaceCount;\r\n\t\t\tif (elementType === Tess2.CONNECTED_POLYGONS)\r\n\t\t\t\tmaxFaceCount *= 2;\r\n\t/*\t\ttess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(TESSindex) * maxFaceCount * polySize );\r\n\t\t\tif (!tess->elements)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\t\tthis.elements = [];\r\n\t\t\tthis.elements.length = maxFaceCount * polySize;\r\n\t\t\t\r\n\t\t\tthis.vertexCount = maxVertexCount;\r\n\t/*\t\ttess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sizeof(TESSreal) * tess->vertexCount * vertexSize );\r\n\t\t\tif (!tess->vertices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.vertices.length = maxVertexCount * vertexSize;\r\n\r\n\t/*\t\ttess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TESSindex) * tess->vertexCount );\r\n\t\t\tif (!tess->vertexIndices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\t\tthis.vertexIndices = [];\r\n\t\t\tthis.vertexIndices.length = maxVertexCount;\r\n\r\n\t\t\t\r\n\t\t\t// Output vertices.\r\n\t\t\tfor ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )\r\n\t\t\t{\r\n\t\t\t\tif ( v.n !== -1 )\r\n\t\t\t\t{\r\n\t\t\t\t\t// Store coordinate\r\n\t\t\t\t\tvar idx = v.n * vertexSize;\r\n\t\t\t\t\tthis.vertices[idx+0] = v.coords[0];\r\n\t\t\t\t\tthis.vertices[idx+1] = v.coords[1];\r\n\t\t\t\t\tif ( vertexSize > 2 )\r\n\t\t\t\t\t\tthis.vertices[idx+2] = v.coords[2];\r\n\t\t\t\t\t// Store vertex index.\r\n\t\t\t\t\tthis.vertexIndices[v.n] = v.idx;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Output indices.\r\n\t\t\tvar nel = 0;\r\n\t\t\tfor ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n\t\t\t{\r\n\t\t\t\tif ( !f.inside ) continue;\r\n\t\t\t\t\r\n\t\t\t\t// Store polygon\r\n\t\t\t\tedge = f.anEdge;\r\n\t\t\t\tfaceVerts = 0;\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\tv = edge.Org;\r\n\t\t\t\t\tthis.elements[nel++] = v.n;\r\n\t\t\t\t\tfaceVerts++;\r\n\t\t\t\t\tedge = edge.Lnext;\r\n\t\t\t\t}\r\n\t\t\t\twhile (edge !== f.anEdge);\r\n\t\t\t\t// Fill unused.\r\n\t\t\t\tfor (i = faceVerts; i < polySize; ++i)\r\n\t\t\t\t\tthis.elements[nel++] = -1;\r\n\r\n\t\t\t\t// Store polygon connectivity\r\n\t\t\t\tif ( elementType === Tess2.CONNECTED_POLYGONS )\r\n\t\t\t\t{\r\n\t\t\t\t\tedge = f.anEdge;\r\n\t\t\t\t\tdo\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.elements[nel++] = this.getNeighbourFace_( edge );\r\n\t\t\t\t\t\tedge = edge.Lnext;\r\n\t\t\t\t\t}\r\n\t\t\t\t\twhile (edge !== f.anEdge);\r\n\t\t\t\t\t// Fill unused.\r\n\t\t\t\t\tfor (i = faceVerts; i < polySize; ++i)\r\n\t\t\t\t\t\tthis.elements[nel++] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t//\tvoid OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )\r\n\t\toutputContours_: function( mesh, vertexSize ) {\r\n\t\t\tvar f;\r\n\t\t\tvar edge;\r\n\t\t\tvar start;\r\n\t\t\tvar verts;\r\n\t\t\tvar elements;\r\n\t\t\tvar vertInds;\r\n\t\t\tvar startVert = 0;\r\n\t\t\tvar vertCount = 0;\r\n\r\n\t\t\tthis.vertexCount = 0;\r\n\t\t\tthis.elementCount = 0;\r\n\r\n\t\t\tfor ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n\t\t\t{\r\n\t\t\t\tif ( !f.inside ) continue;\r\n\r\n\t\t\t\tstart = edge = f.anEdge;\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.vertexCount++;\r\n\t\t\t\t\tedge = edge.Lnext;\r\n\t\t\t\t}\r\n\t\t\t\twhile ( edge !== start );\r\n\r\n\t\t\t\tthis.elementCount++;\r\n\t\t\t}\r\n\r\n\t/*\t\ttess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(TESSindex) * tess->elementCount * 2 );\r\n\t\t\tif (!tess->elements)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\t\tthis.elements = [];\r\n\t\t\tthis.elements.length = this.elementCount * 2;\r\n\t\t\t\r\n\t/*\t\ttess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(TESSreal) * tess->vertexCount * vertexSize );\r\n\t\t\tif (!tess->vertices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.vertices.length = this.vertexCount * vertexSize;\r\n\r\n\t/*\t\ttess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TESSindex) * tess->vertexCount );\r\n\t\t\tif (!tess->vertexIndices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\t\tthis.vertexIndices = [];\r\n\t\t\tthis.vertexIndices.length = this.vertexCount;\r\n\r\n\t\t\tvar nv = 0;\r\n\t\t\tvar nvi = 0;\r\n\t\t\tvar nel = 0;\r\n\t\t\tstartVert = 0;\r\n\r\n\t\t\tfor ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )\r\n\t\t\t{\r\n\t\t\t\tif ( !f.inside ) continue;\r\n\r\n\t\t\t\tvertCount = 0;\r\n\t\t\t\tstart = edge = f.anEdge;\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.vertices[nv++] = edge.Org.coords[0];\r\n\t\t\t\t\tthis.vertices[nv++] = edge.Org.coords[1];\r\n\t\t\t\t\tif ( vertexSize > 2 )\r\n\t\t\t\t\t\tthis.vertices[nv++] = edge.Org.coords[2];\r\n\t\t\t\t\tthis.vertexIndices[nvi++] = edge.Org.idx;\r\n\t\t\t\t\tvertCount++;\r\n\t\t\t\t\tedge = edge.Lnext;\r\n\t\t\t\t}\r\n\t\t\t\twhile ( edge !== start );\r\n\r\n\t\t\t\tthis.elements[nel++] = startVert;\r\n\t\t\t\tthis.elements[nel++] = vertCount;\r\n\r\n\t\t\t\tstartVert += vertCount;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\taddContour: function( size, vertices )\r\n\t\t{\r\n\t\t\tvar e;\r\n\t\t\tvar i;\r\n\r\n\t\t\tif ( this.mesh === null )\r\n\t\t\t  \tthis.mesh = new TESSmesh();\r\n\t/*\t \tif ( tess->mesh == NULL ) {\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\r\n\t\t\tif ( size < 2 )\r\n\t\t\t\tsize = 2;\r\n\t\t\tif ( size > 3 )\r\n\t\t\t\tsize = 3;\r\n\r\n\t\t\te = null;\r\n\r\n\t\t\tfor( i = 0; i < vertices.length; i += size )\r\n\t\t\t{\r\n\t\t\t\tif( e === null ) {\r\n\t\t\t\t\t/* Make a self-loop (one vertex, one edge). */\r\n\t\t\t\t\te = this.mesh.makeEdge();\r\n\t/*\t\t\t\tif ( e == NULL ) {\r\n\t\t\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\tthis.mesh.splice( e, e.Sym );\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* Create a new vertex and edge which immediately follow e\r\n\t\t\t\t\t* in the ordering around the left face.\r\n\t\t\t\t\t*/\r\n\t\t\t\t\tthis.mesh.splitEdge( e );\r\n\t\t\t\t\te = e.Lnext;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* The new vertex is now e->Org. */\r\n\t\t\t\te.Org.coords[0] = vertices[i+0];\r\n\t\t\t\te.Org.coords[1] = vertices[i+1];\r\n\t\t\t\tif ( size > 2 )\r\n\t\t\t\t\te.Org.coords[2] = vertices[i+2];\r\n\t\t\t\telse\r\n\t\t\t\t\te.Org.coords[2] = 0.0;\r\n\t\t\t\t/* Store the insertion number so that the vertex can be later recognized. */\r\n\t\t\t\te.Org.idx = this.vertexIndexCounter++;\r\n\r\n\t\t\t\t/* The winding of an edge says how the winding number changes as we\r\n\t\t\t\t* cross from the edge''s right face to its left face.  We add the\r\n\t\t\t\t* vertices in such an order that a CCW contour will add +1 to\r\n\t\t\t\t* the winding number of the region inside the contour.\r\n\t\t\t\t*/\r\n\t\t\t\te.winding = 1;\r\n\t\t\t\te.Sym.winding = -1;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t//\tint tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )\r\n\t\ttesselate: function( windingRule, elementType, polySize, vertexSize, normal ) {\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.elements = [];\r\n\t\t\tthis.vertexIndices = [];\r\n\r\n\t\t\tthis.vertexIndexCounter = 0;\r\n\t\t\t\r\n\t\t\tif (normal)\r\n\t\t\t{\r\n\t\t\t\tthis.normal[0] = normal[0];\r\n\t\t\t\tthis.normal[1] = normal[1];\r\n\t\t\t\tthis.normal[2] = normal[2];\r\n\t\t\t}\r\n\r\n\t\t\tthis.windingRule = windingRule;\r\n\r\n\t\t\tif (vertexSize < 2)\r\n\t\t\t\tvertexSize = 2;\r\n\t\t\tif (vertexSize > 3)\r\n\t\t\t\tvertexSize = 3;\r\n\r\n\t/*\t\tif (setjmp(tess->env) != 0) { \r\n\t\t\t\t// come back here if out of memory\r\n\t\t\t\treturn 0;\r\n\t\t\t}*/\r\n\r\n\t\t\tif (!this.mesh)\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t/* Determine the polygon normal and project vertices onto the plane\r\n\t\t\t* of the polygon.\r\n\t\t\t*/\r\n\t\t\tthis.projectPolygon_();\r\n\r\n\t\t\t/* tessComputeInterior( tess ) computes the planar arrangement specified\r\n\t\t\t* by the given contours, and further subdivides this arrangement\r\n\t\t\t* into regions.  Each region is marked \"inside\" if it belongs\r\n\t\t\t* to the polygon, according to the rule given by tess->windingRule.\r\n\t\t\t* Each interior region is guaranteed be monotone.\r\n\t\t\t*/\r\n\t\t\tSweep.computeInterior( this );\r\n\r\n\t\t\tvar mesh = this.mesh;\r\n\r\n\t\t\t/* If the user wants only the boundary contours, we throw away all edges\r\n\t\t\t* except those which separate the interior from the exterior.\r\n\t\t\t* Otherwise we tessellate all the regions marked \"inside\".\r\n\t\t\t*/\r\n\t\t\tif (elementType === Tess2.BOUNDARY_CONTOURS) {\r\n\t\t\t\tthis.setWindingNumber_( mesh, 1, true );\r\n\t\t\t} else {\r\n\t\t\t\tthis.tessellateInterior_( mesh ); \r\n\t\t\t}\r\n\t//\t\tif (rc == 0) longjmp(tess->env,1);  /* could've used a label */\r\n\r\n\t\t\tmesh.check();\r\n\r\n\t\t\tif (elementType === Tess2.BOUNDARY_CONTOURS) {\r\n\t\t\t\tthis.outputContours_( mesh, vertexSize );     /* output contours */\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tthis.outputPolymesh_( mesh, elementType, polySize, vertexSize );     /* output polygons */\r\n\t\t\t}\r\n\r\n//\t\t\ttess.mesh = null;\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n"],"names":[],"mappings":"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"}
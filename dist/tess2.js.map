{"version":3,"file":"tess2.js","sources":["../src/utils/constants.ts","../src/utils/assert.ts","../src/utils/Geom.ts","../src/mesh/TESSface.ts","../src/mesh/TESShalfEdge.ts","../src/mesh/TESSvertex.ts","../src/mesh/TESSmesh.ts","../src/utils/PriorityQ.ts","../src/mesh/ActiveRegion.ts","../src/utils/Dict.ts","../src/utils/Sweep.ts","../src/Tesselator.ts","../src/index.ts"],"sourcesContent":["export enum WINDING{\r\n\tODD = 0,\r\n\tNONZERO = 1,\r\n\tPOSITIVE = 2,\r\n\tNEGATIVE = 3,\r\n\tABS_GEQ_TWO = 4,\r\n};\r\n\r\nexport enum ELEMENT {\r\n\tPOLYGONS = 0,\r\n\tCONNECTED_POLYGONS = 1,\r\n\tBOUNDARY_CONTOURS = 2,\r\n};\r\n","export function assert (cond: any, message: string = undefined) {\r\n\tif (!cond) {\r\n\t\tthrow message || \"Assertion Failed!\";\r\n\t}\r\n};","import {assert} from \"./../utils/assert\";\r\nimport { TESSvertex, TESShalfEdge } from \"../mesh/index\";\r\n\r\nexport class Geom {\r\n\r\n\tstatic vertEq (u: TESSvertex, v: TESSvertex) {\r\n\t\treturn u.s === v.s && u.t === v.t;\r\n\t}\r\n\r\n\t/* Returns TRUE if u is lexicographically <= v. */\r\n\tstatic vertLeq(u: TESSvertex, v: TESSvertex) {\r\n\t\treturn u.s < v.s || (u.s === v.s && u.t <= v.t);\r\n\t}\r\n\r\n\t/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */\r\n\tstatic transLeq(u: TESSvertex, v: TESSvertex) {\r\n\t\treturn u.t < v.t || (u.t === v.t && u.s <= v.s);\r\n\t}\r\n\r\n\tstatic edgeGoesLeft(e: TESShalfEdge) {\r\n\t\treturn Geom.vertLeq(e.Dst, e.Org);\r\n\t}\r\n\r\n\tstatic edgeGoesRight(e: TESShalfEdge) {\r\n\t\treturn Geom.vertLeq(e.Org, e.Dst);\r\n\t}\r\n\r\n\tstatic vertL1dist(u: TESSvertex, v: TESSvertex) {\r\n\t\treturn Math.abs(u.s - v.s) + Math.abs(u.t - v.t);\r\n\t}\r\n\r\n\t//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tstatic edgeEval(u: TESSvertex, v: TESSvertex, w: TESSvertex) {\r\n\t\t/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),\r\n\t\t * evaluates the t-coord of the edge uw at the s-coord of the vertex v.\r\n\t\t * Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.\r\n\t\t * If uw is vertical (and thus passes thru v), the result is zero.\r\n\t\t *\r\n\t\t * The calculation is extremely accurate and stable, even when v\r\n\t\t * is very close to u or w.  In particular if we set v->t = 0 and\r\n\t\t * let r be the negated result (this evaluates (uw)(v->s)), then\r\n\t\t * r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).\r\n\t\t */\r\n\t\tassert(Geom.vertLeq(u, v) && Geom.vertLeq(v, w));\r\n\r\n\t\tvar gapL = v.s - u.s;\r\n\t\tvar gapR = w.s - v.s;\r\n\r\n\t\tif (gapL + gapR > 0.0) {\r\n\t\t\tif (gapL < gapR) {\r\n\t\t\t\treturn v.t - u.t + (u.t - w.t) * (gapL / (gapL + gapR));\r\n\t\t\t} else {\r\n\t\t\t\treturn v.t - w.t + (w.t - u.t) * (gapR / (gapL + gapR));\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t}\r\n\r\n\t//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tstatic edgeSign(u: TESSvertex, v: TESSvertex, w: TESSvertex) {\r\n\t\t/* Returns a number whose sign matches EdgeEval(u,v,w) but which\r\n\t\t * is cheaper to evaluate.  Returns > 0, == 0 , or < 0\r\n\t\t * as v is above, on, or below the edge uw.\r\n\t\t */\r\n\t\tassert(Geom.vertLeq(u, v) && Geom.vertLeq(v, w));\r\n\r\n\t\tvar gapL = v.s - u.s;\r\n\t\tvar gapR = w.s - v.s;\r\n\r\n\t\tif (gapL + gapR > 0.0) {\r\n\t\t\treturn (v.t - w.t) * gapL + (v.t - u.t) * gapR;\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t}\r\n\r\n\t/***********************************************************************\r\n\t * Define versions of EdgeSign, EdgeEval with s and t transposed.\r\n\t */\r\n\r\n\t//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tstatic transEval(u: TESSvertex, v: TESSvertex, w: TESSvertex) {\r\n\t\t/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),\r\n\t\t * evaluates the t-coord of the edge uw at the s-coord of the vertex v.\r\n\t\t * Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.\r\n\t\t * If uw is vertical (and thus passes thru v), the result is zero.\r\n\t\t *\r\n\t\t * The calculation is extremely accurate and stable, even when v\r\n\t\t * is very close to u or w.  In particular if we set v->s = 0 and\r\n\t\t * let r be the negated result (this evaluates (uw)(v->t)), then\r\n\t\t * r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).\r\n\t\t */\r\n\t\tassert(Geom.transLeq(u, v) && Geom.transLeq(v, w));\r\n\r\n\t\tvar gapL = v.t - u.t;\r\n\t\tvar gapR = w.t - v.t;\r\n\r\n\t\tif (gapL + gapR > 0.0) {\r\n\t\t\tif (gapL < gapR) {\r\n\t\t\t\treturn v.s - u.s + (u.s - w.s) * (gapL / (gapL + gapR));\r\n\t\t\t} else {\r\n\t\t\t\treturn v.s - w.s + (w.s - u.s) * (gapR / (gapL + gapR));\r\n\t\t\t}\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t}\r\n\r\n\t//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tstatic transSign(u: TESSvertex, v: TESSvertex, w: TESSvertex) {\r\n\t\t/* Returns a number whose sign matches TransEval(u,v,w) but which\r\n\t\t * is cheaper to evaluate.  Returns > 0, == 0 , or < 0\r\n\t\t * as v is above, on, or below the edge uw.\r\n\t\t */\r\n\t\tassert(Geom.transLeq(u, v) && Geom.transLeq(v, w));\r\n\r\n\t\tvar gapL = v.t - u.t;\r\n\t\tvar gapR = w.t - v.t;\r\n\r\n\t\tif (gapL + gapR > 0.0) {\r\n\t\t\treturn (v.s - w.s) * gapL + (v.s - u.s) * gapR;\r\n\t\t}\r\n\t\t/* vertical line */\r\n\t\treturn 0.0;\r\n\t}\r\n\r\n\t//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )\r\n\tstatic vertCCW(u: TESSvertex, v: TESSvertex, w: TESSvertex) {\r\n\t\t/* For almost-degenerate situations, the results are not reliable.\r\n\t\t * Unless the floating-point arithmetic can be performed without\r\n\t\t * rounding errors, *any* implementation will give incorrect results\r\n\t\t * on some degenerate inputs, so the client must have some way to\r\n\t\t * handle this situation.\r\n\t\t */\r\n\t\treturn u.s * (v.t - w.t) + v.s * (w.t - u.t) + w.s * (u.t - v.t) >= 0.0;\r\n\t}\r\n\r\n\t/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),\r\n\t * or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces\r\n\t * this in the rare case that one argument is slightly negative.\r\n\t * The implementation is extremely stable numerically.\r\n\t * In particular it guarantees that the result r satisfies\r\n\t * MIN(x,y) <= r <= MAX(x,y), and the results are very accurate\r\n\t * even when a and b differ greatly in magnitude.\r\n\t */\r\n\tstatic interpolate(a: number, x:number, b:number, y:number) {\r\n\t\treturn (\r\n\t\t\t(a = a < 0 ? 0 : a),\r\n\t\t\t(b = b < 0 ? 0 : b),\r\n\t\t\ta <= b\r\n\t\t\t\t? b === 0\r\n\t\t\t\t\t? (x + y) / 2\r\n\t\t\t\t\t: x + (y - x) * (a / (a + b))\r\n\t\t\t\t: y + (x - y) * (b / (a + b))\r\n\t\t);\r\n\t}\r\n\r\n\t/*\r\n\t#ifndef FOR_TRITE_TEST_PROGRAM\r\n\t#define Interpolate(a,x,b,y)\tRealInterpolate(a,x,b,y)\r\n\t#else\r\n\r\n\t// Claim: the ONLY property the sweep algorithm relies on is that\r\n\t// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.\r\n\t#include <stdlib.h>\r\n\textern int RandomInterpolate;\r\n\r\n\tdouble Interpolate( double a, double x, double b, double y)\r\n\t{\r\n\t\tprintf(\"*********************%d\\n\",RandomInterpolate);\r\n\t\tif( RandomInterpolate ) {\r\n\t\t\ta = 1.2 * drand48() - 0.1;\r\n\t\t\ta = (a < 0) ? 0 : ((a > 1) ? 1 : a);\r\n\t\t\tb = 1.0 - a;\r\n\t\t}\r\n\t\treturn RealInterpolate(a,x,b,y);\r\n\t}\r\n\t#endif*/\r\n\r\n\tstatic intersect(o1: TESSvertex, d1: TESSvertex, o2: TESSvertex, d2:TESSvertex, v: TESSvertex) {\r\n\t\t/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.\r\n\t\t * The computed point is guaranteed to lie in the intersection of the\r\n\t\t * bounding rectangles defined by each edge.\r\n\t\t */\r\n\t\tvar z1, z2;\r\n\t\tvar t;\r\n\r\n\t\t/* This is certainly not the most efficient way to find the intersection\r\n\t\t * of two line segments, but it is very numerically stable.\r\n\t\t *\r\n\t\t * Strategy: find the two middle vertices in the VertLeq ordering,\r\n\t\t * and interpolate the intersection s-value from these.  Then repeat\r\n\t\t * using the TransLeq ordering to find the intersection t-value.\r\n\t\t */\r\n\r\n\t\tif (!Geom.vertLeq(o1, d1)) {\r\n\t\t\tt = o1;\r\n\t\t\to1 = d1;\r\n\t\t\td1 = t;\r\n\t\t} //swap( o1, d1 ); }\r\n\t\tif (!Geom.vertLeq(o2, d2)) {\r\n\t\t\tt = o2;\r\n\t\t\to2 = d2;\r\n\t\t\td2 = t;\r\n\t\t} //swap( o2, d2 ); }\r\n\t\tif (!Geom.vertLeq(o1, o2)) {\r\n\t\t\tt = o1;\r\n\t\t\to1 = o2;\r\n\t\t\to2 = t;\r\n\t\t\tt = d1;\r\n\t\t\td1 = d2;\r\n\t\t\td2 = t;\r\n\t\t} //swap( o1, o2 ); swap( d1, d2 ); }\r\n\r\n\t\tif (!Geom.vertLeq(o2, d1)) {\r\n\t\t\t/* Technically, no intersection -- do our best */\r\n\t\t\tv.s = (o2.s + d1.s) / 2;\r\n\t\t} else if (Geom.vertLeq(d1, d2)) {\r\n\t\t\t/* Interpolate between o2 and d1 */\r\n\t\t\tz1 = Geom.edgeEval(o1, o2, d1);\r\n\t\t\tz2 = Geom.edgeEval(o2, d1, d2);\r\n\t\t\tif (z1 + z2 < 0) {\r\n\t\t\t\tz1 = -z1;\r\n\t\t\t\tz2 = -z2;\r\n\t\t\t}\r\n\t\t\tv.s = Geom.interpolate(z1, o2.s, z2, d1.s);\r\n\t\t} else {\r\n\t\t\t/* Interpolate between o2 and d2 */\r\n\t\t\tz1 = Geom.edgeSign(o1, o2, d1);\r\n\t\t\tz2 = -Geom.edgeSign(o1, d2, d1);\r\n\t\t\tif (z1 + z2 < 0) {\r\n\t\t\t\tz1 = -z1;\r\n\t\t\t\tz2 = -z2;\r\n\t\t\t}\r\n\t\t\tv.s = Geom.interpolate(z1, o2.s, z2, d2.s);\r\n\t\t}\r\n\r\n\t\t/* Now repeat the process for t */\r\n\r\n\t\tif (!Geom.transLeq(o1, d1)) {\r\n\t\t\tt = o1;\r\n\t\t\to1 = d1;\r\n\t\t\td1 = t;\r\n\t\t} //swap( o1, d1 ); }\r\n\t\tif (!Geom.transLeq(o2, d2)) {\r\n\t\t\tt = o2;\r\n\t\t\to2 = d2;\r\n\t\t\td2 = t;\r\n\t\t} //swap( o2, d2 ); }\r\n\t\tif (!Geom.transLeq(o1, o2)) {\r\n\t\t\tt = o1;\r\n\t\t\to1 = o2;\r\n\t\t\to2 = t;\r\n\t\t\tt = d1;\r\n\t\t\td1 = d2;\r\n\t\t\td2 = t;\r\n\t\t} //swap( o1, o2 ); swap( d1, d2 ); }\r\n\r\n\t\tif (!Geom.transLeq(o2, d1)) {\r\n\t\t\t/* Technically, no intersection -- do our best */\r\n\t\t\tv.t = (o2.t + d1.t) / 2;\r\n\t\t} else if (Geom.transLeq(d1, d2)) {\r\n\t\t\t/* Interpolate between o2 and d1 */\r\n\t\t\tz1 = Geom.transEval(o1, o2, d1);\r\n\t\t\tz2 = Geom.transEval(o2, d1, d2);\r\n\t\t\tif (z1 + z2 < 0) {\r\n\t\t\t\tz1 = -z1;\r\n\t\t\t\tz2 = -z2;\r\n\t\t\t}\r\n\t\t\tv.t = Geom.interpolate(z1, o2.t, z2, d1.t);\r\n\t\t} else {\r\n\t\t\t/* Interpolate between o2 and d2 */\r\n\t\t\tz1 = Geom.transSign(o1, o2, d1);\r\n\t\t\tz2 = -Geom.transSign(o1, d2, d1);\r\n\t\t\tif (z1 + z2 < 0) {\r\n\t\t\t\tz1 = -z1;\r\n\t\t\t\tz2 = -z2;\r\n\t\t\t}\r\n\t\t\tv.t = Geom.interpolate(z1, o2.t, z2, d2.t);\r\n\t\t}\r\n\t}\r\n}\r\n","import { TESShalfEdge } from './TESShalfEdge';\r\nexport class TESSface {\r\n\tnext: TESSface = null; /* next face (never NULL) */\r\n\tprev: TESSface = null; /* previous face (never NULL) */\r\n\tanEdge: TESShalfEdge = null; /* a half edge with this left face */\r\n\r\n\t/* Internal data (keep hidden) */\r\n\ttrail: any = null; /* \"stack\" for conversion to strips */\r\n\tn: number = 0; /* to allow identiy unique faces */\r\n\tmarked: boolean = false; /* flag for conversion to strips */\r\n\tinside: boolean = false; /* this face is in the polygon interior */\r\n}","import { ActiveRegion } from './ActiveRegion';\r\nimport { TESSface } from './TESSface';\r\ntype TESSVertex = any;\r\n\r\nexport class TESShalfEdge {\r\n\r\n\tnext: TESShalfEdge = null; /* doubly-linked list (prev==Sym->next) */\r\n\tOrg: TESSVertex= null; /* origin vertex (Overtex too long) */\r\n\tSym: TESShalfEdge = null; /* same edge, opposite direction */\r\n\tOnext: TESShalfEdge= null; /* next edge CCW around origin */\r\n\tLnext: TESShalfEdge = null; /* next edge CCW around left face */\r\n\tLface: TESSface = null; /* left face */\r\n\r\n\t/* Internal data (keep hidden) */\r\n\tactiveRegion: ActiveRegion = null; /* a region with this upper edge (sweep.c) */\r\n\twinding: number = 0; /* change in winding number when crossing from the right face to the left face */\r\n\r\n\tconstructor(public side: number) { };\r\n\r\n\tget Rface() {\r\n\t\treturn this.Sym!.Lface;\r\n\t}\r\n\r\n\tset Rface(v: TESSface) {\r\n\t\tthis.Sym!.Lface = v;\r\n\t}\r\n\r\n\tget Dst() {\r\n\t\treturn this.Sym!.Org;\r\n\t}\r\n\r\n\tset Dst(v) {\r\n\t\tthis.Sym!.Org = v;\r\n\t}\r\n\r\n\tget Oprev() {\r\n\t\treturn this.Sym!.Lnext;\r\n\t}\r\n\r\n\tset Oprev(v: TESShalfEdge) {\r\n\t\tthis.Sym!.Lnext = v;\r\n\t}\r\n\r\n\tget Lprev() {\r\n\t\treturn this.Onext!.Sym;\r\n\t}\r\n\tset Lprev(v) {\r\n\t\tthis.Onext!.Sym = v;\r\n\t}\r\n\r\n\tget Dprev() {\r\n\t\treturn this.Lnext!.Sym;\r\n\t}\r\n\r\n\tset Dprev(v) {\r\n\t\tthis.Lnext!.Sym = v;\r\n\t}\r\n\tget Rprev() {\r\n\t\treturn this.Sym!.Onext;\r\n\t}\r\n\tset Rprev(v) {\r\n\t\tthis.Sym!.Onext = v;\r\n\t}\r\n\tget Dnext() {\r\n\t\treturn this.Sym!.Onext!.Sym;\r\n\t}\r\n\tset Dnext(v) {\r\n\t\tthis.Sym!.Onext!.Sym = v;\r\n\t}\r\n\tget Rnext() {\r\n\t\treturn this.Sym!.Lnext!.Sym;\r\n\t}\r\n\tset Rnext(v) {\r\n\t\tthis.Sym!.Lnext!.Sym = v;\r\n\t}\r\n};","import { V3 } from '../type';\r\nimport { TESShalfEdge } from './TESShalfEdge';\r\n\r\nexport class TESSvertex {\r\n\tnext: TESSvertex = null; /* next vertex (never NULL) */\r\n\tprev: TESSvertex = null; /* previous vertex (never NULL) */\r\n\tanEdge: TESShalfEdge = null; /* a half-edge with this origin */\r\n\r\n\t/* Internal data (keep hidden) */\r\n\tcoords: V3 = [0, 0, 0]; /* vertex location in 3D */\r\n\ts: number = 0.0;\r\n\tt: number = 0.0; /* projection onto the sweep plane */\r\n\tpqHandle: number = 0; /* to allow deletion from priority queue */\r\n\tn: number = 0; /* to allow identify unique vertices */\r\n\tidx: number = 0; /* to allow map result to original verts */\r\n}","import { Geom } from \"../utils/Geom\";\r\nimport { assert } from \"../utils/assert\";\r\nimport { TESSface } from \"./TESSface\";\r\nimport { TESShalfEdge } from \"./TESShalfEdge\";\r\nimport { TESSvertex } from \"./TESSvertex\";\r\n\r\n\r\n/* The mesh operations below have three motivations: completeness,\r\n * convenience, and efficiency.  The basic mesh operations are MakeEdge,\r\n * Splice, and Delete.  All the other edge operations can be implemented\r\n * in terms of these.  The other operations are provided for convenience\r\n * and/or efficiency.\r\n *\r\n * When a face is split or a vertex is added, they are inserted into the\r\n * global list *before* the existing vertex or face (ie. e->Org or e->Lface).\r\n * This makes it easier to process all vertices or faces in the global lists\r\n * without worrying about processing the same data twice.  As a convenience,\r\n * when a face is split, the \"inside\" flag is copied from the old face.\r\n * Other internal data (v->data, v->activeRegion, f->data, f->marked,\r\n * f->trail, e->winding) is set to zero.\r\n *\r\n * ********************** Basic Edge Operations **************************\r\n *\r\n * tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.\r\n * The loop (face) consists of the two new half-edges.\r\n *\r\n * tessMeshSplice( eOrg, eDst ) is the basic operation for changing the\r\n * mesh connectivity and topology.  It changes the mesh so that\r\n *  eOrg->Onext <- OLD( eDst->Onext )\r\n *  eDst->Onext <- OLD( eOrg->Onext )\r\n * where OLD(...) means the value before the meshSplice operation.\r\n *\r\n * This can have two effects on the vertex structure:\r\n *  - if eOrg->Org != eDst->Org, the two vertices are merged together\r\n *  - if eOrg->Org == eDst->Org, the origin is split into two vertices\r\n * In both cases, eDst->Org is changed and eOrg->Org is untouched.\r\n *\r\n * Similarly (and independently) for the face structure,\r\n *  - if eOrg->Lface == eDst->Lface, one loop is split into two\r\n *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\r\n * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\r\n *\r\n * tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\r\n * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\r\n * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\r\n * the newly created loop will contain eDel->Dst.  If the deletion of eDel\r\n * would create isolated vertices, those are deleted as well.\r\n *\r\n * ********************** Other Edge Operations **************************\r\n *\r\n * tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that\r\n * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\r\n * eOrg and eNew will have the same left face.\r\n *\r\n * tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\r\n * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\r\n * eOrg and eNew will have the same left face.\r\n *\r\n * tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\r\n * to eDst->Org, and returns the corresponding half-edge eNew.\r\n * If eOrg->Lface == eDst->Lface, this splits one loop into two,\r\n * and the newly created loop is eNew->Lface.  Otherwise, two disjoint\r\n * loops are merged into one, and the loop eDst->Lface is destroyed.\r\n *\r\n * ************************ Other Operations *****************************\r\n *\r\n * tessMeshNewMesh() creates a new mesh with no edges, no vertices,\r\n * and no loops (what we usually call a \"face\").\r\n *\r\n * tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in\r\n * both meshes, and returns the new mesh (the old meshes are destroyed).\r\n *\r\n * tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.\r\n *\r\n * tessMeshZapFace( fZap ) destroys a face and removes it from the\r\n * global face list.  All edges of fZap will have a NULL pointer as their\r\n * left face.  Any edges which also have a NULL pointer as their right face\r\n * are deleted entirely (along with any isolated vertices this produces).\r\n * An entire mesh can be deleted by zapping its faces, one at a time,\r\n * in any order.  Zapped faces cannot be used in further mesh operations!\r\n *\r\n * tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\r\n */\r\nexport class TESSmesh {\r\n\tvHead: TESSvertex; /* dummy header for vertex list */\r\n\tfHead: TESSface; /* dummy header for face list */\r\n\teHead: TESShalfEdge; /* dummy header for edge list */\r\n\teHeadSym: TESShalfEdge; /* and its symmetric counterpart */\r\n\r\n\tconstructor() {\r\n\t\tconst v = new TESSvertex();\r\n\t\tconst f = new TESSface();\r\n\t\tconst e = new TESShalfEdge(0);\r\n\t\tconst eSym = new TESShalfEdge(1);\r\n\r\n\t\tv.next = v.prev = v;\r\n\t\tv.anEdge = null;\r\n\r\n\t\tf.next = f.prev = f;\r\n\r\n\t\te.next = e;\r\n\t\te.Sym = eSym;\r\n\r\n\t\teSym.next = eSym;\r\n\t\teSym.Sym = e;\r\n\r\n\t\tthis.vHead = v;\r\n\t\tthis.fHead = f;\r\n\t\tthis.eHead = e;\r\n\t\tthis.eHeadSym = eSym;\r\n\t}\r\n\r\n\t/* MakeEdge creates a new pair of half-edges which form their own loop.\r\n\t * No vertex or face structures are allocated, but these must be assigned\r\n\t * before the current edge operation is completed.\r\n\t */\r\n\t//static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )\r\n\tmakeEdge_(eNext: TESShalfEdge) {\r\n\t\tvar e = new TESShalfEdge(0);\r\n\t\tvar eSym = new TESShalfEdge(1);\r\n\r\n\t\t/* Make sure eNext points to the first edge of the edge pair */\r\n\t\tif (eNext.Sym.side < eNext.side) {\r\n\t\t\teNext = eNext.Sym;\r\n\t\t}\r\n\r\n\t\t/* Insert in circular doubly-linked list before eNext.\r\n\t\t * Note that the prev pointer is stored in Sym->next.\r\n\t\t */\r\n\t\tvar ePrev = eNext.Sym.next;\r\n\t\teSym.next = ePrev;\r\n\t\tePrev.Sym.next = e;\r\n\t\te.next = eNext;\r\n\t\teNext.Sym.next = eSym;\r\n\r\n\t\te.Sym = eSym;\r\n\t\te.Onext = e;\r\n\t\te.Lnext = eSym;\r\n\t\te.Org = null;\r\n\t\te.Lface = null;\r\n\t\te.winding = 0;\r\n\t\te.activeRegion = null;\r\n\r\n\t\teSym.Sym = e;\r\n\t\teSym.Onext = eSym;\r\n\t\teSym.Lnext = e;\r\n\t\teSym.Org = null;\r\n\t\teSym.Lface = null;\r\n\t\teSym.winding = 0;\r\n\t\teSym.activeRegion = null;\r\n\r\n\t\treturn e;\r\n\t}\r\n\r\n\t/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the\r\n\t * CS348a notes (see mesh.h).  Basically it modifies the mesh so that\r\n\t * a->Onext and b->Onext are exchanged.  This can have various effects\r\n\t * depending on whether a and b belong to different face or vertex rings.\r\n\t * For more explanation see tessMeshSplice() below.\r\n\t */\r\n\t// static void Splice( TESShalfEdge *a, TESShalfEdge *b )\r\n\tsplice_(a:TESShalfEdge, b: TESShalfEdge) {\r\n\t\tvar aOnext = a.Onext;\r\n\t\tvar bOnext = b.Onext;\r\n\t\taOnext.Sym.Lnext = b;\r\n\t\tbOnext.Sym.Lnext = a;\r\n\t\ta.Onext = bOnext;\r\n\t\tb.Onext = aOnext;\r\n\t}\r\n\r\n\t/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the\r\n\t * origin of all edges in the vertex loop to which eOrig belongs. \"vNext\" gives\r\n\t * a place to insert the new vertex in the global vertex list.  We insert\r\n\t * the new vertex *before* vNext so that algorithms which walk the vertex\r\n\t * list will not see the newly created vertices.\r\n\t */\r\n\t//static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )\r\n\tmakeVertex_(newVertex: TESSvertex, eOrig: TESShalfEdge, vNext: TESSvertex) {\r\n\t\tvar vNew = newVertex;\r\n\r\n\t\tassert(vNew, \"Vertex can't be null!\");\r\n\r\n\t\t/* insert in circular doubly-linked list before vNext */\r\n\t\tvar vPrev = vNext.prev;\r\n\t\tvNew.prev = vPrev;\r\n\t\tvPrev.next = vNew;\r\n\t\tvNew.next = vNext;\r\n\t\tvNext.prev = vNew;\r\n\r\n\t\tvNew.anEdge = eOrig;\r\n\t\t/* leave coords, s, t undefined */\r\n\r\n\t\t/* fix other edges on this vertex loop */\r\n\t\tvar e = eOrig;\r\n\t\tdo {\r\n\t\t\te.Org = vNew;\r\n\t\t\te = e.Onext;\r\n\t\t} while (e !== eOrig);\r\n\t}\r\n\r\n\t/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left\r\n\t * face of all edges in the face loop to which eOrig belongs.  \"fNext\" gives\r\n\t * a place to insert the new face in the global face list.  We insert\r\n\t * the new face *before* fNext so that algorithms which walk the face\r\n\t * list will not see the newly created faces.\r\n\t */\r\n\t// static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )\r\n\tmakeFace_(newFace: TESSface, eOrig:TESShalfEdge, fNext:TESSface) {\r\n\t\tvar fNew = newFace;\r\n\r\n\t\tassert(fNew, \"Face can't be null\");\r\n\r\n\t\t/* insert in circular doubly-linked list before fNext */\r\n\t\tvar fPrev = fNext.prev;\r\n\t\tfNew.prev = fPrev;\r\n\t\tfPrev.next = fNew;\r\n\t\tfNew.next = fNext;\r\n\t\tfNext.prev = fNew;\r\n\r\n\t\tfNew.anEdge = eOrig;\r\n\t\tfNew.trail = null;\r\n\t\tfNew.marked = false;\r\n\r\n\t\t/* The new face is marked \"inside\" if the old one was.  This is a\r\n\t\t * convenience for the common case where a face has been split in two.\r\n\t\t */\r\n\t\tfNew.inside = fNext.inside;\r\n\r\n\t\t/* fix other edges on this face loop */\r\n\t\tvar e = eOrig;\r\n\t\tdo {\r\n\t\t\te.Lface = fNew;\r\n\t\t\te = e.Lnext;\r\n\t\t} while (e !== eOrig);\r\n\t}\r\n\r\n\t/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),\r\n\t * and removes from the global edge list.\r\n\t */\r\n\t//static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )\r\n\tkillEdge_(eDel: TESShalfEdge) {\r\n\t\t/* Half-edges are allocated in pairs, see EdgePair above */\r\n\t\tif (eDel.Sym.side < eDel.side) {\r\n\t\t\teDel = eDel.Sym;\r\n\t\t}\r\n\r\n\t\t/* delete from circular doubly-linked list */\r\n\t\tvar eNext = eDel.next;\r\n\t\tvar ePrev = eDel.Sym.next;\r\n\t\teNext.Sym.next = ePrev;\r\n\t\tePrev.Sym.next = eNext;\r\n\t}\r\n\r\n\t/* KillVertex( vDel ) destroys a vertex and removes it from the global\r\n\t * vertex list.  It updates the vertex loop to point to a given new vertex.\r\n\t */\r\n\t//static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )\r\n\tkillVertex_(vDel: TESSvertex, newOrg: TESSvertex) {\r\n\t\tvar eStart = vDel.anEdge;\r\n\t\t/* change the origin of all affected edges */\r\n\t\tvar e = eStart;\r\n\t\tdo {\r\n\t\t\te.Org = newOrg;\r\n\t\t\te = e.Onext;\r\n\t\t} while (e !== eStart);\r\n\r\n\t\t/* delete from circular doubly-linked list */\r\n\t\tvar vPrev = vDel.prev;\r\n\t\tvar vNext = vDel.next;\r\n\t\tvNext.prev = vPrev;\r\n\t\tvPrev.next = vNext;\r\n\t}\r\n\r\n\t/* KillFace( fDel ) destroys a face and removes it from the global face\r\n\t * list.  It updates the face loop to point to a given new face.\r\n\t */\r\n\t//static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )\r\n\tkillFace_(fDel: TESSface, newLface: TESSface) {\r\n\t\tvar eStart = fDel.anEdge;\r\n\r\n\t\t/* change the left face of all affected edges */\r\n\t\tvar e = eStart;\r\n\t\tdo {\r\n\t\t\te.Lface = newLface;\r\n\t\t\te = e.Lnext;\r\n\t\t} while (e !== eStart);\r\n\r\n\t\t/* delete from circular doubly-linked list */\r\n\t\tvar fPrev = fDel.prev;\r\n\t\tvar fNext = fDel.next;\r\n\t\tfNext.prev = fPrev;\r\n\t\tfPrev.next = fNext;\r\n\t}\r\n\r\n\t/****************** Basic Edge Operations **********************/\r\n\r\n\t/* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).\r\n\t * The loop consists of the two new half-edges.\r\n\t */\r\n\t//TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )\r\n\tmakeEdge() {\r\n\t\tvar newVertex1 = new TESSvertex();\r\n\t\tvar newVertex2 = new TESSvertex();\r\n\t\tvar newFace = new TESSface();\r\n\t\tvar e = this.makeEdge_(this.eHead);\r\n\t\tthis.makeVertex_(newVertex1, e, this.vHead);\r\n\t\tthis.makeVertex_(newVertex2, e.Sym, this.vHead);\r\n\t\tthis.makeFace_(newFace, e, this.fHead);\r\n\t\treturn e;\r\n\t}\r\n\r\n\t/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the\r\n\t * mesh connectivity and topology.  It changes the mesh so that\r\n\t *\teOrg->Onext <- OLD( eDst->Onext )\r\n\t *\teDst->Onext <- OLD( eOrg->Onext )\r\n\t * where OLD(...) means the value before the meshSplice operation.\r\n\t *\r\n\t * This can have two effects on the vertex structure:\r\n\t *  - if eOrg->Org != eDst->Org, the two vertices are merged together\r\n\t *  - if eOrg->Org == eDst->Org, the origin is split into two vertices\r\n\t * In both cases, eDst->Org is changed and eOrg->Org is untouched.\r\n\t *\r\n\t * Similarly (and independently) for the face structure,\r\n\t *  - if eOrg->Lface == eDst->Lface, one loop is split into two\r\n\t *  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one\r\n\t * In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.\r\n\t *\r\n\t * Some special cases:\r\n\t * If eDst == eOrg, the operation has no effect.\r\n\t * If eDst == eOrg->Lnext, the new face will have a single edge.\r\n\t * If eDst == eOrg->Lprev, the old face will have a single edge.\r\n\t * If eDst == eOrg->Onext, the new vertex will have a single edge.\r\n\t * If eDst == eOrg->Oprev, the old vertex will have a single edge.\r\n\t */\r\n\t//int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )\r\n\tsplice(eOrg: TESShalfEdge, eDst: TESShalfEdge) {\r\n\t\tvar joiningLoops = false;\r\n\t\tvar joiningVertices = false;\r\n\r\n\t\tif (eOrg === eDst) return;\r\n\r\n\t\tif (eDst.Org !== eOrg.Org) {\r\n\t\t\t/* We are merging two disjoint vertices -- destroy eDst->Org */\r\n\t\t\tjoiningVertices = true;\r\n\t\t\tthis.killVertex_(eDst.Org, eOrg.Org);\r\n\t\t}\r\n\t\tif (eDst.Lface !== eOrg.Lface) {\r\n\t\t\t/* We are connecting two disjoint loops -- destroy eDst->Lface */\r\n\t\t\tjoiningLoops = true;\r\n\t\t\tthis.killFace_(eDst.Lface, eOrg.Lface);\r\n\t\t}\r\n\r\n\t\t/* Change the edge structure */\r\n\t\tthis.splice_(eDst, eOrg);\r\n\r\n\t\tif (!joiningVertices) {\r\n\t\t\tvar newVertex = new TESSvertex();\r\n\r\n\t\t\t/* We split one vertex into two -- the new vertex is eDst->Org.\r\n\t\t\t * Make sure the old vertex points to a valid half-edge.\r\n\t\t\t */\r\n\t\t\tthis.makeVertex_(newVertex, eDst, eOrg.Org);\r\n\t\t\teOrg.Org.anEdge = eOrg;\r\n\t\t}\r\n\t\tif (!joiningLoops) {\r\n\t\t\tvar newFace = new TESSface();\r\n\r\n\t\t\t/* We split one loop into two -- the new loop is eDst->Lface.\r\n\t\t\t * Make sure the old face points to a valid half-edge.\r\n\t\t\t */\r\n\t\t\tthis.makeFace_(newFace, eDst, eOrg.Lface);\r\n\t\t\teOrg.Lface.anEdge = eOrg;\r\n\t\t}\r\n\t}\r\n\r\n\t/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:\r\n\t * if (eDel->Lface != eDel->Rface), we join two loops into one; the loop\r\n\t * eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;\r\n\t * the newly created loop will contain eDel->Dst.  If the deletion of eDel\r\n\t * would create isolated vertices, those are deleted as well.\r\n\t *\r\n\t * This function could be implemented as two calls to tessMeshSplice\r\n\t * plus a few calls to memFree, but this would allocate and delete\r\n\t * unnecessary vertices and faces.\r\n\t */\r\n\t//int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )\r\n\tdelete(eDel: TESShalfEdge) {\r\n\t\tvar eDelSym = eDel.Sym;\r\n\t\tvar joiningLoops = false;\r\n\r\n\t\t/* First step: disconnect the origin vertex eDel->Org.  We make all\r\n\t\t * changes to get a consistent mesh in this \"intermediate\" state.\r\n\t\t */\r\n\t\tif (eDel.Lface !== eDel.Rface) {\r\n\t\t\t/* We are joining two loops into one -- remove the left face */\r\n\t\t\tjoiningLoops = true;\r\n\t\t\tthis.killFace_(eDel.Lface, eDel.Rface);\r\n\t\t}\r\n\r\n\t\tif (eDel.Onext === eDel) {\r\n\t\t\tthis.killVertex_(eDel.Org, null);\r\n\t\t} else {\r\n\t\t\t/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */\r\n\t\t\teDel.Rface.anEdge = eDel.Oprev;\r\n\t\t\teDel.Org.anEdge = eDel.Onext;\r\n\r\n\t\t\tthis.splice_(eDel, eDel.Oprev);\r\n\t\t\tif (!joiningLoops) {\r\n\t\t\t\tvar newFace = new TESSface();\r\n\r\n\t\t\t\t/* We are splitting one loop into two -- create a new loop for eDel. */\r\n\t\t\t\tthis.makeFace_(newFace, eDel, eDel.Lface);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Claim: the mesh is now in a consistent state, except that eDel->Org\r\n\t\t * may have been deleted.  Now we disconnect eDel->Dst.\r\n\t\t */\r\n\t\tif (eDelSym.Onext === eDelSym) {\r\n\t\t\tthis.killVertex_(eDelSym.Org, null);\r\n\t\t\tthis.killFace_(eDelSym.Lface, null);\r\n\t\t} else {\r\n\t\t\t/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */\r\n\t\t\teDel.Lface.anEdge = eDelSym.Oprev;\r\n\t\t\teDelSym.Org.anEdge = eDelSym.Onext;\r\n\t\t\tthis.splice_(eDelSym, eDelSym.Oprev);\r\n\t\t}\r\n\r\n\t\t/* Any isolated vertices or faces have already been freed. */\r\n\t\tthis.killEdge_(eDel);\r\n\t}\r\n\r\n\t/******************** Other Edge Operations **********************/\r\n\r\n\t/* All these routines can be implemented with the basic edge\r\n\t * operations above.  They are provided for convenience and efficiency.\r\n\t */\r\n\r\n\t/* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that\r\n\t * eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.\r\n\t * eOrg and eNew will have the same left face.\r\n\t */\r\n\t// TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );\r\n\taddEdgeVertex(eOrg: TESShalfEdge) {\r\n\t\tvar eNew = this.makeEdge_(eOrg);\r\n\t\tvar eNewSym = eNew.Sym;\r\n\r\n\t\t/* Connect the new edge appropriately */\r\n\t\tthis.splice_(eNew, eOrg.Lnext);\r\n\r\n\t\t/* Set the vertex and face information */\r\n\t\teNew.Org = eOrg.Dst;\r\n\r\n\t\tvar newVertex = new TESSvertex();\r\n\t\tthis.makeVertex_(newVertex, eNewSym, eNew.Org);\r\n\r\n\t\teNew.Lface = eNewSym.Lface = eOrg.Lface;\r\n\r\n\t\treturn eNew;\r\n\t}\r\n\r\n\t/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,\r\n\t * such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.\r\n\t * eOrg and eNew will have the same left face.\r\n\t */\r\n\t// TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );\r\n\tsplitEdge(eOrg: TESShalfEdge) {\r\n\t\tvar tempHalfEdge = this.addEdgeVertex(eOrg);\r\n\t\tvar eNew = tempHalfEdge.Sym;\r\n\r\n\t\t/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */\r\n\t\tthis.splice_(eOrg.Sym, eOrg.Sym.Oprev);\r\n\t\tthis.splice_(eOrg.Sym, eNew);\r\n\r\n\t\t/* Set the vertex and face information */\r\n\t\teOrg.Dst = eNew.Org;\r\n\t\teNew.Dst.anEdge = eNew.Sym; /* may have pointed to eOrg->Sym */\r\n\t\teNew.Rface = eOrg.Rface;\r\n\t\teNew.winding = eOrg.winding; /* copy old winding information */\r\n\t\teNew.Sym.winding = eOrg.Sym.winding;\r\n\r\n\t\treturn eNew;\r\n\t}\r\n\r\n\t/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst\r\n\t * to eDst->Org, and returns the corresponding half-edge eNew.\r\n\t * If eOrg->Lface == eDst->Lface, this splits one loop into two,\r\n\t * and the newly created loop is eNew->Lface.  Otherwise, two disjoint\r\n\t * loops are merged into one, and the loop eDst->Lface is destroyed.\r\n\t *\r\n\t * If (eOrg == eDst), the new face will have only two edges.\r\n\t * If (eOrg->Lnext == eDst), the old face is reduced to a single edge.\r\n\t * If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.\r\n\t */\r\n\r\n\t// TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );\r\n\tconnect(eOrg: TESShalfEdge, eDst: TESShalfEdge) {\r\n\t\tvar joiningLoops = false;\r\n\t\tvar eNew = this.makeEdge_(eOrg);\r\n\t\tvar eNewSym = eNew.Sym;\r\n\r\n\t\tif (eDst.Lface !== eOrg.Lface) {\r\n\t\t\t/* We are connecting two disjoint loops -- destroy eDst->Lface */\r\n\t\t\tjoiningLoops = true;\r\n\t\t\tthis.killFace_(eDst.Lface, eOrg.Lface);\r\n\t\t}\r\n\r\n\t\t/* Connect the new edge appropriately */\r\n\t\tthis.splice_(eNew, eOrg.Lnext);\r\n\t\tthis.splice_(eNewSym, eDst);\r\n\r\n\t\t/* Set the vertex and face information */\r\n\t\teNew.Org = eOrg.Dst;\r\n\t\teNewSym.Org = eDst.Org;\r\n\t\teNew.Lface = eNewSym.Lface = eOrg.Lface;\r\n\r\n\t\t/* Make sure the old face points to a valid half-edge */\r\n\t\teOrg.Lface.anEdge = eNewSym;\r\n\r\n\t\tif (!joiningLoops) {\r\n\t\t\tvar newFace = new TESSface();\r\n\t\t\t/* We split one loop into two -- the new loop is eNew->Lface */\r\n\t\t\tthis.makeFace_(newFace, eNew, eOrg.Lface);\r\n\t\t}\r\n\t\treturn eNew;\r\n\t}\r\n\r\n\t/* tessMeshZapFace( fZap ) destroys a face and removes it from the\r\n\t * global face list.  All edges of fZap will have a NULL pointer as their\r\n\t * left face.  Any edges which also have a NULL pointer as their right face\r\n\t * are deleted entirely (along with any isolated vertices this produces).\r\n\t * An entire mesh can be deleted by zapping its faces, one at a time,\r\n\t * in any order.  Zapped faces cannot be used in further mesh operations!\r\n\t */\r\n\tzapFace(fZap: TESSface) {\r\n\t\tvar eStart = fZap.anEdge;\r\n\t\tvar e, eNext, eSym;\r\n\t\tvar fPrev, fNext;\r\n\r\n\t\t/* walk around face, deleting edges whose right face is also NULL */\r\n\t\teNext = eStart.Lnext;\r\n\t\tdo {\r\n\t\t\te = eNext;\r\n\t\t\teNext = e.Lnext;\r\n\r\n\t\t\te.Lface = null;\r\n\t\t\tif (e.Rface === null) {\r\n\t\t\t\t/* delete the edge -- see TESSmeshDelete above */\r\n\r\n\t\t\t\tif (e.Onext === e) {\r\n\t\t\t\t\tthis.killVertex_(e.Org, null);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* Make sure that e->Org points to a valid half-edge */\r\n\t\t\t\t\te.Org.anEdge = e.Onext;\r\n\t\t\t\t\tthis.splice_(e, e.Oprev);\r\n\t\t\t\t}\r\n\t\t\t\teSym = e.Sym;\r\n\t\t\t\tif (eSym.Onext === eSym) {\r\n\t\t\t\t\tthis.killVertex_(eSym.Org, null);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* Make sure that eSym->Org points to a valid half-edge */\r\n\t\t\t\t\teSym.Org.anEdge = eSym.Onext;\r\n\t\t\t\t\tthis.splice_(eSym, eSym.Oprev);\r\n\t\t\t\t}\r\n\t\t\t\tthis.killEdge_(e);\r\n\t\t\t}\r\n\t\t} while (e != eStart);\r\n\r\n\t\t/* delete from circular doubly-linked list */\r\n\t\tfPrev = fZap.prev;\r\n\t\tfNext = fZap.next;\r\n\t\tfNext.prev = fPrev;\r\n\t\tfPrev.next = fNext;\r\n\t}\r\n\r\n\tcountFaceVerts_(f: TESSface) {\r\n\t\tvar eCur = f.anEdge;\r\n\t\tvar n = 0;\r\n\t\tdo {\r\n\t\t\tn++;\r\n\t\t\teCur = eCur.Lnext;\r\n\t\t} while (eCur !== f.anEdge);\r\n\t\treturn n;\r\n\t}\r\n\r\n\t//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )\r\n\tmergeConvexFaces(maxVertsPerFace: number) {\r\n\t\tvar f;\r\n\t\tvar eCur, eNext, eSym;\r\n\t\tvar vStart;\r\n\t\tvar curNv, symNv;\r\n\r\n\t\tfor (f = this.fHead.next; f !== this.fHead; f = f.next) {\r\n\t\t\t// Skip faces which are outside the result.\r\n\t\t\tif (!f.inside) continue;\r\n\r\n\t\t\teCur = f.anEdge;\r\n\t\t\tvStart = eCur.Org;\r\n\r\n\t\t\twhile (true) {\r\n\t\t\t\teNext = eCur.Lnext;\r\n\t\t\t\teSym = eCur.Sym;\r\n\r\n\t\t\t\t// Try to merge if the neighbour face is valid.\r\n\t\t\t\tif (eSym && eSym.Lface && eSym.Lface.inside) {\r\n\t\t\t\t\t// Try to merge the neighbour faces if the resulting polygons\r\n\t\t\t\t\t// does not exceed maximum number of vertices.\r\n\t\t\t\t\tcurNv = this.countFaceVerts_(f);\r\n\t\t\t\t\tsymNv = this.countFaceVerts_(eSym.Lface);\r\n\t\t\t\t\tif (curNv + symNv - 2 <= maxVertsPerFace) {\r\n\t\t\t\t\t\t// Merge if the resulting poly is convex.\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tGeom.vertCCW(\r\n\t\t\t\t\t\t\t\teCur.Lprev.Org,\r\n\t\t\t\t\t\t\t\teCur.Org,\r\n\t\t\t\t\t\t\t\teSym.Lnext.Lnext.Org,\r\n\t\t\t\t\t\t\t) &&\r\n\t\t\t\t\t\t\tGeom.vertCCW(\r\n\t\t\t\t\t\t\t\teSym.Lprev.Org,\r\n\t\t\t\t\t\t\t\teSym.Org,\r\n\t\t\t\t\t\t\t\teCur.Lnext.Lnext.Org,\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\teNext = eSym.Lnext;\r\n\t\t\t\t\t\t\tthis.delete(eSym);\r\n\t\t\t\t\t\t\teCur = null;\r\n\t\t\t\t\t\t\teSym = null;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (eCur && eCur.Lnext.Org === vStart) break;\r\n\r\n\t\t\t\t// Continue to next edge.\r\n\t\t\t\teCur = eNext;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.\r\n\t */\r\n\tcheck() {\r\n\t\tvar fHead = this.fHead;\r\n\t\tvar vHead = this.vHead;\r\n\t\tvar eHead = this.eHead;\r\n\t\tvar f, fPrev, v, vPrev, e, ePrev;\r\n\r\n\t\tfPrev = fHead;\r\n\t\tfor (fPrev = fHead; (f = fPrev.next) !== fHead; fPrev = f) {\r\n\t\t\tassert(f.prev === fPrev);\r\n\t\t\te = f.anEdge;\r\n\t\t\tdo {\r\n\t\t\t\tassert(e.Sym !== e);\r\n\t\t\t\tassert(e.Sym.Sym === e);\r\n\t\t\t\tassert(e.Lnext.Onext.Sym === e);\r\n\t\t\t\tassert(e.Onext.Sym.Lnext === e);\r\n\t\t\t\tassert(e.Lface === f);\r\n\t\t\t\te = e.Lnext;\r\n\t\t\t} while (e !== f.anEdge);\r\n\t\t}\r\n\t\tassert(f.prev === fPrev && f.anEdge === null);\r\n\r\n\t\tvPrev = vHead;\r\n\t\tfor (vPrev = vHead; (v = vPrev.next) !== vHead; vPrev = v) {\r\n\t\t\tassert(v.prev === vPrev);\r\n\t\t\te = v.anEdge;\r\n\t\t\tdo {\r\n\t\t\t\tassert(e.Sym !== e);\r\n\t\t\t\tassert(e.Sym.Sym === e);\r\n\t\t\t\tassert(e.Lnext.Onext.Sym === e);\r\n\t\t\t\tassert(e.Onext.Sym.Lnext === e);\r\n\t\t\t\tassert(e.Org === v);\r\n\t\t\t\te = e.Onext;\r\n\t\t\t} while (e !== v.anEdge);\r\n\t\t}\r\n\t\tassert(v.prev === vPrev && v.anEdge === null);\r\n\r\n\t\tePrev = eHead;\r\n\t\tfor (ePrev = eHead; (e = ePrev.next) !== eHead; ePrev = e) {\r\n\t\t\tassert(e.Sym.next === ePrev.Sym);\r\n\t\t\tassert(e.Sym !== e);\r\n\t\t\tassert(e.Sym.Sym === e);\r\n\t\t\tassert(e.Org !== null);\r\n\t\t\tassert(e.Dst !== null);\r\n\t\t\tassert(e.Lnext.Onext.Sym === e);\r\n\t\t\tassert(e.Onext.Sym.Lnext === e);\r\n\t\t}\r\n\t\tassert(\r\n\t\t\te.Sym.next === ePrev.Sym &&\r\n\t\t\t\te.Sym === this.eHeadSym &&\r\n\t\t\t\te.Sym.Sym === e &&\r\n\t\t\t\te.Org === null &&\r\n\t\t\t\te.Dst === null &&\r\n\t\t\t\te.Lface === null &&\r\n\t\t\t\te.Rface === null,\r\n\t\t);\r\n\t}\r\n};\r\n","import { assert } from './assert';\r\n\r\nexport class PQnode {\r\n\thandle: any = null;\r\n}\r\n\r\nexport class PQhandleElem {\r\n\tkey: any = null;\r\n\tnode: number = 0;\r\n}\r\n\r\nexport class PriorityQ {\r\n\tmax: number = 0;\r\n\tnodes: Array<PQnode> = [];\r\n\thandles: Array<PQhandleElem> = [];\r\n\tinitialized: boolean = false;\r\n\tfreeList: number = 0;\r\n\tsize: number = 0;\r\n\r\n\tconstructor(size: number, public leq: (...args: any) => boolean) {\r\n\t\r\n\t\tthis.max = size;\r\n\t\tthis.nodes = Array.from({length : size + 1}, () => new PQnode() );\r\n\t\tthis.handles = Array.from({length : size + 1}, () => new PQhandleElem() );\r\n\r\n\t\tthis.initialized = false;\r\n\t\t\r\n\t\t/* so that Minimum() returns NULL */\r\n\t\tthis.nodes[1].handle = 1; \r\n\t\tthis.handles[1].key = null;\r\n\r\n\t}\r\n\r\n\tfloatDown_(curr: number) {\r\n\t\tvar n = this.nodes;\r\n\t\tvar h = this.handles;\r\n\t\tvar hCurr, hChild;\r\n\t\tvar child;\r\n\r\n\t\thCurr = n[curr].handle;\r\n\t\tfor (; ;) {\r\n\t\t\tchild = curr << 1;\r\n\t\t\tif (\r\n\t\t\t\tchild < this.size &&\r\n\t\t\t\tthis.leq(h[n[child + 1].handle].key, h[n[child].handle].key)\r\n\t\t\t) {\r\n\t\t\t\t++child;\r\n\t\t\t}\r\n\r\n\t\t\tassert(child <= this.max);\r\n\r\n\t\t\thChild = n[child].handle;\r\n\t\t\tif (child > this.size || this.leq(h[hCurr].key, h[hChild].key)) {\r\n\t\t\t\tn[curr].handle = hCurr;\r\n\t\t\t\th[hCurr].node = curr;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tn[curr].handle = hChild;\r\n\t\t\th[hChild].node = curr;\r\n\t\t\tcurr = child;\r\n\t\t}\r\n\t}\r\n\r\n\tfloatUp_(curr: number) {\r\n\t\tvar n = this.nodes;\r\n\t\tvar h = this.handles;\r\n\t\tvar hCurr, hParent;\r\n\t\tvar parent;\r\n\r\n\t\thCurr = n[curr].handle;\r\n\t\tfor (; ;) {\r\n\t\t\tparent = curr >> 1;\r\n\t\t\thParent = n[parent].handle;\r\n\t\t\tif (parent === 0 || this.leq(h[hParent].key, h[hCurr].key)) {\r\n\t\t\t\tn[curr].handle = hCurr;\r\n\t\t\t\th[hCurr].node = curr;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tn[curr].handle = hParent;\r\n\t\t\th[hParent].node = curr;\r\n\t\t\tcurr = parent;\r\n\t\t}\r\n\t}\r\n\r\n\tinit() {\r\n\t\t/* This method of building a heap is O(n), rather than O(n lg n). */\r\n\t\tfor (let i = this.size; i >= 1; --i) {\r\n\t\t\tthis.floatDown_(i);\r\n\t\t}\r\n\t\tthis.initialized = true;\r\n\t}\r\n\r\n\tmin() {\r\n\t\treturn this.handles[this.nodes[1].handle].key;\r\n\t}\r\n\r\n\t/* really pqHeapInsert */\r\n\t/* returns INV_HANDLE iff out of memory */\r\n\t//PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )\r\n\tinsert(keyNew: any) {\r\n\t\tvar curr;\r\n\t\tvar free;\r\n\r\n\t\tcurr = ++this.size;\r\n\t\tif (curr * 2 > this.max) {\r\n\t\t\tthis.max *= 2;\r\n\t\t\tvar i;\r\n\t\t\tvar s;\r\n\t\t\ts = this.nodes.length;\r\n\t\t\tthis.nodes.length = this.max + 1;\r\n\t\t\tfor (i = s; i < this.nodes.length; i++)\r\n\t\t\t\tthis.nodes[i] = new PQnode();\r\n\r\n\t\t\ts = this.handles.length;\r\n\t\t\tthis.handles.length = this.max + 1;\r\n\t\t\tfor (i = s; i < this.handles.length; i++)\r\n\t\t\t\tthis.handles[i] = new PQhandleElem();\r\n\t\t}\r\n\r\n\t\tif (this.freeList === 0) {\r\n\t\t\tfree = curr;\r\n\t\t} else {\r\n\t\t\tfree = this.freeList;\r\n\t\t\tthis.freeList = this.handles[free].node;\r\n\t\t}\r\n\r\n\t\tthis.nodes[curr].handle = free;\r\n\t\tthis.handles[free].node = curr;\r\n\t\tthis.handles[free].key = keyNew;\r\n\r\n\t\tif (this.initialized) {\r\n\t\t\tthis.floatUp_(curr);\r\n\t\t}\r\n\t\treturn free;\r\n\t}\r\n\r\n\t//PQkey pqHeapExtractMin( PriorityQHeap *pq )\r\n\textractMin() {\r\n\t\tvar n = this.nodes;\r\n\t\tvar h = this.handles;\r\n\t\tvar hMin = n[1].handle;\r\n\t\tvar min = h[hMin].key;\r\n\r\n\t\tif (this.size > 0) {\r\n\t\t\tn[1].handle = n[this.size].handle;\r\n\t\t\th[n[1].handle].node = 1;\r\n\r\n\t\t\th[hMin].key = null;\r\n\t\t\th[hMin].node = this.freeList;\r\n\t\t\tthis.freeList = hMin;\r\n\r\n\t\t\t--this.size;\r\n\t\t\tif (this.size > 0) {\r\n\t\t\t\tthis.floatDown_(1);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn min;\r\n\t}\r\n\r\n\tdelete(hCurr: number) {\r\n\t\tvar n = this.nodes;\r\n\t\tvar h = this.handles;\r\n\t\tvar curr;\r\n\r\n\t\tassert(hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null);\r\n\r\n\t\tcurr = h[hCurr].node;\r\n\t\tn[curr].handle = n[this.size].handle;\r\n\t\th[n[curr].handle].node = curr;\r\n\r\n\t\t--this.size;\r\n\t\tif (curr <= this.size) {\r\n\t\t\tif (\r\n\t\t\t\tcurr <= 1 ||\r\n\t\t\t\tthis.leq(h[n[curr >> 1].handle].key, h[n[curr].handle].key)\r\n\t\t\t) {\r\n\t\t\t\tthis.floatDown_(curr);\r\n\t\t\t} else {\r\n\t\t\t\tthis.floatUp_(curr);\r\n\t\t\t}\r\n\t\t}\r\n\t\th[hCurr].key = null;\r\n\t\th[hCurr].node = this.freeList;\r\n\t\tthis.freeList = hCurr;\r\n\t}\r\n}\r\n\r\n","import { TESShalfEdge } from './TESShalfEdge';\r\n\r\n/* For each pair of adjacent edges crossing the sweep line, there is\r\n * an ActiveRegion to represent the region between them.  The active\r\n * regions are kept in sorted order in a dynamic dictionary.  As the\r\n * sweep line crosses each vertex, we update the affected regions.\r\n */\r\nexport class ActiveRegion {\r\n\teUp: TESShalfEdge = null; /* upper edge, directed right to left */\r\n\tnodeUp?: any = null; /* dictionary node corresponding to eUp */\r\n\twindingNumber: number = 0;\r\n\t/* used to determine which regions are\r\n\t * inside the polygon */\r\n\tinside: boolean = false; /* is this region inside the polygon? */\r\n\tsentinel: boolean = false; /* marks fake edges at t = +/-infinity */\r\n\tdirty: boolean = false;\r\n\t/* marks regions where the upper or lower\r\n\t * edge has changed, but we haven't checked\r\n\t * whether they intersect yet */\r\n\tfixUpperEdge: boolean = false;\r\n\t/* marks temporary edges introduced when\r\n\t * we process a \"right vertex\" (one without\r\n\t * any edges leaving to the right) */\r\n}\r\n","\r\nexport class DictNode {\r\n\tkey: any = null;\r\n\tnext: DictNode = null;\r\n\tprev: DictNode = null;\r\n}\r\n\r\nexport class Dict {\r\n\thead: DictNode = new DictNode();\r\n\t\r\n\tconstructor(public frame: any, public leq: (...arg: any) => boolean) {\r\n\t\tthis.head.next = this.head;\r\n\t\tthis.head.prev = this.head;\r\n\t}\r\n\r\n\tmin() {\r\n\t\treturn this.head.next;\r\n\t}\r\n\r\n\tmax() {\r\n\t\treturn this.head.prev;\r\n\t}\r\n\r\n\tinsert(k: any) {\r\n\t\treturn this.insertBefore(this.head, k);\r\n\t}\r\n\r\n\tsearch(key: any) {\r\n\t\t/* Search returns the node with the smallest key greater than or equal\r\n\t\t * to the given key.  If there is no such key, returns a node whose\r\n\t\t * key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.\r\n\t\t */\r\n\t\tlet node = this.head;\r\n\t\tdo {\r\n\t\t\tnode = node.next;\r\n\t\t} while (node.key !== null && !this.leq(this.frame, key, node.key));\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\tinsertBefore(node: DictNode, key: any) {\r\n\t\tdo {\r\n\t\t\tnode = node.prev;\r\n\t\t} while (node.key !== null && !this.leq(this.frame, node.key, key));\r\n\r\n\t\tconst newNode = new DictNode();\r\n\t\tnewNode.key = key;\r\n\t\tnewNode.next = node.next;\r\n\t\tnode.next.prev = newNode;\r\n\t\tnewNode.prev = node;\r\n\t\tnode.next = newNode;\r\n\r\n\t\treturn newNode;\r\n\t}\r\n\r\n\tdelete(node:DictNode) {\r\n\t\tnode.next.prev = node.prev;\r\n\t\tnode.prev.next = node.next;\r\n\t}\r\n};","import { Geom } from \"./Geom\";\r\nimport { assert } from \"./../utils/assert\";\r\nimport { PriorityQ } from \"./PriorityQ\";\r\nimport { WINDING } from \"./constants\";\r\nimport { ActiveRegion} from \"./../mesh/ActiveRegion\";\r\nimport { TESSvertex } from \"./../mesh/TESSvertex\";\r\n\r\nimport { Dict } from \"./Dict\";\r\nimport { TESSmesh } from \"../mesh/TESSmesh\";\r\nimport { TESShalfEdge } from \"../mesh/index\";\r\nimport { Tesselator } from \"../index\";\r\n\r\nexport class Sweep {\r\n\r\n\tstatic regionBelow(r: ActiveRegion) {\r\n\t\treturn r.nodeUp.prev.key;\r\n\t}\r\n\r\n\tstatic regionAbove(r: ActiveRegion) {\r\n\t\treturn r.nodeUp.next.key;\r\n\t}\r\n\r\n\tstatic debugEvent(tess: any) {\r\n\t\t// empty\r\n\t}\r\n\r\n\t/*\r\n\t * Invariants for the Edge Dictionary.\r\n\t * - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)\r\n\t *   at any valid location of the sweep event\r\n\t * - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2\r\n\t *   share a common endpoint\r\n\t * - for each e, e->Dst has been processed, but not e->Org\r\n\t * - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)\r\n\t *   where \"event\" is the current sweep line event.\r\n\t * - no edge e has zero length\r\n\t *\r\n\t * Invariants for the Mesh (the processed portion).\r\n\t * - the portion of the mesh left of the sweep line is a planar graph,\r\n\t *   ie. there is *some* way to embed it in the plane\r\n\t * - no processed edge has zero length\r\n\t * - no two processed vertices have identical coordinates\r\n\t * - each \"inside\" region is monotone, ie. can be broken into two chains\r\n\t *   of monotonically increasing vertices according to VertLeq(v1,v2)\r\n\t *   - a non-invariant: these chains may intersect (very slightly)\r\n\t *\r\n\t * Invariants for the Sweep.\r\n\t * - if none of the edges incident to the event vertex have an activeRegion\r\n\t *   (ie. none of these edges are in the edge dictionary), then the vertex\r\n\t *   has only right-going edges.\r\n\t * - if an edge is marked \"fixUpperEdge\" (it is a temporary edge introduced\r\n\t *   by ConnectRightVertex), then it is the only right-going edge from\r\n\t *   its associated vertex.  (This says that these edges exist only\r\n\t *   when it is necessary.)\r\n\t */\r\n\r\n\t/* When we merge two edges into one, we need to compute the combined\r\n\t * winding of the new edge.\r\n\t */\r\n\tstatic addWinding(eDst: TESShalfEdge, eSrc: TESShalfEdge) {\r\n\t\teDst.winding += eSrc.winding;\r\n\t\teDst.Sym.winding += eSrc.Sym.winding;\r\n\t}\r\n\r\n\t//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )\r\n\tstatic edgeLeq(tess: Tesselator, reg1: ActiveRegion, reg2: ActiveRegion) {\r\n\t\t/*\r\n\t\t * Both edges must be directed from right to left (this is the canonical\r\n\t\t * direction for the upper edge of each region).\r\n\t\t *\r\n\t\t * The strategy is to evaluate a \"t\" value for each edge at the\r\n\t\t * current sweep line position, given by tess->event.  The calculations\r\n\t\t * are designed to be very stable, but of course they are not perfect.\r\n\t\t *\r\n\t\t * Special case: if both edge destinations are at the sweep event,\r\n\t\t * we sort the edges by slope (they would otherwise compare equally).\r\n\t\t */\r\n\t\tvar ev = tess.event;\r\n\t\t\r\n\t\tvar e1 = reg1.eUp;\r\n\t\tvar e2 = reg2.eUp;\r\n\r\n\t\tif (e1.Dst === ev) {\r\n\t\t\tif (e2.Dst === ev) {\r\n\t\t\t\t/* Two edges right of the sweep line which meet at the sweep event.\r\n\t\t\t\t * Sort them by slope.\r\n\t\t\t\t */\r\n\t\t\t\tif (Geom.vertLeq(e1.Org, e2.Org)) {\r\n\t\t\t\t\treturn Geom.edgeSign(e2.Dst, e1.Org, e2.Org) <= 0;\r\n\t\t\t\t}\r\n\t\t\t\treturn Geom.edgeSign(e1.Dst, e2.Org, e1.Org) >= 0;\r\n\t\t\t}\r\n\t\t\treturn Geom.edgeSign(e2.Dst, ev, e2.Org) <= 0;\r\n\t\t}\r\n\t\tif (e2.Dst === ev) {\r\n\t\t\treturn Geom.edgeSign(e1.Dst, ev, e1.Org) >= 0;\r\n\t\t}\r\n\r\n\t\t/* General case - compute signed distance *from* e1, e2 to event */\r\n\t\tconst t1 = Geom.edgeEval(e1.Dst, ev, e1.Org);\r\n\t\tconst t2 = Geom.edgeEval(e2.Dst, ev, e2.Org);\r\n\t\treturn t1 >= t2;\r\n\t}\r\n\r\n\t//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )\r\n\tstatic deleteRegion(tess: Tesselator, reg: ActiveRegion) {\r\n\t\tif (reg.fixUpperEdge) {\r\n\t\t\t/* It was created with zero winding number, so it better be\r\n\t\t\t * deleted with zero winding number (ie. it better not get merged\r\n\t\t\t * with a real edge).\r\n\t\t\t */\r\n\t\t\tassert(reg.eUp.winding === 0);\r\n\t\t}\r\n\t\treg.eUp.activeRegion = null;\r\n\t\ttess.dict.delete(reg.nodeUp);\r\n\t}\r\n\r\n\t//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )\r\n\tstatic fixUpperEdge(tess: Tesselator, reg: ActiveRegion, newEdge: TESShalfEdge) {\r\n\t\t/*\r\n\t\t * Replace an upper edge which needs fixing (see ConnectRightVertex).\r\n\t\t */\r\n\t\tassert(reg.fixUpperEdge);\r\n\t\ttess.mesh.delete(reg.eUp);\r\n\t\treg.fixUpperEdge = false;\r\n\t\treg.eUp = newEdge;\r\n\t\tnewEdge.activeRegion = reg;\r\n\t}\r\n\r\n\t//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )\r\n\tstatic topLeftRegion(tess: Tesselator, reg: ActiveRegion) {\r\n\t\tvar org = reg.eUp.Org;\r\n\t\tvar e;\r\n\r\n\t\t/* Find the region above the uppermost edge with the same origin */\r\n\t\tdo {\r\n\t\t\treg = Sweep.regionAbove(reg);\r\n\t\t} while (reg.eUp.Org === org);\r\n\r\n\t\t/* If the edge above was a temporary edge introduced by ConnectRightVertex,\r\n\t\t * now is the time to fix it.\r\n\t\t */\r\n\t\tif (reg.fixUpperEdge) {\r\n\t\t\te = tess.mesh.connect(\r\n\t\t\t\tSweep.regionBelow(reg).eUp.Sym,\r\n\t\t\t\treg.eUp.Lnext,\r\n\t\t\t);\r\n\t\t\tif (e === null) return null;\r\n\t\t\tSweep.fixUpperEdge(tess, reg, e);\r\n\t\t\treg = Sweep.regionAbove(reg);\r\n\t\t}\r\n\t\treturn reg;\r\n\t}\r\n\r\n\t//static ActiveRegion *TopRightRegion( ActiveRegion *reg )\r\n\tstatic topRightRegion(reg: ActiveRegion) {\r\n\t\tvar dst = reg.eUp.Dst;\r\n\t\t/* Find the region above the uppermost edge with the same destination */\r\n\t\tdo {\r\n\t\t\treg = Sweep.regionAbove(reg);\r\n\t\t} while (reg.eUp.Dst === dst);\r\n\t\treturn reg;\r\n\t}\r\n\r\n\t//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )\r\n\tstatic addRegionBelow(tess: Tesselator, regAbove: ActiveRegion, eNewUp: TESShalfEdge) {\r\n\t\t/*\r\n\t\t * Add a new active region to the sweep line, *somewhere* below \"regAbove\"\r\n\t\t * (according to where the new edge belongs in the sweep-line dictionary).\r\n\t\t * The upper edge of the new region will be \"eNewUp\".\r\n\t\t * Winding number and \"inside\" flag are not updated.\r\n\t\t */\r\n\t\tvar regNew = new ActiveRegion();\r\n\t\tregNew.eUp = eNewUp;\r\n\t\tregNew.nodeUp = tess.dict.insertBefore(regAbove.nodeUp, regNew);\r\n\t\t//\tif (regNew->nodeUp == NULL) longjmp(tess->env,1);\r\n\t\tregNew.fixUpperEdge = false;\r\n\t\tregNew.sentinel = false;\r\n\t\tregNew.dirty = false;\r\n\r\n\t\teNewUp.activeRegion = regNew;\r\n\t\treturn regNew;\r\n\t}\r\n\r\n\t//static int IsWindingInside( TESStesselator *tess, int n )\r\n\tstatic isWindingInside(tess:Tesselator, n: number) {\r\n\t\tswitch (tess.windingRule) {\r\n\t\t\tcase WINDING.ODD:\r\n\t\t\t\treturn (n & 1) !== 0;\r\n\t\t\tcase WINDING.NONZERO:\r\n\t\t\t\treturn n !== 0;\r\n\t\t\tcase WINDING.POSITIVE:\r\n\t\t\t\treturn n > 0;\r\n\t\t\tcase WINDING.NEGATIVE:\r\n\t\t\t\treturn n < 0;\r\n\t\t\tcase WINDING.ABS_GEQ_TWO:\r\n\t\t\t\treturn n >= 2 || n <= -2;\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Invalid winding rulle\");\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )\r\n\tstatic computeWinding(tess:Tesselator, reg:ActiveRegion) {\r\n\t\treg.windingNumber =\r\n\t\t\tSweep.regionAbove(reg).windingNumber + reg.eUp.winding;\r\n\t\treg.inside = Sweep.isWindingInside(tess, reg.windingNumber);\r\n\t}\r\n\r\n\t//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )\r\n\tstatic finishRegion(tess:Tesselator, reg:ActiveRegion) {\r\n\t\t/*\r\n\t\t * Delete a region from the sweep line.  This happens when the upper\r\n\t\t * and lower chains of a region meet (at a vertex on the sweep line).\r\n\t\t * The \"inside\" flag is copied to the appropriate mesh face (we could\r\n\t\t * not do this before -- since the structure of the mesh is always\r\n\t\t * changing, this face may not have even existed until now).\r\n\t\t */\r\n\t\tvar e = reg.eUp;\r\n\t\tvar f = e.Lface;\r\n\r\n\t\tf.inside = reg.inside;\r\n\t\tf.anEdge = e; /* optimization for tessMeshTessellateMonoRegion() */\r\n\t\tSweep.deleteRegion(tess, reg);\r\n\t}\r\n\r\n\t//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )\r\n\tstatic finishLeftRegions(tess:Tesselator, regFirst:ActiveRegion, regLast:ActiveRegion) {\r\n\t\t/*\r\n\t\t * We are given a vertex with one or more left-going edges.  All affected\r\n\t\t * edges should be in the edge dictionary.  Starting at regFirst->eUp,\r\n\t\t * we walk down deleting all regions where both edges have the same\r\n\t\t * origin vOrg.  At the same time we copy the \"inside\" flag from the\r\n\t\t * active region to the face, since at this point each face will belong\r\n\t\t * to at most one region (this was not necessarily true until this point\r\n\t\t * in the sweep).  The walk stops at the region above regLast; if regLast\r\n\t\t * is NULL we walk as far as possible.  At the same time we relink the\r\n\t\t * mesh if necessary, so that the ordering of edges around vOrg is the\r\n\t\t * same as in the dictionary.\r\n\t\t */\r\n\t\tvar e;\r\n\t\tvar reg = null;\r\n\t\tvar regPrev = regFirst;\r\n\t\tvar ePrev = regFirst.eUp;\r\n\t\t\r\n\t\twhile (regPrev !== regLast) {\r\n\t\t\tregPrev.fixUpperEdge = false; /* placement was OK */\r\n\t\t\treg = Sweep.regionBelow(regPrev);\r\n\t\t\te = reg.eUp;\r\n\t\t\tif (e.Org != ePrev.Org) {\r\n\t\t\t\tif (!reg.fixUpperEdge) {\r\n\t\t\t\t\t/* Remove the last left-going edge.  Even though there are no further\r\n\t\t\t\t\t * edges in the dictionary with this origin, there may be further\r\n\t\t\t\t\t * such edges in the mesh (if we are adding left edges to a vertex\r\n\t\t\t\t\t * that has already been processed).  Thus it is important to call\r\n\t\t\t\t\t * FinishRegion rather than just DeleteRegion.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tSweep.finishRegion(tess, regPrev);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t/* If the edge below was a temporary edge introduced by\r\n\t\t\t\t * ConnectRightVertex, now is the time to fix it.\r\n\t\t\t\t */\r\n\t\t\t\te = tess.mesh.connect(ePrev.Lprev, e.Sym);\r\n\t\t\t\t//\t\t\tif (e == NULL) longjmp(tess->env,1);\r\n\t\t\t\tSweep.fixUpperEdge(tess, reg, e);\r\n\t\t\t}\r\n\r\n\t\t\t/* Relink edges so that ePrev->Onext == e */\r\n\t\t\tif (ePrev.Onext !== e) {\r\n\t\t\t\ttess.mesh.splice(e.Oprev, e);\r\n\t\t\t\ttess.mesh.splice(ePrev, e);\r\n\t\t\t}\r\n\t\t\tSweep.finishRegion(tess, regPrev); /* may change reg->eUp */\r\n\t\t\tePrev = reg.eUp;\r\n\t\t\tregPrev = reg;\r\n\t\t}\r\n\t\treturn ePrev;\r\n\t}\r\n\r\n\t//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )\r\n\tstatic addRightEdges(tess: Tesselator, regUp: ActiveRegion, eFirst: TESShalfEdge, eLast:TESShalfEdge, eTopLeft:TESShalfEdge, cleanUp: boolean) {\r\n\t\t/*\r\n\t\t * Purpose: insert right-going edges into the edge dictionary, and update\r\n\t\t * winding numbers and mesh connectivity appropriately.  All right-going\r\n\t\t * edges share a common origin vOrg.  Edges are inserted CCW starting at\r\n\t\t * eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any\r\n\t\t * left-going edges already processed, then eTopLeft must be the edge\r\n\t\t * such that an imaginary upward vertical segment from vOrg would be\r\n\t\t * contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft\r\n\t\t * should be NULL.\r\n\t\t */\r\n\t\tvar reg, regPrev;\r\n\t\tvar e, ePrev;\r\n\t\tvar firstTime = true;\r\n\r\n\t\t/* Insert the new right-going edges in the dictionary */\r\n\t\te = eFirst;\r\n\t\tdo {\r\n\t\t\tassert(Geom.vertLeq(e.Org, e.Dst));\r\n\t\t\tSweep.addRegionBelow(tess, regUp, e.Sym);\r\n\t\t\te = e.Onext;\r\n\t\t} while (e !== eLast);\r\n\r\n\t\t/* Walk *all* right-going edges from e->Org, in the dictionary order,\r\n\t\t * updating the winding numbers of each region, and re-linking the mesh\r\n\t\t * edges to match the dictionary ordering (if necessary).\r\n\t\t */\r\n\t\tif (eTopLeft === null) {\r\n\t\t\teTopLeft = Sweep.regionBelow(regUp).eUp.Rprev;\r\n\t\t}\r\n\t\tregPrev = regUp;\r\n\t\tePrev = eTopLeft;\r\n\t\tfor (;;) {\r\n\t\t\treg = Sweep.regionBelow(regPrev);\r\n\t\t\te = reg.eUp.Sym;\r\n\t\t\tif (e.Org !== ePrev.Org) break;\r\n\r\n\t\t\tif (e.Onext !== ePrev) {\r\n\t\t\t\t/* Unlink e from its current position, and relink below ePrev */\r\n\t\t\t\ttess.mesh.splice(e.Oprev, e);\r\n\t\t\t\ttess.mesh.splice(ePrev.Oprev, e);\r\n\t\t\t}\r\n\t\t\t/* Compute the winding number and \"inside\" flag for the new regions */\r\n\t\t\treg.windingNumber = regPrev.windingNumber - e.winding;\r\n\t\t\treg.inside = Sweep.isWindingInside(tess, reg.windingNumber);\r\n\r\n\t\t\t/* Check for two outgoing edges with same slope -- process these\r\n\t\t\t * before any intersection tests (see example in tessComputeInterior).\r\n\t\t\t */\r\n\t\t\tregPrev.dirty = true;\r\n\t\t\tif (!firstTime && Sweep.checkForRightSplice(tess, regPrev)) {\r\n\t\t\t\tSweep.addWinding(e, ePrev);\r\n\t\t\t\tSweep.deleteRegion(tess, regPrev);\r\n\t\t\t\ttess.mesh.delete(ePrev);\r\n\t\t\t}\r\n\t\t\tfirstTime = false;\r\n\t\t\tregPrev = reg;\r\n\t\t\tePrev = e;\r\n\t\t}\r\n\t\tregPrev.dirty = true;\r\n\t\tassert(regPrev.windingNumber - e.winding === reg.windingNumber);\r\n\r\n\t\tif (cleanUp) {\r\n\t\t\t/* Check for intersections between newly adjacent edges. */\r\n\t\t\tSweep.walkDirtyRegions(tess, regPrev);\r\n\t\t}\r\n\t}\r\n\r\n\t//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )\r\n\tstatic spliceMergeVertices(tess: Tesselator, e1:TESShalfEdge, e2:TESShalfEdge) {\r\n\t\t/*\r\n\t\t * Two vertices with idential coordinates are combined into one.\r\n\t\t * e1->Org is kept, while e2->Org is discarded.\r\n\t\t */\r\n\t\ttess.mesh.splice(e1, e2);\r\n\t}\r\n\r\n\t//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )\r\n\tstatic vertexWeights(isect:TESSvertex, org:TESSvertex, dst: any) {\r\n\t\t/*\r\n\t\t * Find some weights which describe how the intersection vertex is\r\n\t\t * a linear combination of \"org\" and \"dest\".  Each of the two edges\r\n\t\t * which generated \"isect\" is allocated 50% of the weight; each edge\r\n\t\t * splits the weight between its org and dst according to the\r\n\t\t * relative distance to \"isect\".\r\n\t\t */\r\n\t\tvar t1 = Geom.vertL1dist(org, isect);\r\n\t\tvar t2 = Geom.vertL1dist(dst, isect);\r\n\t\tvar w0 = (0.5 * t2) / (t1 + t2);\r\n\t\tvar w1 = (0.5 * t1) / (t1 + t2);\r\n\t\tisect.coords[0] += w0 * org.coords[0] + w1 * dst.coords[0];\r\n\t\tisect.coords[1] += w0 * org.coords[1] + w1 * dst.coords[1];\r\n\t\tisect.coords[2] += w0 * org.coords[2] + w1 * dst.coords[2];\r\n\t}\r\n\r\n\t//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )\r\n\tstatic getIntersectData(tess: Tesselator, isect:TESSvertex, orgUp:TESSvertex, dstUp:TESSvertex, orgLo:TESSvertex, dstLo:TESSvertex) {\r\n\t\t/*\r\n\t\t * We've computed a new intersection point, now we need a \"data\" pointer\r\n\t\t * from the user so that we can refer to this new vertex in the\r\n\t\t * rendering callbacks.\r\n\t\t */\r\n\t\tisect.coords[0] = isect.coords[1] = isect.coords[2] = 0;\r\n\t\tisect.idx = -1;\r\n\t\tSweep.vertexWeights(isect, orgUp, dstUp);\r\n\t\tSweep.vertexWeights(isect, orgLo, dstLo);\r\n\t}\r\n\r\n\t//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )\r\n\tstatic checkForRightSplice(tess:Tesselator, regUp:ActiveRegion) {\r\n\t\t/*\r\n\t\t * Check the upper and lower edge of \"regUp\", to make sure that the\r\n\t\t * eUp->Org is above eLo, or eLo->Org is below eUp (depending on which\r\n\t\t * origin is leftmost).\r\n\t\t *\r\n\t\t * The main purpose is to splice right-going edges with the same\r\n\t\t * dest vertex and nearly identical slopes (ie. we can't distinguish\r\n\t\t * the slopes numerically).  However the splicing can also help us\r\n\t\t * to recover from numerical errors.  For example, suppose at one\r\n\t\t * point we checked eUp and eLo, and decided that eUp->Org is barely\r\n\t\t * above eLo.  Then later, we split eLo into two edges (eg. from\r\n\t\t * a splice operation like this one).  This can change the result of\r\n\t\t * our test so that now eUp->Org is incident to eLo, or barely below it.\r\n\t\t * We must correct this condition to maintain the dictionary invariants.\r\n\t\t *\r\n\t\t * One possibility is to check these edges for intersection again\r\n\t\t * (ie. CheckForIntersect).  This is what we do if possible.  However\r\n\t\t * CheckForIntersect requires that tess->event lies between eUp and eLo,\r\n\t\t * so that it has something to fall back on when the intersection\r\n\t\t * calculation gives us an unusable answer.  So, for those cases where\r\n\t\t * we can't check for intersection, this routine fixes the problem\r\n\t\t * by just splicing the offending vertex into the other edge.\r\n\t\t * This is a guaranteed solution, no matter how degenerate things get.\r\n\t\t * Basically this is a combinatorial solution to a numerical problem.\r\n\t\t */\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\r\n\t\tif (Geom.vertLeq(eUp.Org, eLo.Org)) {\r\n\t\t\tif (Geom.edgeSign(eLo.Dst, eUp.Org, eLo.Org) > 0) return false;\r\n\r\n\t\t\t/* eUp->Org appears to be below eLo */\r\n\t\t\tif (!Geom.vertEq(eUp.Org, eLo.Org)) {\r\n\t\t\t\t/* Splice eUp->Org into eLo */\r\n\t\t\t\ttess.mesh.splitEdge(eLo.Sym);\r\n\t\t\t\ttess.mesh.splice(eUp, eLo.Oprev);\r\n\t\t\t\tregUp.dirty = regLo.dirty = true;\r\n\t\t\t} else if (eUp.Org !== eLo.Org) {\r\n\t\t\t\t/* merge the two vertices, discarding eUp->Org */\r\n\t\t\t\ttess.pq.delete(eUp.Org.pqHandle);\r\n\t\t\t\tSweep.spliceMergeVertices(tess, eLo.Oprev, eUp);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (Geom.edgeSign(eUp.Dst, eLo.Org, eUp.Org) < 0) return false;\r\n\r\n\t\t\t/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */\r\n\t\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n\t\t\ttess.mesh.splitEdge(eUp.Sym);\r\n\t\t\ttess.mesh.splice(eLo.Oprev, eUp);\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )\r\n\tstatic checkForLeftSplice(tess: Tesselator, regUp: ActiveRegion) {\r\n\t\t/*\r\n\t\t * Check the upper and lower edge of \"regUp\", to make sure that the\r\n\t\t * eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which\r\n\t\t * destination is rightmost).\r\n\t\t *\r\n\t\t * Theoretically, this should always be true.  However, splitting an edge\r\n\t\t * into two pieces can change the results of previous tests.  For example,\r\n\t\t * suppose at one point we checked eUp and eLo, and decided that eUp->Dst\r\n\t\t * is barely above eLo.  Then later, we split eLo into two edges (eg. from\r\n\t\t * a splice operation like this one).  This can change the result of\r\n\t\t * the test so that now eUp->Dst is incident to eLo, or barely below it.\r\n\t\t * We must correct this condition to maintain the dictionary invariants\r\n\t\t * (otherwise new edges might get inserted in the wrong place in the\r\n\t\t * dictionary, and bad stuff will happen).\r\n\t\t *\r\n\t\t * We fix the problem by just splicing the offending vertex into the\r\n\t\t * other edge.\r\n\t\t */\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\t\tvar e;\r\n\r\n\t\tassert(!Geom.vertEq(eUp.Dst, eLo.Dst));\r\n\r\n\t\tif (Geom.vertLeq(eUp.Dst, eLo.Dst)) {\r\n\t\t\tif (Geom.edgeSign(eUp.Dst, eLo.Dst, eUp.Org) < 0) return false;\r\n\r\n\t\t\t/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */\r\n\t\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n\t\t\te = tess.mesh.splitEdge(eUp);\r\n\t\t\ttess.mesh.splice(eLo.Sym, e);\r\n\t\t\te.Lface.inside = regUp.inside;\r\n\t\t} else {\r\n\t\t\tif (Geom.edgeSign(eLo.Dst, eUp.Dst, eLo.Org) > 0) return false;\r\n\r\n\t\t\t/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */\r\n\t\t\tregUp.dirty = regLo.dirty = true;\r\n\t\t\te = tess.mesh.splitEdge(eLo);\r\n\t\t\ttess.mesh.splice(eUp.Lnext, eLo.Sym);\r\n\t\t\te.Rface.inside = regUp.inside;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )\r\n\tstatic checkForIntersect(tess: Tesselator, regUp: ActiveRegion) {\r\n\t\t/*\r\n\t\t * Check the upper and lower edges of the given region to see if\r\n\t\t * they intersect.  If so, create the intersection and add it\r\n\t\t * to the data structures.\r\n\t\t *\r\n\t\t * Returns TRUE if adding the new intersection resulted in a recursive\r\n\t\t * call to AddRightEdges(); in this case all \"dirty\" regions have been\r\n\t\t * checked for intersections, and possibly regUp has been deleted.\r\n\t\t */\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\t\tvar orgUp = eUp.Org;\r\n\t\tvar orgLo = eLo.Org;\r\n\t\tvar dstUp = eUp.Dst;\r\n\t\tvar dstLo = eLo.Dst;\r\n\t\tvar tMinUp, tMaxLo;\r\n\t\tvar isect = new TESSvertex(),\r\n\t\t\torgMin;\r\n\t\tvar e;\r\n\r\n\t\tassert(!Geom.vertEq(dstLo, dstUp));\r\n\t\tassert(Geom.edgeSign(dstUp, tess.event, orgUp) <= 0);\r\n\t\tassert(Geom.edgeSign(dstLo, tess.event, orgLo) >= 0);\r\n\t\tassert(orgUp !== tess.event && orgLo !== tess.event);\r\n\t\tassert(!regUp.fixUpperEdge && !regLo.fixUpperEdge);\r\n\r\n\t\tif (orgUp === orgLo) return false; /* right endpoints are the same */\r\n\r\n\t\ttMinUp = Math.min(orgUp.t, dstUp.t);\r\n\t\ttMaxLo = Math.max(orgLo.t, dstLo.t);\r\n\t\tif (tMinUp > tMaxLo) return false; /* t ranges do not overlap */\r\n\r\n\t\tif (Geom.vertLeq(orgUp, orgLo)) {\r\n\t\t\tif (Geom.edgeSign(dstLo, orgUp, orgLo) > 0) return false;\r\n\t\t} else {\r\n\t\t\tif (Geom.edgeSign(dstUp, orgLo, orgUp) < 0) return false;\r\n\t\t}\r\n\r\n\t\t/* At this point the edges intersect, at least marginally */\r\n\t\tSweep.debugEvent(tess);\r\n\r\n\t\tGeom.intersect(dstUp, orgUp, dstLo, orgLo, isect);\r\n\t\t/* The following properties are guaranteed: */\r\n\t\tassert(Math.min(orgUp.t, dstUp.t) <= isect.t);\r\n\t\tassert(isect.t <= Math.max(orgLo.t, dstLo.t));\r\n\t\tassert(Math.min(dstLo.s, dstUp.s) <= isect.s);\r\n\t\tassert(isect.s <= Math.max(orgLo.s, orgUp.s));\r\n\r\n\t\tif (Geom.vertLeq(isect, tess.event)) {\r\n\t\t\t/* The intersection point lies slightly to the left of the sweep line,\r\n\t\t\t * so move it until it''s slightly to the right of the sweep line.\r\n\t\t\t * (If we had perfect numerical precision, this would never happen\r\n\t\t\t * in the first place).  The easiest and safest thing to do is\r\n\t\t\t * replace the intersection by tess->event.\r\n\t\t\t */\r\n\t\t\tisect.s = tess.event.s;\r\n\t\t\tisect.t = tess.event.t;\r\n\t\t}\r\n\t\t/* Similarly, if the computed intersection lies to the right of the\r\n\t\t * rightmost origin (which should rarely happen), it can cause\r\n\t\t * unbelievable inefficiency on sufficiently degenerate inputs.\r\n\t\t * (If you have the test program, try running test54.d with the\r\n\t\t * \"X zoom\" option turned on).\r\n\t\t */\r\n\t\torgMin = Geom.vertLeq(orgUp, orgLo) ? orgUp : orgLo;\r\n\t\tif (Geom.vertLeq(orgMin, isect)) {\r\n\t\t\tisect.s = orgMin.s;\r\n\t\t\tisect.t = orgMin.t;\r\n\t\t}\r\n\r\n\t\tif (Geom.vertEq(isect, orgUp) || Geom.vertEq(isect, orgLo)) {\r\n\t\t\t/* Easy case -- intersection at one of the right endpoints */\r\n\t\t\tSweep.checkForRightSplice(tess, regUp);\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif (\r\n\t\t\t(!Geom.vertEq(dstUp, tess.event) &&\r\n\t\t\t\tGeom.edgeSign(dstUp, tess.event, isect) >= 0) ||\r\n\t\t\t(!Geom.vertEq(dstLo, tess.event) &&\r\n\t\t\t\tGeom.edgeSign(dstLo, tess.event, isect) <= 0)\r\n\t\t) {\r\n\t\t\t/* Very unusual -- the new upper or lower edge would pass on the\r\n\t\t\t * wrong side of the sweep event, or through it.  This can happen\r\n\t\t\t * due to very small numerical errors in the intersection calculation.\r\n\t\t\t */\r\n\t\t\tif (dstLo === tess.event) {\r\n\t\t\t\t/* Splice dstLo into eUp, and process the new region(s) */\r\n\t\t\t\ttess.mesh.splitEdge(eUp.Sym);\r\n\t\t\t\ttess.mesh.splice(eLo.Sym, eUp);\r\n\t\t\t\tregUp = Sweep.topLeftRegion(tess, regUp);\r\n\t\t\t\t//\t\t\tif (regUp == NULL) longjmp(tess->env,1);\r\n\t\t\t\teUp = Sweep.regionBelow(regUp).eUp;\r\n\t\t\t\tSweep.finishLeftRegions(tess, Sweep.regionBelow(regUp), regLo);\r\n\t\t\t\tSweep.addRightEdges(tess, regUp, eUp.Oprev, eUp, eUp, true);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tif (dstUp === tess.event) {\r\n\t\t\t\t/* Splice dstUp into eLo, and process the new region(s) */\r\n\t\t\t\ttess.mesh.splitEdge(eLo.Sym);\r\n\t\t\t\ttess.mesh.splice(eUp.Lnext, eLo.Oprev);\r\n\t\t\t\tregLo = regUp;\r\n\t\t\t\tregUp = Sweep.topRightRegion(regUp);\r\n\t\t\t\te = Sweep.regionBelow(regUp).eUp.Rprev;\r\n\t\t\t\tregLo.eUp = eLo.Oprev;\r\n\t\t\t\teLo = Sweep.finishLeftRegions(tess, regLo, null);\r\n\t\t\t\tSweep.addRightEdges(tess, regUp, eLo.Onext, eUp.Rprev, e, true);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\t/* Special case: called from ConnectRightVertex.  If either\r\n\t\t\t * edge passes on the wrong side of tess->event, split it\r\n\t\t\t * (and wait for ConnectRightVertex to splice it appropriately).\r\n\t\t\t */\r\n\t\t\tif (Geom.edgeSign(dstUp, tess.event, isect) >= 0) {\r\n\t\t\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = true;\r\n\t\t\t\ttess.mesh.splitEdge(eUp.Sym);\r\n\t\t\t\teUp.Org.s = tess.event.s;\r\n\t\t\t\teUp.Org.t = tess.event.t;\r\n\t\t\t}\r\n\t\t\tif (Geom.edgeSign(dstLo, tess.event, isect) <= 0) {\r\n\t\t\t\tregUp.dirty = regLo.dirty = true;\r\n\t\t\t\ttess.mesh.splitEdge(eLo.Sym);\r\n\t\t\t\teLo.Org.s = tess.event.s;\r\n\t\t\t\teLo.Org.t = tess.event.t;\r\n\t\t\t}\r\n\t\t\t/* leave the rest for ConnectRightVertex */\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* General case -- split both edges, splice into new vertex.\r\n\t\t * When we do the splice operation, the order of the arguments is\r\n\t\t * arbitrary as far as correctness goes.  However, when the operation\r\n\t\t * creates a new face, the work done is proportional to the size of\r\n\t\t * the new face.  We expect the faces in the processed part of\r\n\t\t * the mesh (ie. eUp->Lface) to be smaller than the faces in the\r\n\t\t * unprocessed original contours (which will be eLo->Oprev->Lface).\r\n\t\t */\r\n\t\ttess.mesh.splitEdge(eUp.Sym);\r\n\t\ttess.mesh.splitEdge(eLo.Sym);\r\n\t\ttess.mesh.splice(eLo.Oprev, eUp);\r\n\t\teUp.Org.s = isect.s;\r\n\t\teUp.Org.t = isect.t;\r\n\t\teUp.Org.pqHandle = tess.pq.insert(eUp.Org);\r\n\t\tSweep.getIntersectData(tess, eUp.Org, orgUp, dstUp, orgLo, dstLo);\r\n\t\tSweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\t//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )\r\n\tstatic walkDirtyRegions(tess: Tesselator, regUp: ActiveRegion) {\r\n\t\t/*\r\n\t\t * When the upper or lower edge of any region changes, the region is\r\n\t\t * marked \"dirty\".  This routine walks through all the dirty regions\r\n\t\t * and makes sure that the dictionary invariants are satisfied\r\n\t\t * (see the comments at the beginning of this file).  Of course\r\n\t\t * new dirty regions can be created as we make changes to restore\r\n\t\t * the invariants.\r\n\t\t */\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp, eLo;\r\n\r\n\t\tfor (;;) {\r\n\t\t\t/* Find the lowest dirty region (we walk from the bottom up). */\r\n\t\t\twhile (regLo.dirty) {\r\n\t\t\t\tregUp = regLo;\r\n\t\t\t\tregLo = Sweep.regionBelow(regLo);\r\n\t\t\t}\r\n\t\t\tif (!regUp.dirty) {\r\n\t\t\t\tregLo = regUp;\r\n\t\t\t\tregUp = Sweep.regionAbove(regUp);\r\n\t\t\t\tif (regUp === null || !regUp.dirty) {\r\n\t\t\t\t\t/* We've walked all the dirty regions */\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tregUp.dirty = false;\r\n\t\t\teUp = regUp.eUp;\r\n\t\t\teLo = regLo.eUp;\r\n\r\n\t\t\tif (eUp.Dst !== eLo.Dst) {\r\n\t\t\t\t/* Check that the edge ordering is obeyed at the Dst vertices. */\r\n\t\t\t\tif (Sweep.checkForLeftSplice(tess, regUp)) {\r\n\t\t\t\t\t/* If the upper or lower edge was marked fixUpperEdge, then\r\n\t\t\t\t\t * we no longer need it (since these edges are needed only for\r\n\t\t\t\t\t * vertices which otherwise have no right-going edges).\r\n\t\t\t\t\t */\r\n\t\t\t\t\tif (regLo.fixUpperEdge) {\r\n\t\t\t\t\t\tSweep.deleteRegion(tess, regLo);\r\n\t\t\t\t\t\ttess.mesh.delete(eLo);\r\n\t\t\t\t\t\tregLo = Sweep.regionBelow(regUp);\r\n\t\t\t\t\t\teLo = regLo.eUp;\r\n\t\t\t\t\t} else if (regUp.fixUpperEdge) {\r\n\t\t\t\t\t\tSweep.deleteRegion(tess, regUp);\r\n\t\t\t\t\t\ttess.mesh.delete(eUp);\r\n\t\t\t\t\t\tregUp = Sweep.regionAbove(regLo);\r\n\t\t\t\t\t\teUp = regUp.eUp;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (eUp.Org !== eLo.Org) {\r\n\t\t\t\tif (\r\n\t\t\t\t\teUp.Dst !== eLo.Dst &&\r\n\t\t\t\t\t!regUp.fixUpperEdge &&\r\n\t\t\t\t\t!regLo.fixUpperEdge &&\r\n\t\t\t\t\t(eUp.Dst === tess.event || eLo.Dst === tess.event)\r\n\t\t\t\t) {\r\n\t\t\t\t\t/* When all else fails in CheckForIntersect(), it uses tess->event\r\n\t\t\t\t\t * as the intersection location.  To make this possible, it requires\r\n\t\t\t\t\t * that tess->event lie between the upper and lower edges, and also\r\n\t\t\t\t\t * that neither of these is marked fixUpperEdge (since in the worst\r\n\t\t\t\t\t * case it might splice one of these edges into tess->event, and\r\n\t\t\t\t\t * violate the invariant that fixable edges are the only right-going\r\n\t\t\t\t\t * edge from their associated vertex).\r\n\t\t\t\t\t */\r\n\t\t\t\t\tif (Sweep.checkForIntersect(tess, regUp)) {\r\n\t\t\t\t\t\t/* WalkDirtyRegions() was called recursively; we're done */\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t/* Even though we can't use CheckForIntersect(), the Org vertices\r\n\t\t\t\t\t * may violate the dictionary edge ordering.  Check and correct this.\r\n\t\t\t\t\t */\r\n\t\t\t\t\tSweep.checkForRightSplice(tess, regUp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (eUp.Org === eLo.Org && eUp.Dst === eLo.Dst) {\r\n\t\t\t\t/* A degenerate loop consisting of only two edges -- delete it. */\r\n\t\t\t\tSweep.addWinding(eLo, eUp);\r\n\t\t\t\tSweep.deleteRegion(tess, regUp);\r\n\t\t\t\ttess.mesh.delete(eUp);\r\n\t\t\t\tregUp = Sweep.regionAbove(regLo);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )\r\n\tstatic connectRightVertex(tess: Tesselator, regUp: ActiveRegion, eBottomLeft: TESShalfEdge) {\r\n\t\t/*\r\n\t\t * Purpose: connect a \"right\" vertex vEvent (one where all edges go left)\r\n\t\t * to the unprocessed portion of the mesh.  Since there are no right-going\r\n\t\t * edges, two regions (one above vEvent and one below) are being merged\r\n\t\t * into one.  \"regUp\" is the upper of these two regions.\r\n\t\t *\r\n\t\t * There are two reasons for doing this (adding a right-going edge):\r\n\t\t *  - if the two regions being merged are \"inside\", we must add an edge\r\n\t\t *    to keep them separated (the combined region would not be monotone).\r\n\t\t *  - in any case, we must leave some record of vEvent in the dictionary,\r\n\t\t *    so that we can merge vEvent with features that we have not seen yet.\r\n\t\t *    For example, maybe there is a vertical edge which passes just to\r\n\t\t *    the right of vEvent; we would like to splice vEvent into this edge.\r\n\t\t *\r\n\t\t * However, we don't want to connect vEvent to just any vertex.  We don''t\r\n\t\t * want the new edge to cross any other edges; otherwise we will create\r\n\t\t * intersection vertices even when the input data had no self-intersections.\r\n\t\t * (This is a bad thing; if the user's input data has no intersections,\r\n\t\t * we don't want to generate any false intersections ourselves.)\r\n\t\t *\r\n\t\t * Our eventual goal is to connect vEvent to the leftmost unprocessed\r\n\t\t * vertex of the combined region (the union of regUp and regLo).\r\n\t\t * But because of unseen vertices with all right-going edges, and also\r\n\t\t * new vertices which may be created by edge intersections, we don''t\r\n\t\t * know where that leftmost unprocessed vertex is.  In the meantime, we\r\n\t\t * connect vEvent to the closest vertex of either chain, and mark the region\r\n\t\t * as \"fixUpperEdge\".  This flag says to delete and reconnect this edge\r\n\t\t * to the next processed vertex on the boundary of the combined region.\r\n\t\t * Quite possibly the vertex we connected to will turn out to be the\r\n\t\t * closest one, in which case we won''t need to make any changes.\r\n\t\t */\r\n\t\tvar eNew;\r\n\t\tvar eTopLeft = eBottomLeft.Onext;\r\n\t\tvar regLo = Sweep.regionBelow(regUp);\r\n\t\tvar eUp = regUp.eUp;\r\n\t\tvar eLo = regLo.eUp;\r\n\t\tvar degenerate = false;\r\n\r\n\t\tif (eUp.Dst !== eLo.Dst) {\r\n\t\t\tSweep.checkForIntersect(tess, regUp);\r\n\t\t}\r\n\r\n\t\t/* Possible new degeneracies: upper or lower edge of regUp may pass\r\n\t\t * through vEvent, or may coincide with new intersection vertex\r\n\t\t */\r\n\t\tif (Geom.vertEq(eUp.Org, tess.event)) {\r\n\t\t\ttess.mesh.splice(eTopLeft.Oprev, eUp);\r\n\t\t\tregUp = Sweep.topLeftRegion(tess, regUp);\r\n\t\t\teTopLeft = Sweep.regionBelow(regUp).eUp;\r\n\t\t\tSweep.finishLeftRegions(tess, Sweep.regionBelow(regUp), regLo);\r\n\t\t\tdegenerate = true;\r\n\t\t}\r\n\t\tif (Geom.vertEq(eLo.Org, tess.event)) {\r\n\t\t\ttess.mesh.splice(eBottomLeft, eLo.Oprev);\r\n\t\t\teBottomLeft = Sweep.finishLeftRegions(tess, regLo, null);\r\n\t\t\tdegenerate = true;\r\n\t\t}\r\n\t\tif (degenerate) {\r\n\t\t\tSweep.addRightEdges(\r\n\t\t\t\ttess,\r\n\t\t\t\tregUp,\r\n\t\t\t\teBottomLeft.Onext,\r\n\t\t\t\teTopLeft,\r\n\t\t\t\teTopLeft,\r\n\t\t\t\ttrue,\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Non-degenerate situation -- need to add a temporary, fixable edge.\r\n\t\t * Connect to the closer of eLo->Org, eUp->Org.\r\n\t\t */\r\n\t\tif (Geom.vertLeq(eLo.Org, eUp.Org)) {\r\n\t\t\teNew = eLo.Oprev;\r\n\t\t} else {\r\n\t\t\teNew = eUp;\r\n\t\t}\r\n\t\teNew = tess.mesh.connect(eBottomLeft.Lprev, eNew);\r\n\r\n\t\t/* Prevent cleanup, otherwise eNew might disappear before we've even\r\n\t\t * had a chance to mark it as a temporary edge.\r\n\t\t */\r\n\t\tSweep.addRightEdges(tess, regUp, eNew, eNew.Onext, eNew.Onext, false);\r\n\t\teNew.Sym.activeRegion.fixUpperEdge = true;\r\n\t\tSweep.walkDirtyRegions(tess, regUp);\r\n\t}\r\n\r\n\t/* Because vertices at exactly the same location are merged together\r\n\t * before we process the sweep event, some degenerate cases can't occur.\r\n\t * However if someone eventually makes the modifications required to\r\n\t * merge features which are close together, the cases below marked\r\n\t * TOLERANCE_NONZERO will be useful.  They were debugged before the\r\n\t * code to merge identical vertices in the main loop was added.\r\n\t */\r\n\t//#define TOLERANCE_NONZERO\tFALSE\r\n\r\n\t//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )\r\n\tstatic connectLeftDegenerate(tess: Tesselator, regUp: ActiveRegion, vEvent: TESSvertex) {\r\n\t\t/*\r\n\t\t * The event vertex lies exacty on an already-processed edge or vertex.\r\n\t\t * Adding the new vertex involves splicing it into the already-processed\r\n\t\t * part of the mesh.\r\n\t\t */\r\n\t\tvar e, eTopLeft, eTopRight, eLast;\r\n\t\tvar reg;\r\n\r\n\t\te = regUp.eUp;\r\n\t\tif (Geom.vertEq(e.Org, vEvent)) {\r\n\t\t\t/* e->Org is an unprocessed vertex - just combine them, and wait\r\n\t\t\t * for e->Org to be pulled from the queue\r\n\t\t\t */\r\n\t\t\tassert(false /*TOLERANCE_NONZERO*/);\r\n\t\t\tSweep.spliceMergeVertices(tess, e, vEvent.anEdge);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!Geom.vertEq(e.Dst, vEvent)) {\r\n\t\t\t/* General case -- splice vEvent into edge e which passes through it */\r\n\t\t\ttess.mesh.splitEdge(e.Sym);\r\n\t\t\tif (regUp.fixUpperEdge) {\r\n\t\t\t\t/* This edge was fixable -- delete unused portion of original edge */\r\n\t\t\t\ttess.mesh.delete(e.Onext);\r\n\t\t\t\tregUp.fixUpperEdge = false;\r\n\t\t\t}\r\n\t\t\ttess.mesh.splice(vEvent.anEdge, e);\r\n\t\t\tSweep.sweepEvent(tess, vEvent); /* recurse */\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* vEvent coincides with e->Dst, which has already been processed.\r\n\t\t * Splice in the additional right-going edges.\r\n\t\t */\r\n\t\tassert(false /*TOLERANCE_NONZERO*/);\r\n\t\tregUp = Sweep.topRightRegion(regUp);\r\n\t\treg = Sweep.regionBelow(regUp);\r\n\t\teTopRight = reg.eUp.Sym;\r\n\t\teTopLeft = eLast = eTopRight.Onext;\r\n\t\tif (reg.fixUpperEdge) {\r\n\t\t\t/* Here e->Dst has only a single fixable edge going right.\r\n\t\t\t * We can delete it since now we have some real right-going edges.\r\n\t\t\t */\r\n\t\t\tassert(eTopLeft !== eTopRight); /* there are some left edges too */\r\n\t\t\tSweep.deleteRegion(tess, reg);\r\n\t\t\ttess.mesh.delete(eTopRight);\r\n\t\t\teTopRight = eTopLeft.Oprev;\r\n\t\t}\r\n\t\ttess.mesh.splice(vEvent.anEdge, eTopRight);\r\n\t\tif (!Geom.edgeGoesLeft(eTopLeft)) {\r\n\t\t\t/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */\r\n\t\t\teTopLeft = null;\r\n\t\t}\r\n\t\tSweep.addRightEdges(\r\n\t\t\ttess,\r\n\t\t\tregUp,\r\n\t\t\teTopRight.Onext,\r\n\t\t\teLast,\r\n\t\t\teTopLeft,\r\n\t\t\ttrue,\r\n\t\t);\r\n\t}\r\n\r\n\t//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )\r\n\tstatic connectLeftVertex(tess: Tesselator, vEvent: TESSvertex) {\r\n\t\t/*\r\n\t\t * Purpose: connect a \"left\" vertex (one where both edges go right)\r\n\t\t * to the processed portion of the mesh.  Let R be the active region\r\n\t\t * containing vEvent, and let U and L be the upper and lower edge\r\n\t\t * chains of R.  There are two possibilities:\r\n\t\t *\r\n\t\t * - the normal case: split R into two regions, by connecting vEvent to\r\n\t\t *   the rightmost vertex of U or L lying to the left of the sweep line\r\n\t\t *\r\n\t\t * - the degenerate case: if vEvent is close enough to U or L, we\r\n\t\t *   merge vEvent into that edge chain.  The subcases are:\r\n\t\t *\t- merging with the rightmost vertex of U or L\r\n\t\t *\t- merging with the active edge of U or L\r\n\t\t *\t- merging with an already-processed portion of U or L\r\n\t\t */\r\n\t\tvar regUp, regLo, reg;\r\n\t\tvar eUp, eLo, eNew;\r\n\t\tvar tmp = new ActiveRegion();\r\n\r\n\t\t/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */\r\n\r\n\t\t/* Get a pointer to the active region containing vEvent */\r\n\t\ttmp.eUp = vEvent.anEdge.Sym; /* tessDictListSearch */\r\n\t\t/* __GL_DICTLISTKEY */ regUp = tess.dict.search(tmp).key;\r\n\t\tregLo = Sweep.regionBelow(regUp);\r\n\t\tif (!regLo) {\r\n\t\t\t// This may happen if the input polygon is coplanar.\r\n\t\t\treturn;\r\n\t\t}\r\n\t\teUp = regUp.eUp;\r\n\t\teLo = regLo.eUp;\r\n\r\n\t\t/* Try merging with U or L first */\r\n\t\tif (Geom.edgeSign(eUp.Dst, vEvent, eUp.Org) === 0.0) {\r\n\t\t\tSweep.connectLeftDegenerate(tess, regUp, vEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Connect vEvent to rightmost processed vertex of either chain.\r\n\t\t * e->Dst is the vertex that we will connect to vEvent.\r\n\t\t */\r\n\t\treg = Geom.vertLeq(eLo.Dst, eUp.Dst) ? regUp : regLo;\r\n\r\n\t\tif (regUp.inside || reg.fixUpperEdge) {\r\n\t\t\tif (reg === regUp) {\r\n\t\t\t\teNew = tess.mesh.connect(vEvent.anEdge.Sym, eUp.Lnext);\r\n\t\t\t} else {\r\n\t\t\t\tvar tempHalfEdge = tess.mesh.connect(eLo.Dnext, vEvent.anEdge);\r\n\t\t\t\teNew = tempHalfEdge.Sym;\r\n\t\t\t}\r\n\t\t\tif (reg.fixUpperEdge) {\r\n\t\t\t\tSweep.fixUpperEdge(tess, reg, eNew);\r\n\t\t\t} else {\r\n\t\t\t\tSweep.computeWinding(\r\n\t\t\t\t\ttess,\r\n\t\t\t\t\tSweep.addRegionBelow(tess, regUp, eNew),\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\tSweep.sweepEvent(tess, vEvent);\r\n\t\t} else {\r\n\t\t\t/* The new vertex is in a region which does not belong to the polygon.\r\n\t\t\t * We don''t need to connect this vertex to the rest of the mesh.\r\n\t\t\t */\r\n\t\t\tSweep.addRightEdges(\r\n\t\t\t\ttess,\r\n\t\t\t\tregUp,\r\n\t\t\t\tvEvent.anEdge,\r\n\t\t\t\tvEvent.anEdge,\r\n\t\t\t\tnull,\r\n\t\t\t\ttrue,\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )\r\n\tstatic sweepEvent(tess: Tesselator, vEvent: TESSvertex) {\r\n\t\t/*\r\n\t\t * Does everything necessary when the sweep line crosses a vertex.\r\n\t\t * Updates the mesh and the edge dictionary.\r\n\t\t */\r\n\r\n\t\ttess.event = vEvent; /* for access in EdgeLeq() */\r\n\t\tSweep.debugEvent(tess);\r\n\r\n\t\t/* Check if this vertex is the right endpoint of an edge that is\r\n\t\t * already in the dictionary.  In this case we don't need to waste\r\n\t\t * time searching for the location to insert new edges.\r\n\t\t */\r\n\t\tvar e = vEvent.anEdge;\r\n\t\twhile (e.activeRegion === null) {\r\n\t\t\te = e.Onext;\r\n\t\t\tif (e === vEvent.anEdge) {\r\n\t\t\t\t/* All edges go right -- not incident to any processed edges */\r\n\t\t\t\tSweep.connectLeftVertex(tess, vEvent);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Processing consists of two phases: first we \"finish\" all the\r\n\t\t * active regions where both the upper and lower edges terminate\r\n\t\t * at vEvent (ie. vEvent is closing off these regions).\r\n\t\t * We mark these faces \"inside\" or \"outside\" the polygon according\r\n\t\t * to their winding number, and delete the edges from the dictionary.\r\n\t\t * This takes care of all the left-going edges from vEvent.\r\n\t\t */\r\n\t\tvar regUp = Sweep.topLeftRegion(tess, e.activeRegion);\r\n\t\tassert(regUp !== null);\r\n\t\t//\tif (regUp == NULL) longjmp(tess->env,1);\r\n\t\tvar reg = Sweep.regionBelow(regUp);\r\n\t\tvar eTopLeft = reg.eUp;\r\n\t\tvar eBottomLeft = Sweep.finishLeftRegions(tess, reg, null);\r\n\r\n\t\t/* Next we process all the right-going edges from vEvent.  This\r\n\t\t * involves adding the edges to the dictionary, and creating the\r\n\t\t * associated \"active regions\" which record information about the\r\n\t\t * regions between adjacent dictionary edges.\r\n\t\t */\r\n\t\tif (eBottomLeft.Onext === eTopLeft) {\r\n\t\t\t/* No right-going edges -- add a temporary \"fixable\" edge */\r\n\t\t\tSweep.connectRightVertex(tess, regUp, eBottomLeft);\r\n\t\t} else {\r\n\t\t\tSweep.addRightEdges(\r\n\t\t\t\ttess,\r\n\t\t\t\tregUp,\r\n\t\t\t\teBottomLeft.Onext,\r\n\t\t\t\teTopLeft,\r\n\t\t\t\teTopLeft,\r\n\t\t\t\ttrue,\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/* Make the sentinel coordinates big enough that they will never be\r\n\t * merged with real input features.\r\n\t */\r\n\r\n\t//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )\r\n\tstatic addSentinel(tess: Tesselator, smin: number, smax: number, t: number) {\r\n\t\t/*\r\n\t\t * We add two sentinel edges above and below all other edges,\r\n\t\t * to avoid special cases at the top and bottom.\r\n\t\t */\r\n\t\tvar reg = new ActiveRegion();\r\n\t\tvar e = tess.mesh.makeEdge();\r\n\t\t//\tif (e == NULL) longjmp(tess->env,1);\r\n\r\n\t\te.Org.s = smax;\r\n\t\te.Org.t = t;\r\n\t\te.Dst.s = smin;\r\n\t\te.Dst.t = t;\r\n\t\ttess.event = e.Dst; /* initialize it */\r\n\r\n\t\treg.eUp = e;\r\n\t\treg.windingNumber = 0;\r\n\t\treg.inside = false;\r\n\t\treg.fixUpperEdge = false;\r\n\t\treg.sentinel = true;\r\n\t\treg.dirty = false;\r\n\t\treg.nodeUp = tess.dict.insert(reg);\r\n\t\t//\tif (reg->nodeUp == NULL) longjmp(tess->env,1);\r\n\t}\r\n\r\n\t//static void InitEdgeDict( TESStesselator *tess )\r\n\tstatic initEdgeDict(tess: Tesselator) {\r\n\t\t/*\r\n\t\t * We maintain an ordering of edge intersections with the sweep line.\r\n\t\t * This order is maintained in a dynamic dictionary.\r\n\t\t */\r\n\t\ttess.dict = new Dict(tess, Sweep.edgeLeq);\r\n\t\t//\tif (tess->dict == NULL) longjmp(tess->env,1);\r\n\r\n\t\tvar w = tess.bmax[0] - tess.bmin[0];\r\n\t\tvar h = tess.bmax[1] - tess.bmin[1];\r\n\r\n\t\tvar smin = tess.bmin[0] - w;\r\n\t\tvar smax = tess.bmax[0] + w;\r\n\t\tvar tmin = tess.bmin[1] - h;\r\n\t\tvar tmax = tess.bmax[1] + h;\r\n\r\n\t\tSweep.addSentinel(tess, smin, smax, tmin);\r\n\t\tSweep.addSentinel(tess, smin, smax, tmax);\r\n\t}\r\n\r\n\tstatic doneEdgeDict(tess: Tesselator) {\r\n\t\tvar reg;\r\n\t\tvar fixedEdges = 0;\r\n\r\n\t\twhile ((reg = tess.dict.min().key) !== null) {\r\n\t\t\t/*\r\n\t\t\t * At the end of all processing, the dictionary should contain\r\n\t\t\t * only the two sentinel edges, plus at most one \"fixable\" edge\r\n\t\t\t * created by ConnectRightVertex().\r\n\t\t\t */\r\n\t\t\tif (!reg.sentinel) {\r\n\t\t\t\tassert(reg.fixUpperEdge);\r\n\t\t\t\tassert(++fixedEdges === 1);\r\n\t\t\t}\r\n\t\t\tassert(reg.windingNumber === 0);\r\n\t\t\tSweep.deleteRegion(tess, reg);\r\n\t\t\t/*    tessMeshDelete( reg->eUp );*/\r\n\t\t}\r\n\t\t//\tdictDeleteDict( &tess->alloc, tess->dict );\r\n\t}\r\n\r\n\tstatic removeDegenerateEdges(tess:Tesselator) {\r\n\t\t/*\r\n\t\t * Remove zero-length edges, and contours with fewer than 3 vertices.\r\n\t\t */\r\n\t\tvar e, eNext, eLnext;\r\n\t\tvar eHead = tess.mesh.eHead;\r\n\r\n\t\t/*LINTED*/\r\n\t\tfor (e = eHead.next; e !== eHead; e = eNext) {\r\n\t\t\teNext = e.next;\r\n\t\t\teLnext = e.Lnext;\r\n\r\n\t\t\tif (Geom.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e) {\r\n\t\t\t\t/* Zero-length edge, contour has at least 3 edges */\r\n\t\t\t\tSweep.spliceMergeVertices(tess, eLnext, e); /* deletes e->Org */\r\n\t\t\t\ttess.mesh.delete(e); /* e is a self-loop */\r\n\t\t\t\te = eLnext;\r\n\t\t\t\teLnext = e.Lnext;\r\n\t\t\t}\r\n\t\t\tif (eLnext.Lnext === e) {\r\n\t\t\t\t/* Degenerate contour (one or two edges) */\r\n\t\t\t\tif (eLnext !== e) {\r\n\t\t\t\t\tif (eLnext === eNext || eLnext === eNext.Sym) {\r\n\t\t\t\t\t\teNext = eNext.next;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttess.mesh.delete(eLnext);\r\n\t\t\t\t}\r\n\t\t\t\tif (e === eNext || e === eNext.Sym) {\r\n\t\t\t\t\teNext = eNext.next;\r\n\t\t\t\t}\r\n\t\t\t\ttess.mesh.delete(e);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tstatic initPriorityQ(tess:Tesselator) {\r\n\t\t/*\r\n\t\t * Insert all vertices into the priority queue which determines the\r\n\t\t * order in which vertices cross the sweep line.\r\n\t\t */\r\n\t\tvar pq;\r\n\t\tvar v, vHead;\r\n\t\tvar vertexCount = 0;\r\n\r\n\t\tvHead = tess.mesh.vHead;\r\n\t\tfor (v = vHead.next; v !== vHead; v = v.next) {\r\n\t\t\tvertexCount++;\r\n\t\t}\r\n\t\t/* Make sure there is enough space for sentinels. */\r\n\t\tvertexCount += 8; //MAX( 8, tess->alloc.extraVertices );\r\n\r\n\t\tpq = tess.pq = new PriorityQ(vertexCount, Geom.vertLeq);\r\n\t\t//\tif (pq == NULL) return 0;\r\n\r\n\t\tvHead = tess.mesh.vHead;\r\n\t\tfor (v = vHead.next; v !== vHead; v = v.next) {\r\n\t\t\tv.pqHandle = pq.insert(v);\r\n\t\t\t//\t\tif (v.pqHandle == INV_HANDLE)\r\n\t\t\t//\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (v !== vHead) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tpq.init();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstatic donePriorityQ(tess: Tesselator) {\r\n\t\ttess.pq = null;\r\n\t}\r\n\r\n\tstatic removeDegenerateFaces(tess: Tesselator, mesh:TESSmesh) {\r\n\t\t/*\r\n\t\t * Delete any degenerate faces with only two edges.  WalkDirtyRegions()\r\n\t\t * will catch almost all of these, but it won't catch degenerate faces\r\n\t\t * produced by splice operations on already-processed edges.\r\n\t\t * The two places this can happen are in FinishLeftRegions(), when\r\n\t\t * we splice in a \"temporary\" edge produced by ConnectRightVertex(),\r\n\t\t * and in CheckForLeftSplice(), where we splice already-processed\r\n\t\t * edges to ensure that our dictionary invariants are not violated\r\n\t\t * by numerical errors.\r\n\t\t *\r\n\t\t * In both these cases it is *very* dangerous to delete the offending\r\n\t\t * edge at the time, since one of the routines further up the stack\r\n\t\t * will sometimes be keeping a pointer to that edge.\r\n\t\t */\r\n\t\tvar f, fNext;\r\n\t\tvar e;\r\n\r\n\t\t/*LINTED*/\r\n\t\tfor (f = mesh.fHead.next; f !== mesh.fHead; f = fNext) {\r\n\t\t\tfNext = f.next;\r\n\t\t\te = f.anEdge;\r\n\t\t\tassert(e.Lnext !== e);\r\n\r\n\t\t\tif (e.Lnext.Lnext === e) {\r\n\t\t\t\t/* A face with only two edges */\r\n\t\t\t\tSweep.addWinding(e.Onext, e);\r\n\t\t\t\ttess.mesh.delete(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstatic computeInterior(tess:Tesselator, validate: boolean = true) {\r\n\t\t/*\r\n\t\t * tessComputeInterior( tess ) computes the planar arrangement specified\r\n\t\t * by the given contours, and further subdivides this arrangement\r\n\t\t * into regions.  Each region is marked \"inside\" if it belongs\r\n\t\t * to the polygon, according to the rule given by tess->windingRule.\r\n\t\t * Each interior region is guaranteed be monotone.\r\n\t\t */\r\n\t\tvar v, vNext;\r\n\r\n\t\t/* Each vertex defines an event for our sweep line.  Start by inserting\r\n\t\t * all the vertices in a priority queue.  Events are processed in\r\n\t\t * lexicographic order, ie.\r\n\t\t *\r\n\t\t *\te1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)\r\n\t\t */\r\n\t\tSweep.removeDegenerateEdges(tess);\r\n\t\t\r\n\t\t/* if error */\r\n\t\tif (!Sweep.initPriorityQ(tess)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tSweep.initEdgeDict(tess);\r\n\r\n\t\twhile ((v = tess.pq.extractMin()) !== null) {\r\n\t\t\tfor (;;) {\r\n\t\t\t\tvNext = tess.pq.min();\r\n\t\t\t\tif (vNext === null || !Geom.vertEq(vNext, v)) break;\r\n\r\n\t\t\t\t/* Merge together all vertices at exactly the same location.\r\n\t\t\t\t * This is more efficient than processing them one at a time,\r\n\t\t\t\t * simplifies the code (see ConnectLeftDegenerate), and is also\r\n\t\t\t\t * important for correct handling of certain degenerate cases.\r\n\t\t\t\t * For example, suppose there are two identical edges A and B\r\n\t\t\t\t * that belong to different contours (so without this code they would\r\n\t\t\t\t * be processed by separate sweep events).  Suppose another edge C\r\n\t\t\t\t * crosses A and B from above.  When A is processed, we split it\r\n\t\t\t\t * at its intersection point with C.  However this also splits C,\r\n\t\t\t\t * so when we insert B we may compute a slightly different\r\n\t\t\t\t * intersection point.  This might leave two edges with a small\r\n\t\t\t\t * gap between them.  This kind of error is especially obvious\r\n\t\t\t\t * when using boundary extraction (TESS_BOUNDARY_ONLY).\r\n\t\t\t\t */\r\n\t\t\t\tvNext = tess.pq.extractMin();\r\n\t\t\t\tSweep.spliceMergeVertices(tess, v.anEdge, vNext.anEdge);\r\n\t\t\t}\r\n\t\t\tSweep.sweepEvent(tess, v);\r\n\t\t}\r\n\r\n\t\t/* Set tess->event for debugging purposes */\r\n\t\ttess.event = tess.dict.min().key.eUp.Org;\r\n\r\n\t\tSweep.debugEvent(tess);\r\n\t\tSweep.doneEdgeDict(tess);\r\n\t\tSweep.donePriorityQ(tess);\r\n\r\n\t\tif (!Sweep.removeDegenerateFaces(tess, tess.mesh)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tif(validate) {\r\n\t\t\ttess.mesh.check();\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n","import { WINDING, ELEMENT } from './utils/constants';\r\nimport { TESSmesh } from './mesh/TESSmesh';\r\nimport { Geom } from \"./utils/Geom\";\r\nimport { Sweep } from \"./utils/Sweep\";\r\nimport { V3, V2 } from './type';\r\nimport { TESShalfEdge } from './mesh/TESShalfEdge';\r\nimport { PriorityQ } from './utils/PriorityQ';\r\nimport { Dict } from './utils/Dict';\r\n\r\ntype TESSface = any;\r\n//type TESSmesh = any;\r\ntype TESSedge = any;\r\n\r\nexport class Tesselator {\r\n\t/*** state needed for collecting the input data ***/\r\n\t/* stores the input contours, and eventually the tessellation itself */\r\n\tmesh: TESSmesh = new TESSmesh();\r\n\r\n\t/*** state needed for projecting onto the sweep plane ***/\r\n\tnormal: V3 = [0.0, 0.0, 0.0]; /* user-specified normal (if provided) */\r\n\tsUnit: V3 = [0.0, 0.0, 0.0]; /* unit vector in s-direction (debugging) */\r\n\ttUnit: V3 = [0.0, 0.0, 0.0]; /* unit vector in t-direction (debugging) */\r\n\r\n\tbmin: V2 = [0.0, 0.0];\r\n\tbmax: V2 = [0.0, 0.0];\r\n\r\n\t/*** state needed for the line sweep ***/\r\n\t/* rule for determining polygon interior */\r\n\r\n\twindingRule = WINDING.ODD;\r\n\r\n\tdict: Dict = null; /* edge dictionary for sweep line */\r\n\tpq: PriorityQ = null; /* priority queue of vertex events */\r\n\tevent: any = null; /* current sweep event being processed */\r\n\r\n\tvertexIndexCounter: number = 0;\r\n\r\n\tvertices: Array<number> = [];\r\n\tvertexIndices: Array<number> = [];\r\n\tvertexCount: number = 0;\r\n\telements: Array<number> = [];\r\n\telementCount: number = 0;\r\n\r\n\tdot_(u: V3, v: V3) {\r\n\t\treturn u[0] * v[0] + u[1] * v[1] + u[2] * v[2];\r\n\t}\r\n\r\n\tnormalize_(v: V3) {\r\n\t\tlet len = v[0] * v[0] + v[1] * v[1] + v[2] * v[2];\r\n\r\n\t\tif (!len) {\r\n\t\t\tthrow \"Zero-size vector!\";\r\n\t\t}\r\n\r\n\t\tlen = Math.sqrt(len);\r\n\r\n\t\tv[0] /= len;\r\n\t\tv[1] /= len;\r\n\t\tv[2] /= len;\r\n\t}\r\n\r\n\tlongAxis_(v: V3) {\r\n\t\tlet i = 0;\r\n\r\n\t\tif (Math.abs(v[1]) > Math.abs(v[0])) {\r\n\t\t\ti = 1;\r\n\t\t}\r\n\r\n\t\tif (Math.abs(v[2]) > Math.abs(v[i])) {\r\n\t\t\ti = 2;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\tcomputeNormal_(norm: V3) {\r\n\t\tlet v: any, v1: any, v2: any;\r\n\t\tlet c, tLen2, maxLen2;\r\n\t\tlet maxVal: V3 = [0, 0, 0],\r\n\t\t\tminVal: V3 = [0, 0, 0],\r\n\t\t\td1: V3 = [0, 0, 0],\r\n\t\t\td2: V3 = [0, 0, 0],\r\n\t\t\ttNorm: V3 = [0, 0, 0];\r\n\r\n\t\tconst maxVert:Array<any> = [null, null, null],\r\n\t\t\tminVert:Array<any> = [null, null, null];\r\n\t\tconst vHead = this.mesh.vHead;\r\n\r\n\t\tv = vHead.next;\r\n\t\tfor (let i = 0; i < 3; ++i) {\r\n\t\t\tc = v.coords[i];\r\n\t\t\tminVal[i] = c;\r\n\t\t\tminVert[i] = v;\r\n\t\t\tmaxVal[i] = c;\r\n\t\t\tmaxVert[i] = v;\r\n\t\t}\r\n\r\n\t\tfor (v = vHead.next; v !== vHead; v = v.next) {\r\n\t\t\tfor (let i = 0; i < 3; ++i) {\r\n\t\t\t\tc = v.coords[i];\r\n\r\n\t\t\t\tif (c < minVal[i]) {\r\n\t\t\t\t\tminVal[i] = c;\r\n\t\t\t\t\tminVert[i] = v;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (c > maxVal[i]) {\r\n\t\t\t\t\tmaxVal[i] = c;\r\n\t\t\t\t\tmaxVert[i] = v;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Find two vertices separated by at least 1/sqrt(3) of the maximum\r\n\t\t * distance between any two vertices\r\n\t\t */\r\n\t\tlet i = 0;\r\n\t\tif (maxVal[1] - minVal[1] > maxVal[0] - minVal[0]) {\r\n\t\t\ti = 1;\r\n\t\t}\r\n\r\n\t\tif (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) {\r\n\t\t\ti = 2;\r\n\t\t}\r\n\r\n\t\tif (minVal[i] >= maxVal[i]) {\r\n\t\t\t/* All vertices are the same -- normal doesn't matter */\r\n\t\t\tnorm[0] = 0;\r\n\t\t\tnorm[1] = 0;\r\n\t\t\tnorm[2] = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Look for a third vertex which forms the triangle with maximum area\r\n\t\t * (Length of normal == twice the triangle area)\r\n\t\t */\r\n\t\tmaxLen2 = 0;\r\n\t\tv1 = minVert[i]!;\r\n\t\tv2 = maxVert[i]!;\r\n\t\td1[0] = v1.coords[0] - v2.coords[0];\r\n\t\td1[1] = v1.coords[1] - v2.coords[1];\r\n\t\td1[2] = v1.coords[2] - v2.coords[2];\r\n\r\n\t\tfor (v = vHead.next; v !== vHead; v = v.next) {\r\n\t\t\td2[0] = v.coords[0] - v2.coords[0];\r\n\t\t\td2[1] = v.coords[1] - v2.coords[1];\r\n\t\t\td2[2] = v.coords[2] - v2.coords[2];\r\n\r\n\t\t\ttNorm[0] = d1[1] * d2[2] - d1[2] * d2[1];\r\n\t\t\ttNorm[1] = d1[2] * d2[0] - d1[0] * d2[2];\r\n\t\t\ttNorm[2] = d1[0] * d2[1] - d1[1] * d2[0];\r\n\t\t\ttLen2 = tNorm[0] * tNorm[0] + tNorm[1] * tNorm[1] + tNorm[2] * tNorm[2];\r\n\r\n\t\t\tif (tLen2 > maxLen2) {\r\n\t\t\t\tmaxLen2 = tLen2;\r\n\t\t\t\tnorm[0] = tNorm[0];\r\n\t\t\t\tnorm[1] = tNorm[1];\r\n\t\t\t\tnorm[2] = tNorm[2];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (maxLen2 <= 0) {\r\n\t\t\t/* All points lie on a single line -- any decent normal will do */\r\n\t\t\tnorm[0] = norm[1] = norm[2] = 0;\r\n\t\t\tnorm[this.longAxis_(d1)] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\tcheckOrientation_() {\r\n\t\tvar f,\r\n\t\t\tfHead = this.mesh.fHead;\r\n\t\tvar v,\r\n\t\t\tvHead = this.mesh.vHead;\r\n\t\tvar e;\r\n\r\n\t\t/* When we compute the normal automatically, we choose the orientation\r\n\t\t * so that the the sum of the signed areas of all contours is non-negative.\r\n\t\t */\r\n\t\tlet area = 0;\r\n\r\n\t\tfor (let f = fHead.next!; f !== fHead; f = f.next!) {\r\n\t\t\te = f.anEdge!;\r\n\t\t\tif (e.winding <= 0) continue;\r\n\t\t\tdo {\r\n\t\t\t\tarea += (e!.Org!.s! - e!.Dst!.s!) * (e!.Org!.t + e!.Dst!.t!);\r\n\t\t\t\te = e!.Lnext!;\r\n\t\t\t} while (e !== f.anEdge);\r\n\t\t}\r\n\r\n\t\tif (area < 0) {\r\n\t\t\t/* Reverse the orientation by flipping all the t-coordinates */\r\n\t\t\tfor (v = vHead.next!; v !== vHead; v = v!.next!) {\r\n\t\t\t\tv.t = -v.t;\r\n\t\t\t}\r\n\t\t\tthis.tUnit[0] = -this.tUnit[0];\r\n\t\t\tthis.tUnit[1] = -this.tUnit[1];\r\n\t\t\tthis.tUnit[2] = -this.tUnit[2];\r\n\t\t}\r\n\t}\r\n\r\n\t/*\t#ifdef FOR_TRITE_TEST_PROGRAM\r\n\t\t#include <stdlib.h>\r\n\t\textern int RandomSweep;\r\n\t\t#define S_UNIT_X\t(RandomSweep ? (2*drand48()-1) : 1.0)\r\n\t\t#define S_UNIT_Y\t(RandomSweep ? (2*drand48()-1) : 0.0)\r\n\t\t#else\r\n\t\t#if defined(SLANTED_SWEEP) */\r\n\t/* The \"feature merging\" is not intended to be complete.  There are\r\n\t * special cases where edges are nearly parallel to the sweep line\r\n\t * which are not implemented.  The algorithm should still behave\r\n\t * robustly (ie. produce a reasonable tesselation) in the presence\r\n\t * of such edges, however it may miss features which could have been\r\n\t * merged.  We could minimize this effect by choosing the sweep line\r\n\t * direction to be something unusual (ie. not parallel to one of the\r\n\t * coordinate axes).\r\n\t */\r\n\t/*\t#define S_UNIT_X\t(TESSreal)0.50941539564955385\t// Pre-normalized\r\n\t\t#define S_UNIT_Y\t(TESSreal)0.86052074622010633\r\n\t\t#else\r\n\t\t#define S_UNIT_X\t(TESSreal)1.0\r\n\t\t#define S_UNIT_Y\t(TESSreal)0.0\r\n\t\t#endif\r\n\t\t#endif*/\r\n\r\n\t/* Determine the polygon normal and project vertices onto the plane\r\n\t * of the polygon.\r\n\t */\r\n\tprojectPolygon_() {\r\n\t\tlet v,\r\n\t\t\tvHead = this.mesh.vHead;\r\n\t\tlet norm: V3 = [0, 0, 0];\r\n\t\tlet sUnit, tUnit;\r\n\t\tlet computedNormal = false;\r\n\r\n\t\tnorm[0] = this.normal[0];\r\n\t\tnorm[1] = this.normal[1];\r\n\t\tnorm[2] = this.normal[2];\r\n\r\n\t\tif (!norm[0] && !norm[1] && !norm[2]) {\r\n\t\t\tthis.computeNormal_(norm);\r\n\t\t\tcomputedNormal = true;\r\n\t\t}\r\n\r\n\t\tsUnit = this.sUnit;\r\n\t\ttUnit = this.tUnit;\r\n\r\n\t\tlet axis = this.longAxis_(norm);\r\n\r\n\t\t/*\t#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)\r\n\t\t\t// Choose the initial sUnit vector to be approximately perpendicular\r\n\t\t\t// to the normal.\r\n\t\t\t\r\n\t\t\tNormalize( norm );\r\n\r\n\t\t\tsUnit[i] = 0;\r\n\t\t\tsUnit[(i+1)%3] = S_UNIT_X;\r\n\t\t\tsUnit[(i+2)%3] = S_UNIT_Y;\r\n\r\n\t\t\t// Now make it exactly perpendicular \r\n\t\t\tw = Dot( sUnit, norm );\r\n\t\t\tsUnit[0] -= w * norm[0];\r\n\t\t\tsUnit[1] -= w * norm[1];\r\n\t\t\tsUnit[2] -= w * norm[2];\r\n\t\t\tNormalize( sUnit );\r\n\r\n\t\t\t// Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame \r\n\t\t\ttUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];\r\n\t\t\ttUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];\r\n\t\t\ttUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];\r\n\t\t\tNormalize( tUnit );\r\n\t\t#else*/\r\n\t\t/* Project perpendicular to a coordinate axis -- better numerically */\r\n\t\tsUnit[axis] = 0;\r\n\t\tsUnit[(axis + 1) % 3] = 1.0;\r\n\t\tsUnit[(axis + 2) % 3] = 0.0;\r\n\r\n\t\ttUnit[axis] = 0;\r\n\t\ttUnit[(axis + 1) % 3] = 0.0;\r\n\t\ttUnit[(axis + 2) % 3] = norm[axis] > 0 ? 1.0 : -1.0;\r\n\t\t//\t#endif\r\n\r\n\t\t/* Project the vertices onto the sweep plane */\r\n\t\tfor (let v = vHead.next!; v !== vHead; v = v!.next!) {\r\n\t\t\tv.s = this.dot_(v.coords, sUnit);\r\n\t\t\tv.t = this.dot_(v.coords, tUnit);\r\n\t\t}\r\n\r\n\t\tif (computedNormal) {\r\n\t\t\tthis.checkOrientation_();\r\n\t\t}\r\n\r\n\t\t/* Compute ST bounds. */\r\n\t\tlet first = true;\r\n\r\n\t\tfor (let v = vHead.next; v !== vHead; v = v!.next!) {\r\n\t\t\tif (first) {\r\n\t\t\t\tthis.bmin[0] = this.bmax[0] = v!.s;\r\n\t\t\t\tthis.bmin[1] = this.bmax[1] = v!.t;\r\n\r\n\t\t\t\tfirst = false;\r\n\t\t\t} else {\r\n\t\t\t\tif (v!.s! < this.bmin[0]) this.bmin[0] = v!.s;\r\n\t\t\t\tif (v!.s! > this.bmax[0]) this.bmax[0] = v!.s;\r\n\t\t\t\tif (v!.t! < this.bmin[1]) this.bmin[1] = v!.t;\r\n\t\t\t\tif (v!.t! > this.bmax[1]) this.bmax[1] = v!.t;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\taddWinding_(eDst: any, eSrc: any) {\r\n\t\teDst.winding += eSrc.winding;\r\n\t\teDst.Sym.winding += eSrc.Sym.winding;\r\n\t}\r\n\r\n\t/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region\r\n\t * (what else would it do??)  The region must consist of a single\r\n\t * loop of half-edges (see mesh.h) oriented CCW.  \"Monotone\" in this\r\n\t * case means that any vertical line intersects the interior of the\r\n\t * region in a single interval.\r\n\t *\r\n\t * Tessellation consists of adding interior edges (actually pairs of\r\n\t * half-edges), to split the region into non-overlapping triangles.\r\n\t *\r\n\t * The basic idea is explained in Preparata and Shamos (which I don''t\r\n\t * have handy right now), although their implementation is more\r\n\t * complicated than this one.  The are two edge chains, an upper chain\r\n\t * and a lower chain.  We process all vertices from both chains in order,\r\n\t * from right to left.\r\n\t *\r\n\t * The algorithm ensures that the following invariant holds after each\r\n\t * vertex is processed: the untessellated region consists of two\r\n\t * chains, where one chain (say the upper) is a single edge, and\r\n\t * the other chain is concave.  The left vertex of the single edge\r\n\t * is always to the left of all vertices in the concave chain.\r\n\t *\r\n\t * Each step consists of adding the rightmost unprocessed vertex to one\r\n\t * of the two chains, and forming a fan of triangles from the rightmost\r\n\t * of two chain endpoints.  Determining whether we can add each triangle\r\n\t * to the fan is a simple orientation test.  By making the fan as large\r\n\t * as possible, we restore the invariant (check it yourself).\r\n\t */\r\n\t//\tint tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )\r\n\ttessellateMonoRegion_(mesh: any, face: TESSface) {\r\n\t\tlet up, lo;\r\n\r\n\t\t/* All edges are oriented CCW around the boundary of the region.\r\n\t\t * First, find the half-edge whose origin vertex is rightmost.\r\n\t\t * Since the sweep goes from left to right, face->anEdge should\r\n\t\t * be close to the edge we want.\r\n\t\t */\r\n\t\tup = face.anEdge;\r\n\t\tif (!(up.Lnext !== up && up.Lnext.Lnext !== up)) {\r\n\t\t\tthrow \"Mono region invalid\";\r\n\t\t}\r\n\r\n\t\tfor (; Geom.vertLeq(up.Dst, up.Org); up = up.Lprev);\r\n\t\tfor (; Geom.vertLeq(up.Org, up.Dst); up = up.Lnext);\r\n\r\n\t\tlo = up.Lprev;\r\n\r\n\t\tlet tempHalfEdge: any = undefined;\r\n\r\n\t\twhile (up.Lnext !== lo) {\r\n\t\t\tif (Geom.vertLeq(up.Dst, lo.Org)) {\r\n\t\t\t\t/* up->Dst is on the left.  It is safe to form triangles from lo->Org.\r\n\t\t\t\t * The EdgeGoesLeft test guarantees progress even when some triangles\r\n\t\t\t\t * are CW, given that the upper and lower chains are truly monotone.\r\n\t\t\t\t */\r\n\t\t\t\twhile (\r\n\t\t\t\t\tlo.Lnext !== up &&\r\n\t\t\t\t\t(Geom.edgeGoesLeft(lo.Lnext) ||\r\n\t\t\t\t\t\tGeom.edgeSign(lo.Org, lo.Dst, lo.Lnext.Dst) <= 0.0)\r\n\t\t\t\t) {\r\n\t\t\t\t\ttempHalfEdge = mesh.connect(lo.Lnext, lo);\r\n\t\t\t\t\t//if (tempHalfEdge == NULL) return 0;\r\n\t\t\t\t\tlo = tempHalfEdge.Sym;\r\n\t\t\t\t}\r\n\t\t\t\tlo = lo.Lprev;\r\n\t\t\t} else {\r\n\t\t\t\t/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */\r\n\t\t\t\twhile (\r\n\t\t\t\t\tlo.Lnext !== up &&\r\n\t\t\t\t\t(Geom.edgeGoesRight(up.Lprev) ||\r\n\t\t\t\t\t\tGeom.edgeSign(up.Dst, up.Org, up.Lprev.Org) >= 0.0)\r\n\t\t\t\t) {\r\n\t\t\t\t\ttempHalfEdge = mesh.connect(up, up.Lprev);\r\n\t\t\t\t\t//if (tempHalfEdge == NULL) return 0;\r\n\t\t\t\t\tup = tempHalfEdge.Sym;\r\n\t\t\t\t}\r\n\t\t\t\tup = up.Lnext;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region\r\n\t\t * can be tessellated in a fan from this leftmost vertex.\r\n\t\t */\r\n\r\n\t\tif (lo.Lnext === up) {\r\n\t\t\tthrow \"Mono region invalid\";\r\n\t\t}\r\n\r\n\t\twhile (lo.Lnext.Lnext !== up) {\r\n\t\t\ttempHalfEdge = mesh.connect(lo.Lnext, lo);\r\n\t\t\t//if (tempHalfEdge == NULL) return 0;\r\n\t\t\tlo = tempHalfEdge.Sym;\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* tessMeshTessellateInterior( mesh ) tessellates each region of\r\n\t * the mesh which is marked \"inside\" the polygon.  Each such region\r\n\t * must be monotone.\r\n\t */\r\n\t//int tessMeshTessellateInterior( TESSmesh *mesh )\r\n\ttessellateInterior_(mesh: TESSmesh) {\r\n\t\tlet next;\r\n\r\n\t\t/*LINTED*/\r\n\t\tfor (let f = mesh.fHead.next; f !== mesh.fHead; f = next) {\r\n\t\t\t/* Make sure we don''t try to tessellate the new triangles. */\r\n\t\t\tnext = f!.next!;\r\n\t\t\tif (f!.inside) {\r\n\t\t\t\tif (!this.tessellateMonoRegion_(mesh, f)) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces\r\n\t * which are not marked \"inside\" the polygon.  Since further mesh operations\r\n\t * on NULL faces are not allowed, the main purpose is to clean up the\r\n\t * mesh so that exterior loops are not represented in the data structure.\r\n\t */\r\n\t//void tessMeshDiscardExterior( TESSmesh *mesh )\r\n\tdiscardExterior_(mesh: TESSmesh) {\r\n\t\tlet next;\r\n\r\n\t\t/*LINTED*/\r\n\t\tfor (let f = mesh.fHead.next; f !== mesh.fHead; f = next) {\r\n\t\t\t/* Since f will be destroyed, save its next pointer. */\r\n\t\t\tnext = f!.next;\r\n\r\n\t\t\tif (!f!.inside) {\r\n\t\t\t\tmesh.zapFace(f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the\r\n\t * winding numbers on all edges so that regions marked \"inside\" the\r\n\t * polygon have a winding number of \"value\", and regions outside\r\n\t * have a winding number of 0.\r\n\t *\r\n\t * If keepOnlyBoundary is TRUE, it also deletes all edges which do not\r\n\t * separate an interior region from an exterior one.\r\n\t */\r\n\t//\tint tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )\r\n\tsetWindingNumber_(mesh: TESSmesh, value: number, keepOnlyBoundary: boolean) {\r\n\t\tlet eNext;\r\n\r\n\t\tfor (let e = mesh.eHead.next; e !== mesh.eHead; e = eNext) {\r\n\t\t\teNext = e!.next;\r\n\t\t\tif (e.Rface.inside !== e.Lface.inside) {\r\n\t\t\t\t/* This is a boundary edge (one side is interior, one is exterior). */\r\n\t\t\t\te.winding = e.Lface.inside ? value : -value;\r\n\t\t\t} else {\r\n\t\t\t\t/* Both regions are interior, or both are exterior. */\r\n\t\t\t\tif (!keepOnlyBoundary) {\r\n\t\t\t\t\te.winding = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmesh.delete(e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tgetNeighbourFace_(edge: TESSedge): TESSedge {\r\n\t\tif (!edge.Rface) return -1;\r\n\t\tif (!edge.Rface.inside) return -1;\r\n\t\treturn edge.Rface.n;\r\n\t}\r\n\r\n\toutputPolymesh_(mesh: TESSmesh, elementType: number, polySize: number, vertexSize: number) {\r\n\t\tlet edge;\r\n\t\tlet maxFaceCount = 0;\r\n\t\tlet maxVertexCount = 0;\r\n\t\tlet faceVerts, i;\r\n\r\n\t\t// Assume that the input data is triangles now.\r\n\t\t// Try to merge as many polygons as possible\r\n\t\tif (polySize > 3) {\r\n\t\t\tmesh.mergeConvexFaces(polySize);\r\n\t\t}\r\n\r\n\t\t// Mark unused\r\n\t\tfor (let v = mesh.vHead.next; v !== mesh.vHead; v = v.next) {\r\n\t\t\tv.n = -1;\r\n\t\t}\r\n\r\n\t\t// Create unique IDs for all vertices and faces.\r\n\t\tfor (let f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {\r\n\t\t\tf.n = -1;\r\n\r\n\t\t\tif (!f.inside) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tedge = f.anEdge;\r\n\t\t\tfaceVerts = 0;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tlet v = edge.Org;\r\n\t\t\t\tif (v.n === -1) {\r\n\t\t\t\t\tv.n = maxVertexCount;\r\n\t\t\t\t\tmaxVertexCount++;\r\n\t\t\t\t}\r\n\t\t\t\tfaceVerts++;\r\n\t\t\t\tedge = edge.Lnext;\r\n\t\t\t} while (edge !== f.anEdge);\r\n\r\n\t\t\tif ((faceVerts > polySize)) {\r\n\t\t\t\tthrow `Face vertex greater that support polygon`;\r\n\t\t\t}\r\n\r\n\t\t\tf.n = maxFaceCount;\r\n\t\t\t++maxFaceCount;\r\n\t\t}\r\n\r\n\t\tthis.elementCount = maxFaceCount;\r\n\t\tif (elementType === ELEMENT.CONNECTED_POLYGONS) {\r\n\t\t\tmaxFaceCount *= 2;\r\n\t\t}\r\n\t\t/*\t\ttess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(TESSindex) * maxFaceCount * polySize );\r\n\t\t\tif (!tess->elements)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\tthis.elements = [];\r\n\t\tthis.elements.length = maxFaceCount * polySize;\r\n\r\n\t\tthis.vertexCount = maxVertexCount;\r\n\t\t/*\t\ttess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t sizeof(TESSreal) * tess->vertexCount * vertexSize );\r\n\t\t\tif (!tess->vertices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\tthis.vertices = [];\r\n\t\tthis.vertices.length = maxVertexCount * vertexSize;\r\n\r\n\t\t/*\t\ttess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TESSindex) * tess->vertexCount );\r\n\t\t\tif (!tess->vertexIndices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\tthis.vertexIndices = [];\r\n\t\tthis.vertexIndices.length = maxVertexCount;\r\n\r\n\t\t// Output vertices.\r\n\t\tfor (let v = mesh.vHead.next; v !== mesh.vHead; v = v.next) {\r\n\t\t\tif (v.n !== -1) {\r\n\t\t\t\t// Store coordinate\r\n\t\t\t\tvar idx = v.n * vertexSize;\r\n\t\t\t\tthis.vertices[idx + 0] = v.coords[0];\r\n\t\t\t\tthis.vertices[idx + 1] = v.coords[1];\r\n\t\t\t\t\r\n\t\t\t\tif (vertexSize > 2) {\r\n\t\t\t\t\tthis.vertices[idx + 2] = v.coords[2];\r\n\t\t\t\t}\r\n\t\t\t\t// Store vertex index.\r\n\t\t\t\tthis.vertexIndices[v.n] = v.idx;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Output indices.\r\n\t\tlet nel = 0;\r\n\t\tfor (let f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {\r\n\t\t\tif (!f.inside) continue;\r\n\r\n\t\t\t// Store polygon\r\n\t\t\tedge = f.anEdge;\r\n\t\t\tfaceVerts = 0;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tlet v = edge.Org;\r\n\t\t\t\tthis.elements[nel++] = v.n;\r\n\t\t\t\tfaceVerts++;\r\n\t\t\t\tedge = edge.Lnext;\r\n\t\t\t} while (edge !== f.anEdge);\r\n\t\t\t// Fill unused.\r\n\r\n\t\t\tfor (let i = faceVerts; i < polySize; ++i) {\r\n\t\t\t\tthis.elements[nel++] = -1;\r\n\t\t\t}\r\n\r\n\t\t\t// Store polygon connectivity\r\n\t\t\tif (elementType === ELEMENT.CONNECTED_POLYGONS) {\r\n\t\t\t\tedge = f.anEdge;\r\n\t\t\t\tdo {\r\n\t\t\t\t\tthis.elements[nel++] = this.getNeighbourFace_(edge);\r\n\t\t\t\t\tedge = edge.Lnext;\r\n\t\t\t\t} while (edge !== f.anEdge);\r\n\t\t\t\t// Fill unused.\r\n\t\t\t\tfor (let i = faceVerts; i < polySize; ++i) {\r\n\t\t\t\t\tthis.elements[nel++] = -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//\tvoid OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )\r\n\toutputContours_(mesh: TESSmesh, vertexSize: number) {\r\n\t\tlet edge;\r\n\t\tlet start;\r\n\t\tlet startVert = 0;\r\n\t\tlet vertCount = 0;\r\n\r\n\t\tthis.vertexCount = 0;\r\n\t\tthis.elementCount = 0;\r\n\r\n\t\tfor (let f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {\r\n\t\t\tif (!f.inside) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tstart = edge = f.anEdge;\r\n\t\t\tdo {\r\n\t\t\t\tthis.vertexCount++;\r\n\t\t\t\tedge = edge.Lnext;\r\n\t\t\t} while (edge !== start);\r\n\r\n\t\t\tthis.elementCount++;\r\n\t\t}\r\n\r\n\t\t/*\t\ttess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(TESSindex) * tess->elementCount * 2 );\r\n\t\t\tif (!tess->elements)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\tthis.elements = [];\r\n\t\tthis.elements.length = this.elementCount * 2;\r\n\r\n\t\t/*\t\ttess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  sizeof(TESSreal) * tess->vertexCount * vertexSize );\r\n\t\t\tif (!tess->vertices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\tthis.vertices = [];\r\n\t\tthis.vertices.length = this.vertexCount * vertexSize;\r\n\r\n\t\t/*\t\ttess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsizeof(TESSindex) * tess->vertexCount );\r\n\t\t\tif (!tess->vertexIndices)\r\n\t\t\t{\r\n\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\treturn;\r\n\t\t\t}*/\r\n\t\tthis.vertexIndices = [];\r\n\t\tthis.vertexIndices.length = this.vertexCount;\r\n\r\n\t\tlet nv = 0;\r\n\t\tlet nvi = 0;\r\n\t\tlet nel = 0;\r\n\r\n\t\tstartVert = 0;\r\n\r\n\t\tfor (let f = mesh.fHead.next; f !== mesh.fHead; f = f.next) {\r\n\t\t\tif (!f.inside) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tvertCount = 0;\r\n\t\t\tstart = edge = f.anEdge;\r\n\r\n\t\t\tdo {\r\n\t\t\t\tthis.vertices[nv++] = edge.Org.coords[0];\r\n\t\t\t\tthis.vertices[nv++] = edge.Org.coords[1];\r\n\t\t\t\t\r\n\t\t\t\tif (vertexSize > 2) {\r\n\t\t\t\t\tthis.vertices[nv++] = edge.Org.coords[2];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.vertexIndices[nvi++] = edge.Org.idx;\r\n\t\t\t\tvertCount++;\r\n\t\t\t\tedge = edge.Lnext;\r\n\t\t\t} while (edge !== start);\r\n\r\n\t\t\tthis.elements[nel++] = startVert;\r\n\t\t\tthis.elements[nel++] = vertCount;\r\n\r\n\t\t\tstartVert += vertCount;\r\n\t\t}\r\n\t}\r\n\r\n\taddContour(size: number, vertices: Array<number>) {\r\n\r\n\t\tif (this.mesh === null) {\r\n\t\t\tthis.mesh = new TESSmesh();\r\n\t\t}\r\n\t\t/*\t \tif ( tess->mesh == NULL ) {\r\n\t\t\ttess->outOfMemory = 1;\r\n\t\t\treturn;\r\n\t\t}*/\r\n\r\n\t\tif (size < 2) {\r\n\t\t\tsize = 2;\r\n\t\t}\r\n\r\n\t\tif (size > 3) {\r\n\t\t\tsize = 3;\r\n\t\t}\r\n\r\n\t\tlet e: TESShalfEdge = null;\r\n\r\n\t\tfor (let i = 0; i < vertices.length; i += size) {\r\n\t\t\tif (e === null) {\r\n\t\t\t\t/* Make a self-loop (one vertex, one edge). */\r\n\t\t\t\te = this.mesh.makeEdge();\r\n\t\t\t\t/*\t\t\t\tif ( e == NULL ) {\r\n\t\t\t\t\t\ttess->outOfMemory = 1;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}*/\r\n\t\t\t\tthis.mesh.splice(e, e.Sym);\r\n\t\t\t} else {\r\n\t\t\t\t/* Create a new vertex and edge which immediately follow e\r\n\t\t\t\t * in the ordering around the left face.\r\n\t\t\t\t */\r\n\t\t\t\tthis.mesh.splitEdge(e);\r\n\t\t\t\te = e!.Lnext!;\r\n\t\t\t}\r\n\r\n\t\t\t/* The new vertex is now e->Org. */\r\n\t\t\te.Org.coords[0] = vertices[i + 0];\r\n\t\t\te.Org.coords[1] = vertices[i + 1];\r\n\r\n\t\t\tif (size > 2) {\r\n\t\t\t\te.Org.coords[2] = vertices[i + 2];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\te.Org.coords[2] = 0.0;\r\n\t\t\t}\r\n\r\n\t\t\t/* Store the insertion number so that the vertex can be later recognized. */\r\n\t\t\te.Org.idx = this.vertexIndexCounter++;\r\n\r\n\t\t\t/* The winding of an edge says how the winding number changes as we\r\n\t\t\t * cross from the edge''s right face to its left face.  We add the\r\n\t\t\t * vertices in such an order that a CCW contour will add +1 to\r\n\t\t\t * the winding number of the region inside the contour.\r\n\t\t\t */\r\n\t\t\te.winding = 1;\r\n\t\t\te.Sym.winding = -1;\r\n\t\t}\r\n\t}\r\n\r\n\t//\tint tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )\r\n\t/**\r\n\t * Run tesselation\r\n\t * @param windingRule \r\n\t * @param elementType \r\n\t * @param polySize \r\n\t * @param vertexSize \r\n\t * @param normal \r\n\t * @param validate UNSAFE! Skip mesh validation pass, may throw any error.\r\n\t */\r\n\ttesselate(\r\n\t\twindingRule: WINDING = WINDING.ODD,\r\n\t\telementType: ELEMENT = ELEMENT.POLYGONS,\r\n\t\tpolySize: number,\r\n\t\tvertexSize: 2 | 3,\r\n\t\tnormal: V3,\r\n\t\tvalidate : boolean = true\r\n\t) {\r\n\t\tthis.vertices = [];\r\n\t\tthis.elements = [];\r\n\t\tthis.vertexIndices = [];\r\n\r\n\t\tthis.vertexIndexCounter = 0;\r\n\r\n\t\tif (normal) {\r\n\t\t\tthis.normal[0] = normal[0];\r\n\t\t\tthis.normal[1] = normal[1];\r\n\t\t\tthis.normal[2] = normal[2];\r\n\t\t}\r\n\r\n\t\tthis.windingRule = windingRule;\r\n\r\n\t\tif (vertexSize < 2) {\r\n\t\t\tvertexSize = 2;\r\n\t\t}\r\n\r\n\t\tif (vertexSize > 3) {\r\n\t\t\tvertexSize = 3;\r\n\t\t}\r\n\r\n\t\t/*\t\tif (setjmp(tess->env) != 0) { \r\n\t\t\t\t// come back here if out of memory\r\n\t\t\t\treturn 0;\r\n\t\t\t}*/\r\n\r\n\t\tif (!this.mesh) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t/* Determine the polygon normal and project vertices onto the plane\r\n\t\t * of the polygon.\r\n\t\t */\r\n\t\tthis.projectPolygon_();\r\n\r\n\t\t/* tessComputeInterior( tess ) computes the planar arrangement specified\r\n\t\t * by the given contours, and further subdivides this arrangement\r\n\t\t * into regions.  Each region is marked \"inside\" if it belongs\r\n\t\t * to the polygon, according to the rule given by tess->windingRule.\r\n\t\t * Each interior region is guaranteed be monotone.\r\n\t\t */\r\n\t\tSweep.computeInterior(this, validate);\r\n\r\n\t\tvar mesh = this.mesh;\r\n\r\n\t\t/* If the user wants only the boundary contours, we throw away all edges\r\n\t\t * except those which separate the interior from the exterior.\r\n\t\t * Otherwise we tessellate all the regions marked \"inside\".\r\n\t\t */\r\n\t\tif (elementType === ELEMENT.BOUNDARY_CONTOURS) {\r\n\t\t\tthis.setWindingNumber_(mesh, 1, true);\r\n\t\t} else {\r\n\t\t\tthis.tessellateInterior_(mesh);\r\n\t\t}\r\n\t\t//\t\tif (rc == 0) longjmp(tess->env,1);  /* could've used a label */\r\n\r\n\t\tif(validate){\r\n\t\t\t mesh.check();\r\n\t\t}\r\n\r\n\t\tif (elementType === ELEMENT.BOUNDARY_CONTOURS) {\r\n\t\t\tthis.outputContours_(mesh, vertexSize); /* output contours */\r\n\t\t} else {\r\n\t\t\tthis.outputPolymesh_(\r\n\t\t\t\tmesh,\r\n\t\t\t\telementType,\r\n\t\t\t\tpolySize,\r\n\t\t\t\tvertexSize,\r\n\t\t\t); /* output polygons */\r\n\t\t}\r\n\r\n\t\t//\t\t\ttess.mesh = null;\r\n\r\n\t\treturn true;\r\n\t}\r\n};","/*\r\n ** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)\r\n ** Copyright (C) [dates of first publication] Silicon Graphics, Inc.\r\n ** All Rights Reserved.\r\n **\r\n ** Permission is hereby granted, free of charge, to any person obtaining a copy\r\n ** of this software and associated documentation files (the \"Software\"), to deal\r\n ** in the Software without restriction, including without limitation the rights\r\n ** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\r\n ** of the Software, and to permit persons to whom the Software is furnished to do so,\r\n ** subject to the following conditions:\r\n **\r\n ** The above copyright notice including the dates of first publication and either this\r\n ** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be\r\n ** included in all copies or substantial portions of the Software.\r\n **\r\n ** THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n ** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n ** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.\r\n ** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n ** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE\r\n ** OR OTHER DEALINGS IN THE SOFTWARE.\r\n **\r\n ** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not\r\n ** be used in advertising or otherwise to promote the sale, use or other dealings in\r\n ** this Software without prior written authorization from Silicon Graphics, Inc.\r\n */\r\n/*\r\n ** Author: Mikko Mononen, Aug 2013.\r\n ** TS-version: Timoshenko Konstantin, Mart 2020.\r\n ** The code is based on GLU libtess by Eric Veach, July 1994\r\n */\r\n\r\nimport { Tesselator } from \"./Tesselator\";\r\nimport { WINDING, ELEMENT } from \"./utils/constants\";\r\nimport { V3 } from \"./type\";\r\n\r\nexport interface IOptions {\r\n\twindingRule?: number;\r\n\telementType?: number;\r\n\tpolySize?: number;\r\n\tvertexSize?: 2 | 3;\r\n\tnormal?: V3;\r\n\tcontours: Array<Array<number>>;\r\n\tstrict?: boolean;\r\n\tdebug?: boolean;\r\n}\r\n\r\nexport interface IResult {\r\n\tvertices: Array<number>;\r\n\tvertexIndices: Array<number>;\r\n\tvertexCount: number;\r\n\telements: Array<number>;\r\n\telementCount: number;\r\n\tmesh: any;\r\n}\r\n\r\nexport { Tesselator, WINDING, ELEMENT };\r\n\r\nexport function tesselate({\r\n\twindingRule = WINDING.ODD,\r\n\telementType = ELEMENT.POLYGONS,\r\n\tpolySize = 3,\r\n\tvertexSize = 2,\r\n\tnormal = [0, 0, 1],\r\n\tcontours = [],\r\n\tstrict = true,\r\n\tdebug = false,\r\n}: IOptions): IResult | undefined {\r\n\tif (!contours && strict) {\r\n\t\tthrow new Error(\"Contours can't be empty\");\r\n\t}\r\n\r\n\tif (!contours) {\r\n\t\treturn undefined;\r\n\t}\r\n\r\n\tconst tess = new Tesselator();\r\n\r\n\tfor (let i = 0; i < contours.length; i++) {\r\n\t\ttess.addContour(vertexSize || 2, contours[i]);\r\n\t}\r\n\r\n\ttess.tesselate(\r\n\t\twindingRule,\r\n\t\telementType,\r\n\t\tpolySize,\r\n\t\tvertexSize,\r\n\t\tnormal,\r\n\t\tstrict,\r\n\t);\r\n\r\n\treturn {\r\n\t\tvertices: tess.vertices,\r\n\t\tvertexIndices: tess.vertexIndices,\r\n\t\tvertexCount: tess.vertexCount,\r\n\t\telements: tess.elements,\r\n\t\telementCount: tess.elementCount,\r\n\t\tmesh: debug ? tess.mesh : undefined,\r\n\t};\r\n}\r\n\r\n// legacy, compatibility exports\r\n\r\n\r\nexport const WINDING_ODD = WINDING.ODD;\r\nexport const WINDING_NONZERO = WINDING.NONZERO;\r\nexport const WINDING_POSITIVE = WINDING.POSITIVE;\r\nexport const WINDING_NEGATIVE = WINDING.NEGATIVE;\r\nexport const WINDING_ABS_GEQ_TWO = WINDING.ABS_GEQ_TWO;\r\n\r\nexport const POLYGONS = ELEMENT.POLYGONS;\r\nexport const CONNECTED_POLYGONS = ELEMENT.CONNECTED_POLYGONS;\r\nexport const BOUNDARY_CONTOURS = ELEMENT.BOUNDARY_CONTOURS;"],"names":["WINDING","ELEMENT"],"mappings":"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"}
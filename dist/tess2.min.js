var Tess2=function(e){"use strict";var t,n;function i(e,t){if(!e)throw t||"Assertion Failed!"}(t=e.WINDING||(e.WINDING={}))[t.ODD=0]="ODD",t[t.NONZERO=1]="NONZERO",t[t.POSITIVE=2]="POSITIVE",t[t.NEGATIVE=3]="NEGATIVE",t[t.ABS_GEQ_TWO=4]="ABS_GEQ_TWO",(n=e.ELEMENT||(e.ELEMENT={}))[n.POLYGONS=0]="POLYGONS",n[n.CONNECTED_POLYGONS=1]="CONNECTED_POLYGONS",n[n.BOUNDARY_CONTOURS=2]="BOUNDARY_CONTOURS";class s{static vertEq(e,t){return e.s===t.s&&e.t===t.t}static vertLeq(e,t){return e.s<t.s||e.s===t.s&&e.t<=t.t}static transLeq(e,t){return e.t<t.t||e.t===t.t&&e.s<=t.s}static edgeGoesLeft(e){return s.vertLeq(e.Dst,e.Org)}static edgeGoesRight(e){return s.vertLeq(e.Org,e.Dst)}static vertL1dist(e,t){return Math.abs(e.s-t.s)+Math.abs(e.t-t.t)}static edgeEval(e,t,n){i(s.vertLeq(e,t)&&s.vertLeq(t,n));var r=t.s-e.s,d=n.s-t.s;return r+d>0?r<d?t.t-e.t+(e.t-n.t)*(r/(r+d)):t.t-n.t+(n.t-e.t)*(d/(r+d)):0}static edgeSign(e,t,n){i(s.vertLeq(e,t)&&s.vertLeq(t,n));var r=t.s-e.s,d=n.s-t.s;return r+d>0?(t.t-n.t)*r+(t.t-e.t)*d:0}static transEval(e,t,n){i(s.transLeq(e,t)&&s.transLeq(t,n));var r=t.t-e.t,d=n.t-t.t;return r+d>0?r<d?t.s-e.s+(e.s-n.s)*(r/(r+d)):t.s-n.s+(n.s-e.s)*(d/(r+d)):0}static transSign(e,t,n){i(s.transLeq(e,t)&&s.transLeq(t,n));var r=t.t-e.t,d=n.t-t.t;return r+d>0?(t.s-n.s)*r+(t.s-e.s)*d:0}static vertCCW(e,t,n){return e.s*(t.t-n.t)+t.s*(n.t-e.t)+n.s*(e.t-t.t)>=0}static interpolate(e,t,n,i){return(e=e<0?0:e)<=(n=n<0?0:n)?0===n?(t+i)/2:t+e/(e+n)*(i-t):i+n/(e+n)*(t-i)}static intersect(e,t,n,i,r){var d,a,l;s.vertLeq(e,t)||(l=e,e=t,t=l),s.vertLeq(n,i)||(l=n,n=i,i=l),s.vertLeq(e,n)||(l=e,e=n,n=l,l=t,t=i,i=l),s.vertLeq(n,t)?s.vertLeq(t,i)?((d=s.edgeEval(e,n,t))+(a=s.edgeEval(n,t,i))<0&&(d=-d,a=-a),r.s=s.interpolate(d,n.s,a,t.s)):((d=s.edgeSign(e,n,t))+(a=-s.edgeSign(e,i,t))<0&&(d=-d,a=-a),r.s=s.interpolate(d,n.s,a,i.s)):r.s=(n.s+t.s)/2,s.transLeq(e,t)||(l=e,e=t,t=l),s.transLeq(n,i)||(l=n,n=i,i=l),s.transLeq(e,n)||(l=e,e=n,n=l,l=t,t=i,i=l),s.transLeq(n,t)?s.transLeq(t,i)?((d=s.transEval(e,n,t))+(a=s.transEval(n,t,i))<0&&(d=-d,a=-a),r.t=s.interpolate(d,n.t,a,t.t)):((d=s.transSign(e,n,t))+(a=-s.transSign(e,i,t))<0&&(d=-d,a=-a),r.t=s.interpolate(d,n.t,a,i.t)):r.t=(n.t+t.t)/2}}class r{constructor(){this.next=null,this.prev=null,this.anEdge=null,this.trail=null,this.n=0,this.marked=!1,this.inside=!1}}class d{constructor(e){this.side=e,this.next=null,this.Org=null,this.Sym=null,this.Onext=null,this.Lnext=null,this.Lface=null,this.activeRegion=null,this.winding=0}get Rface(){return this.Sym.Lface}set Rface(e){this.Sym.Lface=e}get Dst(){return this.Sym.Org}set Dst(e){this.Sym.Org=e}get Oprev(){return this.Sym.Lnext}set Oprev(e){this.Sym.Lnext=e}get Lprev(){return this.Onext.Sym}set Lprev(e){this.Onext.Sym=e}get Dprev(){return this.Lnext.Sym}set Dprev(e){this.Lnext.Sym=e}get Rprev(){return this.Sym.Onext}set Rprev(e){this.Sym.Onext=e}get Dnext(){return this.Sym.Onext.Sym}set Dnext(e){this.Sym.Onext.Sym=e}get Rnext(){return this.Sym.Lnext.Sym}set Rnext(e){this.Sym.Lnext.Sym=e}}class a{constructor(){this.next=null,this.prev=null,this.anEdge=null,this.coords=[0,0,0],this.s=0,this.t=0,this.pqHandle=0,this.n=0,this.idx=0}}class l{constructor(){const e=new a,t=new r,n=new d(0),i=new d(1);e.next=e.prev=e,e.anEdge=null,t.next=t.prev=t,n.next=n,n.Sym=i,i.next=i,i.Sym=n,this.vHead=e,this.fHead=t,this.eHead=n,this.eHeadSym=i}makeEdge_(e){var t=new d(0),n=new d(1);e.Sym.side<e.side&&(e=e.Sym);var i=e.Sym.next;return n.next=i,i.Sym.next=t,t.next=e,e.Sym.next=n,t.Sym=n,t.Onext=t,t.Lnext=n,t.Org=null,t.Lface=null,t.winding=0,t.activeRegion=null,n.Sym=t,n.Onext=n,n.Lnext=t,n.Org=null,n.Lface=null,n.winding=0,n.activeRegion=null,t}splice_(e,t){var n=e.Onext,i=t.Onext;n.Sym.Lnext=t,i.Sym.Lnext=e,e.Onext=i,t.Onext=n}makeVertex_(e,t,n){var s=e;i(s,"Vertex can't be null!");var r=n.prev;s.prev=r,r.next=s,s.next=n,n.prev=s,s.anEdge=t;var d=t;do{d.Org=s,d=d.Onext}while(d!==t)}makeFace_(e,t,n){var s=e;i(s,"Face can't be null");var r=n.prev;s.prev=r,r.next=s,s.next=n,n.prev=s,s.anEdge=t,s.trail=null,s.marked=!1,s.inside=n.inside;var d=t;do{d.Lface=s,d=d.Lnext}while(d!==t)}killEdge_(e){e.Sym.side<e.side&&(e=e.Sym);var t=e.next,n=e.Sym.next;t.Sym.next=n,n.Sym.next=t}killVertex_(e,t){var n=e.anEdge,i=n;do{i.Org=t,i=i.Onext}while(i!==n);var s=e.prev,r=e.next;r.prev=s,s.next=r}killFace_(e,t){var n=e.anEdge,i=n;do{i.Lface=t,i=i.Lnext}while(i!==n);var s=e.prev,r=e.next;r.prev=s,s.next=r}makeEdge(){var e=new a,t=new a,n=new r,i=this.makeEdge_(this.eHead);return this.makeVertex_(e,i,this.vHead),this.makeVertex_(t,i.Sym,this.vHead),this.makeFace_(n,i,this.fHead),i}splice(e,t){var n=!1,i=!1;if(e!==t){if(t.Org!==e.Org&&(i=!0,this.killVertex_(t.Org,e.Org)),t.Lface!==e.Lface&&(n=!0,this.killFace_(t.Lface,e.Lface)),this.splice_(t,e),!i){var s=new a;this.makeVertex_(s,t,e.Org),e.Org.anEdge=e}if(!n){var d=new r;this.makeFace_(d,t,e.Lface),e.Lface.anEdge=e}}}delete(e){var t=e.Sym,n=!1;if(e.Lface!==e.Rface&&(n=!0,this.killFace_(e.Lface,e.Rface)),e.Onext===e)this.killVertex_(e.Org,null);else if(e.Rface.anEdge=e.Oprev,e.Org.anEdge=e.Onext,this.splice_(e,e.Oprev),!n){var i=new r;this.makeFace_(i,e,e.Lface)}t.Onext===t?(this.killVertex_(t.Org,null),this.killFace_(t.Lface,null)):(e.Lface.anEdge=t.Oprev,t.Org.anEdge=t.Onext,this.splice_(t,t.Oprev)),this.killEdge_(e)}addEdgeVertex(e){var t=this.makeEdge_(e),n=t.Sym;this.splice_(t,e.Lnext),t.Org=e.Dst;var i=new a;return this.makeVertex_(i,n,t.Org),t.Lface=n.Lface=e.Lface,t}splitEdge(e){var t=this.addEdgeVertex(e).Sym;return this.splice_(e.Sym,e.Sym.Oprev),this.splice_(e.Sym,t),e.Dst=t.Org,t.Dst.anEdge=t.Sym,t.Rface=e.Rface,t.winding=e.winding,t.Sym.winding=e.Sym.winding,t}connect(e,t){var n=!1,i=this.makeEdge_(e),s=i.Sym;if(t.Lface!==e.Lface&&(n=!0,this.killFace_(t.Lface,e.Lface)),this.splice_(i,e.Lnext),this.splice_(s,t),i.Org=e.Dst,s.Org=t.Org,i.Lface=s.Lface=e.Lface,e.Lface.anEdge=s,!n){var d=new r;this.makeFace_(d,i,e.Lface)}return i}zapFace(e){var t,n,i,s,r,d=e.anEdge;n=d.Lnext;do{n=(t=n).Lnext,t.Lface=null,null===t.Rface&&(t.Onext===t?this.killVertex_(t.Org,null):(t.Org.anEdge=t.Onext,this.splice_(t,t.Oprev)),(i=t.Sym).Onext===i?this.killVertex_(i.Org,null):(i.Org.anEdge=i.Onext,this.splice_(i,i.Oprev)),this.killEdge_(t))}while(t!=d);s=e.prev,(r=e.next).prev=s,s.next=r}countFaceVerts_(e){var t=e.anEdge,n=0;do{n++,t=t.Lnext}while(t!==e.anEdge);return n}mergeConvexFaces(e){var t,n,i,r,d;for(t=this.fHead.next;t!==this.fHead;t=t.next)if(t.inside)for(d=(n=t.anEdge).Org;i=n.Lnext,(r=n.Sym)&&r.Lface&&r.Lface.inside&&this.countFaceVerts_(t)+this.countFaceVerts_(r.Lface)-2<=e&&s.vertCCW(n.Lprev.Org,n.Org,r.Lnext.Lnext.Org)&&s.vertCCW(r.Lprev.Org,r.Org,n.Lnext.Lnext.Org)&&(i=r.Lnext,this.delete(r),n=null,r=null),!n||n.Lnext.Org!==d;)n=i;return!0}check(){var e,t,n,s,r,d,a=this.fHead,l=this.vHead,h=this.eHead;for(t=a,t=a;(e=t.next)!==a;t=e){i(e.prev===t),r=e.anEdge;do{i(r.Sym!==r),i(r.Sym.Sym===r),i(r.Lnext.Onext.Sym===r),i(r.Onext.Sym.Lnext===r),i(r.Lface===e),r=r.Lnext}while(r!==e.anEdge)}for(i(e.prev===t&&null===e.anEdge),s=l,s=l;(n=s.next)!==l;s=n){i(n.prev===s),r=n.anEdge;do{i(r.Sym!==r),i(r.Sym.Sym===r),i(r.Lnext.Onext.Sym===r),i(r.Onext.Sym.Lnext===r),i(r.Org===n),r=r.Onext}while(r!==n.anEdge)}for(i(n.prev===s&&null===n.anEdge),d=h,d=h;(r=d.next)!==h;d=r)i(r.Sym.next===d.Sym),i(r.Sym!==r),i(r.Sym.Sym===r),i(null!==r.Org),i(null!==r.Dst),i(r.Lnext.Onext.Sym===r),i(r.Onext.Sym.Lnext===r);i(r.Sym.next===d.Sym&&r.Sym===this.eHeadSym&&r.Sym.Sym===r&&null===r.Org&&null===r.Dst&&null===r.Lface&&null===r.Rface)}}class h{constructor(){this.handle=null}}class o{constructor(){this.key=null,this.node=0}}class g{constructor(e,t){this.leq=t,this.max=0,this.nodes=[],this.handles=[],this.initialized=!1,this.freeList=0,this.size=0,this.max=e,this.nodes=[],this.handles=[];for(let t=0;t<e+1;t++)this.nodes[t]=new h,this.handles[t]=new o;this.initialized=!1,this.nodes[1].handle=1,this.handles[1].key=null}floatDown_(e){var t,n,s,r=this.nodes,d=this.handles;for(t=r[e].handle;;){if((s=e<<1)<this.size&&this.leq(d[r[s+1].handle].key,d[r[s].handle].key)&&++s,i(s<=this.max),n=r[s].handle,s>this.size||this.leq(d[t].key,d[n].key)){r[e].handle=t,d[t].node=e;break}r[e].handle=n,d[n].node=e,e=s}}floatUp_(e){var t,n,i,s=this.nodes,r=this.handles;for(t=s[e].handle;;){if(n=s[i=e>>1].handle,0===i||this.leq(r[n].key,r[t].key)){s[e].handle=t,r[t].node=e;break}s[e].handle=n,r[n].node=e,e=i}}init(){for(let e=this.size;e>=1;--e)this.floatDown_(e);this.initialized=!0}min(){return this.handles[this.nodes[1].handle].key}insert(e){var t,n;if(2*(t=++this.size)>this.max){var i,s;for(this.max*=2,s=this.nodes.length,this.nodes.length=this.max+1,i=s;i<this.nodes.length;i++)this.nodes[i]=new h;for(s=this.handles.length,this.handles.length=this.max+1,i=s;i<this.handles.length;i++)this.handles[i]=new o}return 0===this.freeList?n=t:(n=this.freeList,this.freeList=this.handles[n].node),this.nodes[t].handle=n,this.handles[n].node=t,this.handles[n].key=e,this.initialized&&this.floatUp_(t),n}extractMin(){var e=this.nodes,t=this.handles,n=e[1].handle,i=t[n].key;return this.size>0&&(e[1].handle=e[this.size].handle,t[e[1].handle].node=1,t[n].key=null,t[n].node=this.freeList,this.freeList=n,--this.size,this.size>0&&this.floatDown_(1)),i}delete(e){var t,n=this.nodes,s=this.handles;i(e>=1&&e<=this.max&&null!==s[e].key),n[t=s[e].node].handle=n[this.size].handle,s[n[t].handle].node=t,--this.size,t<=this.size&&(t<=1||this.leq(s[n[t>>1].handle].key,s[n[t].handle].key)?this.floatDown_(t):this.floatUp_(t)),s[e].key=null,s[e].node=this.freeList,this.freeList=e}}class c{constructor(){this.eUp=null,this.nodeUp=null,this.windingNumber=0,this.inside=!1,this.sentinel=!1,this.dirty=!1,this.fixUpperEdge=!1}}class v{constructor(){this.key=null,this.next=null,this.prev=null}}class x{constructor(e,t){this.frame=e,this.leq=t,this.head=new v,this.head.next=this.head,this.head.prev=this.head}min(){return this.head.next}max(){return this.head.prev}insert(e){return this.insertBefore(this.head,e)}search(e){let t=this.head;do{t=t.next}while(null!==t.key&&!this.leq(this.frame,e,t.key));return t}insertBefore(e,t){do{e=e.prev}while(null!==e.key&&!this.leq(this.frame,e.key,t));const n=new v;return n.key=t,n.next=e.next,e.next.prev=n,n.prev=e,e.next=n,n}delete(e){e.next.prev=e.prev,e.prev.next=e.next}}class m{static regionBelow(e){return e.nodeUp.prev.key}static regionAbove(e){return e.nodeUp.next.key}static debugEvent(e){}static addWinding(e,t){e.winding+=t.winding,e.Sym.winding+=t.Sym.winding}static edgeLeq(e,t,n){var i=e.event,r=t.eUp,d=n.eUp;if(r.Dst===i)return d.Dst===i?s.vertLeq(r.Org,d.Org)?s.edgeSign(d.Dst,r.Org,d.Org)<=0:s.edgeSign(r.Dst,d.Org,r.Org)>=0:s.edgeSign(d.Dst,i,d.Org)<=0;if(d.Dst===i)return s.edgeSign(r.Dst,i,r.Org)>=0;return s.edgeEval(r.Dst,i,r.Org)>=s.edgeEval(d.Dst,i,d.Org)}static deleteRegion(e,t){t.fixUpperEdge&&i(0===t.eUp.winding),t.eUp.activeRegion=null,e.dict.delete(t.nodeUp)}static fixUpperEdge(e,t,n){i(t.fixUpperEdge),e.mesh.delete(t.eUp),t.fixUpperEdge=!1,t.eUp=n,n.activeRegion=t}static topLeftRegion(e,t){var n,i=t.eUp.Org;do{t=m.regionAbove(t)}while(t.eUp.Org===i);if(t.fixUpperEdge){if(null===(n=e.mesh.connect(m.regionBelow(t).eUp.Sym,t.eUp.Lnext)))return null;m.fixUpperEdge(e,t,n),t=m.regionAbove(t)}return t}static topRightRegion(e){var t=e.eUp.Dst;do{e=m.regionAbove(e)}while(e.eUp.Dst===t);return e}static addRegionBelow(e,t,n){var i=new c;return i.eUp=n,i.nodeUp=e.dict.insertBefore(t.nodeUp,i),i.fixUpperEdge=!1,i.sentinel=!1,i.dirty=!1,n.activeRegion=i,i}static isWindingInside(t,n){switch(t.windingRule){case e.WINDING.ODD:return 0!=(1&n);case e.WINDING.NONZERO:return 0!==n;case e.WINDING.POSITIVE:return n>0;case e.WINDING.NEGATIVE:return n<0;case e.WINDING.ABS_GEQ_TWO:return n>=2||n<=-2}throw new Error("Invalid winding rulle")}static computeWinding(e,t){t.windingNumber=m.regionAbove(t).windingNumber+t.eUp.winding,t.inside=m.isWindingInside(e,t.windingNumber)}static finishRegion(e,t){var n=t.eUp,i=n.Lface;i.inside=t.inside,i.anEdge=n,m.deleteRegion(e,t)}static finishLeftRegions(e,t,n){for(var i,s=null,r=t,d=t.eUp;r!==n;){if(r.fixUpperEdge=!1,(i=(s=m.regionBelow(r)).eUp).Org!=d.Org){if(!s.fixUpperEdge){m.finishRegion(e,r);break}i=e.mesh.connect(d.Lprev,i.Sym),m.fixUpperEdge(e,s,i)}d.Onext!==i&&(e.mesh.splice(i.Oprev,i),e.mesh.splice(d,i)),m.finishRegion(e,r),d=s.eUp,r=s}return d}static addRightEdges(e,t,n,r,d,a){var l,h,o,g,c=!0;o=n;do{i(s.vertLeq(o.Org,o.Dst)),m.addRegionBelow(e,t,o.Sym),o=o.Onext}while(o!==r);for(null===d&&(d=m.regionBelow(t).eUp.Rprev),h=t,g=d;(o=(l=m.regionBelow(h)).eUp.Sym).Org===g.Org;)o.Onext!==g&&(e.mesh.splice(o.Oprev,o),e.mesh.splice(g.Oprev,o)),l.windingNumber=h.windingNumber-o.winding,l.inside=m.isWindingInside(e,l.windingNumber),h.dirty=!0,!c&&m.checkForRightSplice(e,h)&&(m.addWinding(o,g),m.deleteRegion(e,h),e.mesh.delete(g)),c=!1,h=l,g=o;h.dirty=!0,i(h.windingNumber-o.winding===l.windingNumber),a&&m.walkDirtyRegions(e,h)}static spliceMergeVertices(e,t,n){e.mesh.splice(t,n)}static vertexWeights(e,t,n){var i=s.vertL1dist(t,e),r=s.vertL1dist(n,e),d=.5*r/(i+r),a=.5*i/(i+r);e.coords[0]+=d*t.coords[0]+a*n.coords[0],e.coords[1]+=d*t.coords[1]+a*n.coords[1],e.coords[2]+=d*t.coords[2]+a*n.coords[2]}static getIntersectData(e,t,n,i,s,r){t.coords[0]=t.coords[1]=t.coords[2]=0,t.idx=-1,m.vertexWeights(t,n,i),m.vertexWeights(t,s,r)}static checkForRightSplice(e,t){var n=m.regionBelow(t),i=t.eUp,r=n.eUp;if(s.vertLeq(i.Org,r.Org)){if(s.edgeSign(r.Dst,i.Org,r.Org)>0)return!1;s.vertEq(i.Org,r.Org)?i.Org!==r.Org&&(e.pq.delete(i.Org.pqHandle),m.spliceMergeVertices(e,r.Oprev,i)):(e.mesh.splitEdge(r.Sym),e.mesh.splice(i,r.Oprev),t.dirty=n.dirty=!0)}else{if(s.edgeSign(i.Dst,r.Org,i.Org)<0)return!1;m.regionAbove(t).dirty=t.dirty=!0,e.mesh.splitEdge(i.Sym),e.mesh.splice(r.Oprev,i)}return!0}static checkForLeftSplice(e,t){var n,r=m.regionBelow(t),d=t.eUp,a=r.eUp;if(i(!s.vertEq(d.Dst,a.Dst)),s.vertLeq(d.Dst,a.Dst)){if(s.edgeSign(d.Dst,a.Dst,d.Org)<0)return!1;m.regionAbove(t).dirty=t.dirty=!0,n=e.mesh.splitEdge(d),e.mesh.splice(a.Sym,n),n.Lface.inside=t.inside}else{if(s.edgeSign(a.Dst,d.Dst,a.Org)>0)return!1;t.dirty=r.dirty=!0,n=e.mesh.splitEdge(a),e.mesh.splice(d.Lnext,a.Sym),n.Rface.inside=t.inside}return!0}static checkForIntersect(e,t){var n,r,d=m.regionBelow(t),l=t.eUp,h=d.eUp,o=l.Org,g=h.Org,c=l.Dst,v=h.Dst,x=new a;if(i(!s.vertEq(v,c)),i(s.edgeSign(c,e.event,o)<=0),i(s.edgeSign(v,e.event,g)>=0),i(o!==e.event&&g!==e.event),i(!t.fixUpperEdge&&!d.fixUpperEdge),o===g)return!1;if(Math.min(o.t,c.t)>Math.max(g.t,v.t))return!1;if(s.vertLeq(o,g)){if(s.edgeSign(v,o,g)>0)return!1}else if(s.edgeSign(c,g,o)<0)return!1;return m.debugEvent(e),s.intersect(c,o,v,g,x),i(Math.min(o.t,c.t)<=x.t),i(x.t<=Math.max(g.t,v.t)),i(Math.min(v.s,c.s)<=x.s),i(x.s<=Math.max(g.s,o.s)),s.vertLeq(x,e.event)&&(x.s=e.event.s,x.t=e.event.t),n=s.vertLeq(o,g)?o:g,s.vertLeq(n,x)&&(x.s=n.s,x.t=n.t),s.vertEq(x,o)||s.vertEq(x,g)?(m.checkForRightSplice(e,t),!1):!s.vertEq(c,e.event)&&s.edgeSign(c,e.event,x)>=0||!s.vertEq(v,e.event)&&s.edgeSign(v,e.event,x)<=0?v===e.event?(e.mesh.splitEdge(l.Sym),e.mesh.splice(h.Sym,l),t=m.topLeftRegion(e,t),l=m.regionBelow(t).eUp,m.finishLeftRegions(e,m.regionBelow(t),d),m.addRightEdges(e,t,l.Oprev,l,l,!0),!0):c===e.event?(e.mesh.splitEdge(h.Sym),e.mesh.splice(l.Lnext,h.Oprev),d=t,t=m.topRightRegion(t),r=m.regionBelow(t).eUp.Rprev,d.eUp=h.Oprev,h=m.finishLeftRegions(e,d,null),m.addRightEdges(e,t,h.Onext,l.Rprev,r,!0),!0):(s.edgeSign(c,e.event,x)>=0&&(m.regionAbove(t).dirty=t.dirty=!0,e.mesh.splitEdge(l.Sym),l.Org.s=e.event.s,l.Org.t=e.event.t),s.edgeSign(v,e.event,x)<=0&&(t.dirty=d.dirty=!0,e.mesh.splitEdge(h.Sym),h.Org.s=e.event.s,h.Org.t=e.event.t),!1):(e.mesh.splitEdge(l.Sym),e.mesh.splitEdge(h.Sym),e.mesh.splice(h.Oprev,l),l.Org.s=x.s,l.Org.t=x.t,l.Org.pqHandle=e.pq.insert(l.Org),m.getIntersectData(e,l.Org,o,c,g,v),m.regionAbove(t).dirty=t.dirty=d.dirty=!0,!1)}static walkDirtyRegions(e,t){for(var n,i,s=m.regionBelow(t);;){for(;s.dirty;)t=s,s=m.regionBelow(s);if(!t.dirty&&(s=t,null===(t=m.regionAbove(t))||!t.dirty))return;if(t.dirty=!1,n=t.eUp,i=s.eUp,n.Dst!==i.Dst&&m.checkForLeftSplice(e,t)&&(s.fixUpperEdge?(m.deleteRegion(e,s),e.mesh.delete(i),i=(s=m.regionBelow(t)).eUp):t.fixUpperEdge&&(m.deleteRegion(e,t),e.mesh.delete(n),n=(t=m.regionAbove(s)).eUp)),n.Org!==i.Org)if(n.Dst===i.Dst||t.fixUpperEdge||s.fixUpperEdge||n.Dst!==e.event&&i.Dst!==e.event)m.checkForRightSplice(e,t);else if(m.checkForIntersect(e,t))return;n.Org===i.Org&&n.Dst===i.Dst&&(m.addWinding(i,n),m.deleteRegion(e,t),e.mesh.delete(n),t=m.regionAbove(s))}}static connectRightVertex(e,t,n){var i,r=n.Onext,d=m.regionBelow(t),a=t.eUp,l=d.eUp,h=!1;a.Dst!==l.Dst&&m.checkForIntersect(e,t),s.vertEq(a.Org,e.event)&&(e.mesh.splice(r.Oprev,a),t=m.topLeftRegion(e,t),r=m.regionBelow(t).eUp,m.finishLeftRegions(e,m.regionBelow(t),d),h=!0),s.vertEq(l.Org,e.event)&&(e.mesh.splice(n,l.Oprev),n=m.finishLeftRegions(e,d,null),h=!0),h?m.addRightEdges(e,t,n.Onext,r,r,!0):(i=s.vertLeq(l.Org,a.Org)?l.Oprev:a,i=e.mesh.connect(n.Lprev,i),m.addRightEdges(e,t,i,i.Onext,i.Onext,!1),i.Sym.activeRegion.fixUpperEdge=!0,m.walkDirtyRegions(e,t))}static connectLeftDegenerate(e,t,n){var r,d,a,l,h;return r=t.eUp,s.vertEq(r.Org,n)?(i(!1),void m.spliceMergeVertices(e,r,n.anEdge)):s.vertEq(r.Dst,n)?(i(!1),t=m.topRightRegion(t),d=l=(a=(h=m.regionBelow(t)).eUp.Sym).Onext,h.fixUpperEdge&&(i(d!==a),m.deleteRegion(e,h),e.mesh.delete(a),a=d.Oprev),e.mesh.splice(n.anEdge,a),s.edgeGoesLeft(d)||(d=null),void m.addRightEdges(e,t,a.Onext,l,d,!0)):(e.mesh.splitEdge(r.Sym),t.fixUpperEdge&&(e.mesh.delete(r.Onext),t.fixUpperEdge=!1),e.mesh.splice(n.anEdge,r),void m.sweepEvent(e,n))}static connectLeftVertex(e,t){var n,i,r,d,a,l,h=new c;if(h.eUp=t.anEdge.Sym,n=e.dict.search(h).key,i=m.regionBelow(n))if(d=n.eUp,a=i.eUp,0!==s.edgeSign(d.Dst,t,d.Org))if(r=s.vertLeq(a.Dst,d.Dst)?n:i,n.inside||r.fixUpperEdge){if(r===n)l=e.mesh.connect(t.anEdge.Sym,d.Lnext);else l=e.mesh.connect(a.Dnext,t.anEdge).Sym;r.fixUpperEdge?m.fixUpperEdge(e,r,l):m.computeWinding(e,m.addRegionBelow(e,n,l)),m.sweepEvent(e,t)}else m.addRightEdges(e,n,t.anEdge,t.anEdge,null,!0);else m.connectLeftDegenerate(e,n,t)}static sweepEvent(e,t){e.event=t,m.debugEvent(e);for(var n=t.anEdge;null===n.activeRegion;)if((n=n.Onext)===t.anEdge)return void m.connectLeftVertex(e,t);var s=m.topLeftRegion(e,n.activeRegion);i(null!==s);var r=m.regionBelow(s),d=r.eUp,a=m.finishLeftRegions(e,r,null);a.Onext===d?m.connectRightVertex(e,s,a):m.addRightEdges(e,s,a.Onext,d,d,!0)}static addSentinel(e,t,n,i){var s=new c,r=e.mesh.makeEdge();r.Org.s=n,r.Org.t=i,r.Dst.s=t,r.Dst.t=i,e.event=r.Dst,s.eUp=r,s.windingNumber=0,s.inside=!1,s.fixUpperEdge=!1,s.sentinel=!0,s.dirty=!1,s.nodeUp=e.dict.insert(s)}static initEdgeDict(e){e.dict=new x(e,m.edgeLeq);var t=e.bmax[0]-e.bmin[0],n=e.bmax[1]-e.bmin[1],i=e.bmin[0]-t,s=e.bmax[0]+t,r=e.bmin[1]-n,d=e.bmax[1]+n;m.addSentinel(e,i,s,r),m.addSentinel(e,i,s,d)}static doneEdgeDict(e){for(var t,n=0;null!==(t=e.dict.min().key);)t.sentinel||(i(t.fixUpperEdge),i(1==++n)),i(0===t.windingNumber),m.deleteRegion(e,t)}static removeDegenerateEdges(e){var t,n,i,r=e.mesh.eHead;for(t=r.next;t!==r;t=n)n=t.next,i=t.Lnext,s.vertEq(t.Org,t.Dst)&&t.Lnext.Lnext!==t&&(m.spliceMergeVertices(e,i,t),e.mesh.delete(t),i=(t=i).Lnext),i.Lnext===t&&(i!==t&&(i!==n&&i!==n.Sym||(n=n.next),e.mesh.delete(i)),t!==n&&t!==n.Sym||(n=n.next),e.mesh.delete(t))}static initPriorityQ(e){var t,n,i,r=0;for(n=(i=e.mesh.vHead).next;n!==i;n=n.next)r++;for(r+=8,t=e.pq=new g(r,s.vertLeq),n=(i=e.mesh.vHead).next;n!==i;n=n.next)n.pqHandle=t.insert(n);return n===i&&(t.init(),!0)}static donePriorityQ(e){e.pq=null}static removeDegenerateFaces(e,t){var n,s,r;for(n=t.fHead.next;n!==t.fHead;n=s)s=n.next,i((r=n.anEdge).Lnext!==r),r.Lnext.Lnext===r&&(m.addWinding(r.Onext,r),e.mesh.delete(r));return!0}static computeInterior(e,t=!0){var n,i;if(m.removeDegenerateEdges(e),!m.initPriorityQ(e))return!1;for(m.initEdgeDict(e);null!==(n=e.pq.extractMin());){for(;null!==(i=e.pq.min())&&s.vertEq(i,n);)i=e.pq.extractMin(),m.spliceMergeVertices(e,n.anEdge,i.anEdge);m.sweepEvent(e,n)}return e.event=e.dict.min().key.eUp.Org,m.debugEvent(e),m.doneEdgeDict(e),m.donePriorityQ(e),!!m.removeDegenerateFaces(e,e.mesh)&&(t&&e.mesh.check(),!0)}}class p{constructor(){this.mesh=new l,this.normal=[0,0,0],this.sUnit=[0,0,0],this.tUnit=[0,0,0],this.bmin=[0,0],this.bmax=[0,0],this.windingRule=e.WINDING.ODD,this.dict=null,this.pq=null,this.event=null,this.vertexIndexCounter=0,this.vertices=[],this.vertexIndices=[],this.vertexCount=0,this.elements=[],this.elementCount=0}dot_(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}normalize_(e){let t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2];if(!t)throw"Zero-size vector!";t=Math.sqrt(t),e[0]/=t,e[1]/=t,e[2]/=t}longAxis_(e){let t=0;return Math.abs(e[1])>Math.abs(e[0])&&(t=1),Math.abs(e[2])>Math.abs(e[t])&&(t=2),t}computeNormal_(e){let t,n,i,s,r,d,a=[0,0,0],l=[0,0,0],h=[0,0,0],o=[0,0,0],g=[0,0,0];const c=[null,null,null],v=[null,null,null],x=this.mesh.vHead;t=x.next;for(let e=0;e<3;++e)s=t.coords[e],l[e]=s,v[e]=t,a[e]=s,c[e]=t;for(t=x.next;t!==x;t=t.next)for(let e=0;e<3;++e)s=t.coords[e],s<l[e]&&(l[e]=s,v[e]=t),s>a[e]&&(a[e]=s,c[e]=t);let m=0;if(a[1]-l[1]>a[0]-l[0]&&(m=1),a[2]-l[2]>a[m]-l[m]&&(m=2),l[m]>=a[m])return e[0]=0,e[1]=0,void(e[2]=1);for(d=0,n=v[m],i=c[m],h[0]=n.coords[0]-i.coords[0],h[1]=n.coords[1]-i.coords[1],h[2]=n.coords[2]-i.coords[2],t=x.next;t!==x;t=t.next)o[0]=t.coords[0]-i.coords[0],o[1]=t.coords[1]-i.coords[1],o[2]=t.coords[2]-i.coords[2],g[0]=h[1]*o[2]-h[2]*o[1],g[1]=h[2]*o[0]-h[0]*o[2],g[2]=h[0]*o[1]-h[1]*o[0],r=g[0]*g[0]+g[1]*g[1]+g[2]*g[2],r>d&&(d=r,e[0]=g[0],e[1]=g[1],e[2]=g[2]);d<=0&&(e[0]=e[1]=e[2]=0,e[this.longAxis_(h)]=1)}checkOrientation_(){var e,t,n=this.mesh.fHead,i=this.mesh.vHead;let s=0;for(let e=n.next;e!==n;e=e.next)if(!((t=e.anEdge).winding<=0))do{s+=(t.Org.s-t.Dst.s)*(t.Org.t+t.Dst.t),t=t.Lnext}while(t!==e.anEdge);if(s<0){for(e=i.next;e!==i;e=e.next)e.t=-e.t;this.tUnit[0]=-this.tUnit[0],this.tUnit[1]=-this.tUnit[1],this.tUnit[2]=-this.tUnit[2]}}projectPolygon_(){let e,t,n=this.mesh.vHead,i=[0,0,0],s=!1;i[0]=this.normal[0],i[1]=this.normal[1],i[2]=this.normal[2],i[0]||i[1]||i[2]||(this.computeNormal_(i),s=!0),e=this.sUnit,t=this.tUnit;let r=this.longAxis_(i);e[r]=0,e[(r+1)%3]=1,e[(r+2)%3]=0,t[r]=0,t[(r+1)%3]=0,t[(r+2)%3]=i[r]>0?1:-1;for(let i=n.next;i!==n;i=i.next)i.s=this.dot_(i.coords,e),i.t=this.dot_(i.coords,t);s&&this.checkOrientation_();let d=!0;for(let e=n.next;e!==n;e=e.next)d?(this.bmin[0]=this.bmax[0]=e.s,this.bmin[1]=this.bmax[1]=e.t,d=!1):(e.s<this.bmin[0]&&(this.bmin[0]=e.s),e.s>this.bmax[0]&&(this.bmax[0]=e.s),e.t<this.bmin[1]&&(this.bmin[1]=e.t),e.t>this.bmax[1]&&(this.bmax[1]=e.t))}addWinding_(e,t){e.winding+=t.winding,e.Sym.winding+=t.Sym.winding}tessellateMonoRegion_(e,t){let n,i;if(n=t.anEdge,n.Lnext===n||n.Lnext.Lnext===n)throw"Mono region invalid";for(;s.vertLeq(n.Dst,n.Org);n=n.Lprev);for(;s.vertLeq(n.Org,n.Dst);n=n.Lnext);i=n.Lprev;let r=void 0;for(;n.Lnext!==i;)if(s.vertLeq(n.Dst,i.Org)){for(;i.Lnext!==n&&(s.edgeGoesLeft(i.Lnext)||s.edgeSign(i.Org,i.Dst,i.Lnext.Dst)<=0);)r=e.connect(i.Lnext,i),i=r.Sym;i=i.Lprev}else{for(;i.Lnext!==n&&(s.edgeGoesRight(n.Lprev)||s.edgeSign(n.Dst,n.Org,n.Lprev.Org)>=0);)r=e.connect(n,n.Lprev),n=r.Sym;n=n.Lnext}if(i.Lnext===n)throw"Mono region invalid";for(;i.Lnext.Lnext!==n;)r=e.connect(i.Lnext,i),i=r.Sym;return!0}tessellateInterior_(e){let t;for(let n=e.fHead.next;n!==e.fHead;n=t)if(t=n.next,n.inside&&!this.tessellateMonoRegion_(e,n))return!1;return!0}discardExterior_(e){let t;for(let n=e.fHead.next;n!==e.fHead;n=t)t=n.next,n.inside||e.zapFace(n)}setWindingNumber_(e,t,n){let i;for(let s=e.eHead.next;s!==e.eHead;s=i)i=s.next,s.Rface.inside!==s.Lface.inside?s.winding=s.Lface.inside?t:-t:n?e.delete(s):s.winding=0}getNeighbourFace_(e){return e.Rface&&e.Rface.inside?e.Rface.n:-1}outputPolymesh_(t,n,i,s){let r,d,a=0,l=0;i>3&&t.mergeConvexFaces(i);for(let e=t.vHead.next;e!==t.vHead;e=e.next)e.n=-1;for(let e=t.fHead.next;e!==t.fHead;e=e.next)if(e.n=-1,e.inside){r=e.anEdge,d=0;do{let e=r.Org;-1===e.n&&(e.n=l,l++),d++,r=r.Lnext}while(r!==e.anEdge);if(d>i)throw"Face vertex greater that support polygon";e.n=a,++a}this.elementCount=a,n===e.ELEMENT.CONNECTED_POLYGONS&&(a*=2),this.elements=[],this.elements.length=a*i,this.vertexCount=l,this.vertices=[],this.vertices.length=l*s,this.vertexIndices=[],this.vertexIndices.length=l;for(let e=t.vHead.next;e!==t.vHead;e=e.next)if(-1!==e.n){var h=e.n*s;this.vertices[h+0]=e.coords[0],this.vertices[h+1]=e.coords[1],s>2&&(this.vertices[h+2]=e.coords[2]),this.vertexIndices[e.n]=e.idx}let o=0;for(let s=t.fHead.next;s!==t.fHead;s=s.next)if(s.inside){r=s.anEdge,d=0;do{let e=r.Org;this.elements[o++]=e.n,d++,r=r.Lnext}while(r!==s.anEdge);for(let e=d;e<i;++e)this.elements[o++]=-1;if(n===e.ELEMENT.CONNECTED_POLYGONS){r=s.anEdge;do{this.elements[o++]=this.getNeighbourFace_(r),r=r.Lnext}while(r!==s.anEdge);for(let e=d;e<i;++e)this.elements[o++]=-1}}}outputContours_(e,t){let n,i,s=0,r=0;this.vertexCount=0,this.elementCount=0;for(let t=e.fHead.next;t!==e.fHead;t=t.next)if(t.inside){i=n=t.anEdge;do{this.vertexCount++,n=n.Lnext}while(n!==i);this.elementCount++}this.elements=[],this.elements.length=2*this.elementCount,this.vertices=[],this.vertices.length=this.vertexCount*t,this.vertexIndices=[],this.vertexIndices.length=this.vertexCount;let d=0,a=0,l=0;s=0;for(let h=e.fHead.next;h!==e.fHead;h=h.next)if(h.inside){r=0,i=n=h.anEdge;do{this.vertices[d++]=n.Org.coords[0],this.vertices[d++]=n.Org.coords[1],t>2&&(this.vertices[d++]=n.Org.coords[2]),this.vertexIndices[a++]=n.Org.idx,r++,n=n.Lnext}while(n!==i);this.elements[l++]=s,this.elements[l++]=r,s+=r}}addContour(e,t){null===this.mesh&&(this.mesh=new l),e<2&&(e=2),e>3&&(e=3);let n=null;for(let i=0;i<t.length;i+=e)null===n?(n=this.mesh.makeEdge(),this.mesh.splice(n,n.Sym)):(this.mesh.splitEdge(n),n=n.Lnext),n.Org.coords[0]=t[i+0],n.Org.coords[1]=t[i+1],n.Org.coords[2]=e>2?t[i+2]:0,n.Org.idx=this.vertexIndexCounter++,n.winding=1,n.Sym.winding=-1}tesselate(t=e.WINDING.ODD,n=e.ELEMENT.POLYGONS,i,s,r,d=!0){if(this.vertices=[],this.elements=[],this.vertexIndices=[],this.vertexIndexCounter=0,r&&(this.normal[0]=r[0],this.normal[1]=r[1],this.normal[2]=r[2]),this.windingRule=t,s<2&&(s=2),s>3&&(s=3),!this.mesh)return!1;this.projectPolygon_(),m.computeInterior(this,d);var a=this.mesh;return n===e.ELEMENT.BOUNDARY_CONTOURS?this.setWindingNumber_(a,1,!0):this.tessellateInterior_(a),d&&a.check(),n===e.ELEMENT.BOUNDARY_CONTOURS?this.outputContours_(a,s):this.outputPolymesh_(a,n,i,s),!0}}const O=e.WINDING.ODD,f=e.WINDING.NONZERO,u=e.WINDING.POSITIVE,E=e.WINDING.NEGATIVE,L=e.WINDING.ABS_GEQ_TWO,y=e.ELEMENT.POLYGONS,S=e.ELEMENT.CONNECTED_POLYGONS,w=e.ELEMENT.BOUNDARY_CONTOURS;return e.BOUNDARY_CONTOURS=w,e.CONNECTED_POLYGONS=S,e.POLYGONS=y,e.Tesselator=p,e.WINDING_ABS_GEQ_TWO=L,e.WINDING_NEGATIVE=E,e.WINDING_NONZERO=f,e.WINDING_ODD=O,e.WINDING_POSITIVE=u,e.tesselate=function({windingRule:t=e.WINDING.ODD,elementType:n=e.ELEMENT.POLYGONS,polySize:i=3,vertexSize:s=2,normal:r=[0,0,1],contours:d=[],strict:a=!0,debug:l=!1}){if(!d&&a)throw new Error("Contours can't be empty");if(!d)return;const h=new p;for(let e=0;e<d.length;e++)h.addContour(s||2,d[e]);return h.tesselate(t,n,i,s,r,a),{vertices:h.vertices,vertexIndices:h.vertexIndices,vertexCount:h.vertexCount,elements:h.elements,elementCount:h.elementCount,mesh:l?h.mesh:void 0}},e}({});

import { ActiveRegion } from "./../mesh/ActiveRegion";
import { TESSvertex } from "./../mesh/TESSvertex";
import { TESSmesh } from "../mesh/TESSmesh";
import { TESShalfEdge } from "../mesh/index";
import { Tesselator } from "../index";
export declare class Sweep {
    static regionBelow(r: ActiveRegion): any;
    static regionAbove(r: ActiveRegion): any;
    static debugEvent(tess: any): void;
    static addWinding(eDst: TESShalfEdge, eSrc: TESShalfEdge): void;
    static edgeLeq(tess: Tesselator, reg1: ActiveRegion, reg2: ActiveRegion): boolean;
    static deleteRegion(tess: Tesselator, reg: ActiveRegion): void;
    static fixUpperEdge(tess: Tesselator, reg: ActiveRegion, newEdge: TESShalfEdge): void;
    static topLeftRegion(tess: Tesselator, reg: ActiveRegion): ActiveRegion;
    static topRightRegion(reg: ActiveRegion): ActiveRegion;
    static addRegionBelow(tess: Tesselator, regAbove: ActiveRegion, eNewUp: TESShalfEdge): ActiveRegion;
    static isWindingInside(tess: Tesselator, n: number): boolean;
    static computeWinding(tess: Tesselator, reg: ActiveRegion): void;
    static finishRegion(tess: Tesselator, reg: ActiveRegion): void;
    static finishLeftRegions(tess: Tesselator, regFirst: ActiveRegion, regLast: ActiveRegion): TESShalfEdge;
    static addRightEdges(tess: Tesselator, regUp: ActiveRegion, eFirst: TESShalfEdge, eLast: TESShalfEdge, eTopLeft: TESShalfEdge, cleanUp: boolean): void;
    static spliceMergeVertices(tess: Tesselator, e1: TESShalfEdge, e2: TESShalfEdge): void;
    static vertexWeights(isect: TESSvertex, org: TESSvertex, dst: any): void;
    static getIntersectData(tess: Tesselator, isect: TESSvertex, orgUp: TESSvertex, dstUp: TESSvertex, orgLo: TESSvertex, dstLo: TESSvertex): void;
    static checkForRightSplice(tess: Tesselator, regUp: ActiveRegion): boolean;
    static checkForLeftSplice(tess: Tesselator, regUp: ActiveRegion): boolean;
    static checkForIntersect(tess: Tesselator, regUp: ActiveRegion): boolean;
    static walkDirtyRegions(tess: Tesselator, regUp: ActiveRegion): void;
    static connectRightVertex(tess: Tesselator, regUp: ActiveRegion, eBottomLeft: TESShalfEdge): void;
    static connectLeftDegenerate(tess: Tesselator, regUp: ActiveRegion, vEvent: TESSvertex): void;
    static connectLeftVertex(tess: Tesselator, vEvent: TESSvertex): void;
    static sweepEvent(tess: Tesselator, vEvent: TESSvertex): void;
    static addSentinel(tess: Tesselator, smin: number, smax: number, t: number): void;
    static initEdgeDict(tess: Tesselator): void;
    static doneEdgeDict(tess: Tesselator): void;
    static removeDegenerateEdges(tess: Tesselator): void;
    static initPriorityQ(tess: Tesselator): boolean;
    static donePriorityQ(tess: Tesselator): void;
    static removeDegenerateFaces(tess: Tesselator, mesh: TESSmesh): boolean;
    static computeInterior(tess: Tesselator, validate?: boolean): boolean;
}
